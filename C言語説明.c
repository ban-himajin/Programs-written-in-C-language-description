#include<stdio.h>

int load(int );
void makeup(int );
int error(int );
void exe(char );

int No=0;

int main (){
    puts("\nこのアプリは開発者の復習または記録をするために作っています");
    puts("なので少しミスや説明不足なところがあったら温かい目で見てください");
    puts("ちなみにうまく漢字が出力されないことがあります");
    puts("version a 1.1.0");
    puts("--<リスト>--");
    char x;
    while(1){
        int road=0;
        int y = load(road);
        while(No<=y && road<=100){
            printf("\n聞きたい説明の番号を入れてください(%dまで)\n", y - 1);
            scanf("%d", &No);
            if (1 <= No && No <= y - 1) {
                makeup(y);
                break;
            }
            if(road>=100){
                return error(road);
            }
            else road++;
        }
        puts("\n終わり");
        puts("まだ聞きたいものがある場合はy実行例を見たい場合はp(開発途中)");
        scanf("%s", &x);
        if(x == 'y'){
            continue;
        }
        if(x=='p'){
            if(y<=No){
                exe(x);
                puts("変数の変更を行いたい場合はt(使えるものと使えないものがあります)");
                scanf("%s", &x);
                if(x=='t')exe(x);
                continue;
            }
            else {
                puts("選択した番号は存在しないのでもう一度番号をしていしてください");
                continue;
            }
        }
        else break;
        
    }
    return 0;
}


int load(int road){//章表示
    int y=1;
    printf("#%d c言語の基本\n", y++);
    printf("#%d 変数の説明\n", y++);
    printf("#%d if(もしも)の説明\n", y++);
    printf("#%d 数字入力(質問)の説明\n", y++);
    printf("#%d switch(選択し)の説明\n", y++);
    printf("#%d for(〜回繰り返す)の説明\n", y++);
    printf("#%d while(ずっと)の説明\n", y++);
    printf("#%d else(ifとの応用)の説明\n", y++);
    printf("#%d 真偽を求める新しい式\n", y++);
    printf("#%d 空白を持つforの説明\n", y++);
    printf("#%d continueの説明と活用\n", y++);
    printf("#%d gotoの説明\n", y++);
    printf("#%d 変数の発展\n", y++);
    printf("#%d 一次元配列\n", y++);
    printf("#%d 多次元配列\n", y++);
    printf("#%d 文字列を変数に収納する方法\n", y++);
    printf("#%d 文字列の配列\n", y++);
    printf("#%d ポインタ変数\n", y++);
    printf("#%d ポインタ演算\n", y++);
    printf("#%d 配列とポインタ\n", y++);
    printf("#%d 文字列ポインタ\n", y++);
    printf("#%d 文字列ポインタ\n", y++);
    printf("#%d ポインタのポインタ\n", y++);
    printf("#%d 自作関数\n", y++);
    printf("#%d 自作関数のプロトタイプ\n", y++);
    printf("#%d 引数と戻り値\n", y++);
    printf("#%d 引数と戻り値\n", y++);
    printf("#%d 再帰\n", y++);
    printf("#%d 仮引数\n", y++);
    printf("#%d コマンドライン\n", y++);
    printf("#%d 伝統形式\n", y++);
    printf("#%d こうぞうたい\n", y++);
    printf("#%d 続・こうぞうたい\n", y++);
    printf("#%d こうぞうたいポインタ\n", y++);
    printf("#%d こうぞうたいネスト\n", y++);
    printf("#%d ビットフィールド\n", y++);
    printf("#%d 共用体\n", y++);
    printf("#%d プリプロセッサ\n", y++);
    printf("#%d デバック\n", y++);
    printf("#%d #と##演算子\n",y++);
    printf("#%d ファイルの操作\n",y++);
    printf("#%d 標準入出力\n",y++);
    printf("#%d ファイルの書き込み\n",y++);
    printf("#%d ファイルサイズを得る\n",y++);
    printf("#%d 凡用ポインタ\n",y++);
    printf("#%d バイナリデータ\n",y++);
    printf("#%d ランダムアクセス\n",y++);
    printf("#%d 記憶クラス\n",y++);
    printf("#%d 列挙型\n",y++);
    printf("#%d 型修飾子\n",y++);
    printf("#%d ビット演算\n",y++);
    printf("#%d 関数ポインタ\n",y++);
    printf("#%d 動的メモリ\n",y++);
    printf("#%d 新しい型名\n",y++);
    printf("#%d printf()関数\n",y++);
    printf("#%d scanf()関数\n",y++);
    printf("#%d 文字列入出力\n",y++);
    printf("#%d 時間管理\n",y++);
    printf("#%d 乱数を得る\n",y++);
    printf("#%d 動的引数\n",y++);
    printf("#%d ワイド文字\n",y++);
    printf("#%d エスケープシーケンス一覧\n",y++);
    printf("#%d 番外編#1(基本関数の振り返り)\n",y++);
    
    


    printf("load %d\n",road);

    return y;
}
void makeup(int y){//文章出力
    switch (No) {
        case 1://#1 C言語の基本
        {
            printf("#1 C言語の基本\n");
            printf("まずはC言語について\n");
            printf("OSなどに使われる言語で\n");
            printf("独学で学ぶには難しい言語だといわれているそうです\n");
            printf("＊ゲームに使われているかは知りません\n");
            printf("まず作り方からメモ帳にC言語を入れ拡張子(.txtとかの部分のとこ)を\n");
            printf(".cにすることでC言語ファイルに変わるのでそれをコンパイル\n");
            printf("(C言語ファイルをexeに変えること)をして.exeファイルに変えて完成です\n");
            printf("じゃあまずメモ帳の内奥から説明します\n");
            printf("例として簡単なものを作りますね\n");
            printf("\n");
            printf("#include<stdio.h>\n");
            printf("\n");
            printf("int main()\n");
            printf("{\n");
            printf("char x=10;\n");
            printf("char y=40;\n");
            printf("printf(\"%%dと%%dの足し算の結果は%%dです\",x,y,x+y);\n");
            printf("}\n");
            printf("\n");
            printf("これが簡単なものです\n");
            printf("解説しますね\n");
            printf("#include<stdio.h>\n");
            printf("はどの関数の種類を使うかを表すもので主に\n");
            printf("stdio.h(ファイル名はヘッダファイルです)が種類を表します\n");
            printf("次に\n");
            printf("int main()\n");
            printf("はここからプログラムを読み上げますみたいなものです\n");
            printf("ここからは関数という機会に命令を与えるコマンドみたいなものです\n");
            printf("まずcharこれは変数を作りそこに数字を割り当てるみたいなものです\n");
            printf("pirintf("""")は""これから""これの間の文字を表示するという関数です\n");
            printf("そこの関数の中に入れた\n");
            printf("%%dは""これが終わってからの,の後の変数などが割り当てられる\n");
            printf("みたいなものです\n");
            printf("ほかにはx+yこれはそのまんまの通り計算をしています\n");
            printf("あと関数の最後にはこれをつけないと\n");
            printf("関数として認識されずエラーになるのできおつけてください\n");
            printf("簡単にC言語の始め方を説明はこんな感じです\n");
            break;
        }
        case 2://#2 変数の説明
        {
            printf("#2 変数の説明\n");
            printf("今回は変数に関係のある関数を教えていきたいと思います\n");
            printf("前回も使ったものも含めて改めて説明していきたいと思います\n");
            printf("まず変数に関するものを使った式を作りたいと思います(次に覚えるのも含め)\n");
            printf("\n");
            printf("#include<stdio.h>\n");
            printf("int main()\n");
            printf("{\n");
            printf("char x=50;\n");
            printf("int y;\n");
            printf("int X;\n");
            printf("int Y;\n");
            printf("int a;\n");
            printf("printf(\"(%%d)に加算する数を入れてください\\n\",x);");
            printf("scanf(\"%%d\",&y);\n");
            printf("printf(\"x+yと大きさを比べる数を入れてください\n\");\n");
            printf("scanf(\"%%d\",&Y);\n");
            printf("a=(x+y>=Y);\n");
            printf("if(a)printf(\"%dは%dより%d大きいです\",x+y,Y,x+y-Y);\n");
            printf("if(!a)printf(\"%%dは%%dより%%d小さいです\",x+y,Y,Y-x+y);\n");
            printf("}\n");
            printf("\n");
            printf("という感じのプログラムになります\n");
            printf("charは変数を作りその中にどの変数を入れるかというものです\n");
            printf("intはなんの値も入っていない変数が作られるというものです\n");
            printf("ほかにもあるのですがそのほかは私も手を付けてないのでわからないのでわかり次第追記\n");
            printf("的な感じで追加していきたいと思います\n");
            printf("次の勉強で少しでもわかりやすくするために\n");
            printf("今回使われた中から次使うものの説明をしたいと思います\n");
            printf("次に使うものはifという　もし〜ならば　という感じで表せるものです\n");
            printf("ifで判断するには真偽を調べなければなりませんその式が\n");
            printf("x=(x==10)\n");
            printf("のような式で図ることができます\n");
            printf("この式の()の中が成立すれば1(真)\n");
            printf("成立しなければ0(偽)になります\n");
            printf("それで次にもしならばのプログラムを作る必要があります\n");
            printf("作り方は簡単で関数の前にifをつけ調べたものの変数を()の中に収めればいいのです\n");
            printf("例が\n");
            printf("\n");
            printf("x=(x==10);\n");
            printf("if(x)printf("");\n");
            printf("\n");
            printf("という感じになります\n");
            printf("これでxが10なら〜というという感じのプログラムができます\n");
            printf("その逆で〜ではないならというのもできます\n");
            printf("それがこちらです\n");
            printf("\n");
            printf("x=(x==10);\n");
            printf("if(x)printf("");\n");
            printf("if(!x)printf("");\n");
            printf("\n");
            printf("これは(x)のxの隣に!を入れることでではないならということになります\n");
            printf("この場合偽の時のみ発動しますほかにも式中でそのような改変をすることができ\n");
            printf("その例が\n");
            printf("\n");
            printf("x=(x!=10)\n");
            printf("\n");
            printf("となりxが10ではないなら1(真)にするという感じ作ることができます\n");
            printf("簡単に説明するならこんな感じです\n");
            break;
        }
        case 3://#3 if(もしも)の説明
        {
            printf("#3 if(もしも)の説明\n");
            printf("まず簡単なほうに入ると思われる関数のifを説明していきたいと思います\n");
            printf("まずわかりやすいように例を作っていきます(これから教えることも踏まえて)\n");
            printf("#include<stdio.h>\n");
            printf("\n");
            printf("int main()\n");
            printf("{\n");
            printf("int x;\n");
            printf("x=(x==10);\n");
            printf("if(x)printf(\"xには10が入っています\");\n");
            printf("if(!x)printf(\"xは10ではありません x=%%d\",x);\n");
            printf("}\n");
            printf("\n");
            printf("これが大体の流れです説明入りますね\n");
            printf("intとかは前やったのでそれは振り返ってください\n");
            printf("次にあるx=(x==10)はかっこの中があっているかそれを調べる関数です\n");
            printf("かっこの中があっている場合xが1間違っている場合0になります\n");
            printf("x=(x==10)などで調べたときの0、1の関係は真偽の関係にあります\n");
            printf("0が偽 1が真\n");
            printf("と覚えてもらえると早いと思います\n");
            printf("ほかにもx=(x<10) x=(x>10) x=(x<=10) x=(x>=10)\n");
            printf("などもあり左側から\n");
            printf("10のほうが大きいなら\n");
            printf("xのほうが大きいなら\n");
            printf("10のほうが大きいまたは同じ\n");
            printf("xのほうが大きいまたは同じ\n");
            printf("という感じにあります\n");
            printf("次にプログラムに使われているifですね\n");
            printf("ifは英語でももしならばみたいな意味がありプログラムで同じ意味を持っています\n");
            printf("プログラム上の使い方は\n");
            printf("if(x)printf(""こんにちは"");\n");
            printf("みたいなものです\n");
            printf("関数の前にifを入れる感じに使います\n");
            printf("そのあとにある(x)はxが真偽のどっちかを調べるためのものです\n");
            printf("(x)を(!x)などにすると出なければみたいなものになります\n");
            printf("簡単に言うと偽の場合に使えるものですね\n");
            printf("ifなどの後に入る関数はなんでも使えます(いま僕が使ってる限りは...)\n");
            printf("ってことでifのざっくりした説明はこれで終わりです\n");
            break;
        }
        case 4://#4 数字入力(質問)の説明
        {
            printf("#4 数字入力(質問)の説明\n");
            printf("今回は数字などの入力を行える関数について\n");
            printf("教えていきたいと思います\n");
            printf(" まず関数を教えたいと思いますその関数は\n");
            printf("scanfという感じです\n");
            printf("これを使ったプログラムは\n");
            printf("#include<stdio.h>\n");
            printf("\n");
            printf("int main()\n");
            printf("{\n");
            printf("int x;\n");
            printf("printf(\"xに入れる数字を入れてください\n\");\n");
            printf("scanf(\"%%d\",&x);\n");
            printf("printf(\"xは%%dです\\n\",x);\n");
            printf("}\n");
            printf("\n");
            printf("のようなプログラムになります\n");
            printf("これは\n");
            printf("xに入れる数を質問したあとに入力する幹事のプログラムでその\n");
            printf("あとにxの値を表示するというプログラムです(今回は簡単だなｗ)\n");
            printf("質問する関数のscanfは質問の前に入れると質問の内容が表示されないので\n");
            printf("きおつけてください\n");
            printf("scanf(\"%%d\",&x)に&を入れる理由はエラーが起きるので入れてください\n");
            printf("*この関数は文字などは入れられません\n");
            printf("今回は複雑なものがないので今回はここまでです\n");
            printf("お疲れ様でした\n");
            printf("\n");
            printf("追記\n");
            printf("VS(Visual Studio)だとscanfは\n");
            printf("scanf_s\n");
            printf("とひょうきしないと使えません\n");
            break;
        }
        case 5://#5 switch(選択し)の説明
        {
            printf("#5 switch(選択し)の説明\n");
            printf("今回は前回の最後に言っていたswitchを\n");
            printf("説明していきたいと思います\n");
            printf("まずswitchの関数について簡単に説明しますね\n");
            printf("関数のswitchは前回使った数字入力と組み合わせて\n");
            printf("使うことができる関数です\n");
            printf("例えば答えによってその答え方を\n");
            printf("変えるといった感じの使い方です\n");
            printf("ではいつも通り軽くプログラムの例を作りますね\n");
            printf("#include<stdio.h>\n");
            printf("\n");
            printf("int main()\n");
            printf("{\n");
            printf("int x;\n");
            printf("printf(\"今日はいい天気ですか？\\n\");\n");
            printf("printf(\"そうですね！=1/雨が降っています=2\\n\");\n");
            printf("scanf(\"%%d\",&x);\n");
            printf("switch(x)\n");
            printf("    {\n");
            printf("    case 1:\n");
            printf("    printf(\"今日はあつそうですね\");\n");
            printf("    break;\n");
            printf("    case 2:\n");
            printf("    printf(\"傘が必要そうです\");\n");
            printf("    break;\n");
            printf("    default:\n");
            printf("    printf(\"どっちですか？\");\n");
            printf("    }\n");
            printf("}\n");
            printf("\n");
            printf("これがプログラムです\n");
            printf("じゃあ解説入れますね\n");
            printf("まずintは変数を作っていますそのあとにscanfで\n");
            printf("どれに当てはまるか聞いていますね\n");
            printf("答えが1なら今日は暑いですねと表示します\n");
            printf("答えが2なら傘が必要そうです\n");
            printf("答えが当てはまらないならどっちですか？\n");
            printf("と聞きますこのようにswitchの{}で区切った範囲でのみ\n");
            printf("反映されないのですがそれ以外は反映されません(当たり前ですね)\n");
            printf("\n");
            printf("それでcaseからからすべてを実行するということです\n");
            printf("breakを入れる理由は上の原因によりその{}のプログラム内\n");
            printf("から抜け出すといういみの関数で使われます\n");
            printf("caseからbreakの間には何を入れても構いません\n");
            printf("今回はこんな感じで終わりにします\n");
            break;
        }
        case 6://#6 for(〜回繰り返す)の説明
        {
            printf("#6 for(〜回繰り返す)の説明\n");
            printf("今回は前回の最後に言ったforについて説明していきたいと思います\n");
            printf("これは〜回繰り返すという感じの関数です\n");
            printf("使い方としては\n");
            printf("\n");
            printf("#include<stdio.h>\n");
            printf("\n");
            printf("int main()\n");
            printf("{\n");
            printf("int x;\n");
            printf("for (x=1;x<=10;x++)\n");
            printf("    {\n");
            printf("    printf(\"x=%%d\\n\",x);\n");
            printf("    }\n");
            printf("}\n");
            printf("\n");
            printf("今回も簡単ですね\n");
            printf("では解説行きますね\n");
            printf("まずもう慣れたでしょうか？またintを使っていますね\n");
            printf("これで変数xを作りました\n");
            printf("次のforの説明ですね\n");
            printf("(x=1,x=10,x++)\n");
            printf("は一つ目のxは回数を数え始める時の初期値ですね\n");
            printf("次のxはxがどれぐらいまでになったらやめるかってことです\n");
            printf("次のxはどれぐらい増やすかですねこれは使い方によってずっと\n");
            printf("xの値にすることもできます\n");
            printf("x++はifでも使うことができるのですがつかわないと思ったので\n");
            printf("まだ説明はしていません\n");
            printf("とりあえずざっと説明すると\n");
            printf("変数の値を一つ増やすみたいなものです\n");
            printf("それで次のprintfの内容は\n");
            printf("xには何が入っているかを言ってくれます\n");
            printf("これはミスるとループに入るのできおつけてくださいBy体験者\n");
            printf("今回はこれで終わりにします\n");
            printf("(最近疲れがたまりすぎて手抜き感があるｗｗだけど教えることがないｗｗ)\n");
            break;
        }
        case 7://#7 while(ずっと)の説明
        {
            printf("#7 while(ずっと)の説明\n");
            printf("今回はhwileという関数を説明していきたいと思います\n");
            printf("まずhwileはずっと繰り替えすなどの関数です\n");
            printf("例えばずっと同じことをさえたいときに使うことができます\n");
            printf("簡単なプログラムを組みますね\n");
            printf("\n");
            printf("#include<stdio.h>\n");
            printf("\n");
            printf("int main()\n");
            printf("{\n");
            printf("int x;\n");
            printf("while(x){\n");
            printf("printf(\"x=%%d\",x);\n");
            printf("if(x==10)printf(\"10!\");\n");
            printf("if(x==50)break;\n");
            printf("x++;\n");
            printf("}\n");
            printf("}\n");
            printf("\n");
            printf("このプログラムは簡単に説明すると\n");
            printf("ループに入るとxが1ずつ増えていき\n");
            printf("xが50の時{}の中から抜け出すbreakをつかい\n");
            printf("ループから抜け出すのようなプログラムです\n");
            printf("whileはbreakで抜け出せます\n");
            printf("細かく解説しますね\n");
            printf("charは変素についてみてください\n");
            printf("xが成り立っているかを調べますこの場合xが真ならループに入ります\n");
            printf("そうではなかったらループには入りません\n");
            printf("ループに入った場合xの値が1ずつ増えるようなプログラムを組み\n");
            printf("ifでxが50なら{}から抜け出すようなプログラムです\n");
            printf("\n");
            printf("質問なんですが\n");
            printf("なぜ難しいものになればなるほど入れる文字数が減るのはなぜでしょうか？\n");
            printf("そのほうが疲れがたまらないのでいいのですが\n");
            printf("多分これに対して最初のほうが教えることが多かったってだけなのでしょうね\n");
            printf("\n");
            printf("それでは今回もお疲れ様でした\n");
            printf("次回は何をするか決めてない(まだこの先勉強してないｗｗ)\n");
            printf("ので何になるかわかりません\n");
            break;
        }
        case 8://#8 else(ifとの応用)の説明
        {
            printf("#8 else(ifとの応用)の説明\n");
            printf("どうもいつも通りです\n");
            printf("今回はifなどで応用ができる関数\n");
            printf("を教えていきたいと思います\n");
            printf("今回教える関数はelseです\n");
            printf("これはifを使った後真偽が偽だった場合elseの{]で区切られた\n");
            printf("中のプログラムを実行します\n");
            printf("そこでまたifを使い真偽の偽が出た場合とき\n");
            printf("またelseの関数がある場合また{}で区切られた中の\n");
            printf("プログラムを実行します\n");
            printf("では毎度恒例の例プログラムを作っていきたいと思います\n");
            printf("\n");
            printf("#include<stdio.h>\n");
            printf("\n");
            printf("int main()\n");
            printf("{\n");
            printf("int x;\n");
            printf("printf(\"xに入れる値を入れてください\\n\");\n");
            printf("scanf(""%%d"",&x);\n");
            printf("if(x>1000)printf(\"xは1000より大きいです\\n\");\n");
            printf("else{\n");
            printf("if(x>100)printf(\"xは100より大きいです\\n\");\n");
            printf("else{\n");
            printf("printf(\"xは100より小さいです\");\n");
            printf("}\n");
            printf("}\n");
            printf("}\n");
            printf("\n");
            printf("これがプログラムです\n");
            printf("説明をするとxの値を聞きそのxの値が1000より大きかったら\n");
            printf("xは1000より大きいですと言います\n");
            printf("ほかの場所でも同じようになります\n");
            printf("elseは{}の中にまたelseがあっても反映されます\n");
            printf("ただ{で始まり}終わる必要があります\n");
            printf("これによってif(!x)などを使わないで済みますね\n");
            printf("ここで一回if(!x)とelseのメリットデメリットを\n");
            printf("見ていきましょう\n");
            printf("・if(!x)のデメリットはプログラムがかさばりますね\n");
            printf("メリットは見てすぐに理解できます\n");
            printf("・elseのメリットは見やすくわざわざif(!x)などを\n");
            printf("何回も使わなくても{}で区切られてる中の\n");
            printf("プログラムを全部実行してくれます\n");
            printf("デメリットは何回でも使えてしまうので\n");
            printf("わかりにくくなる時がある\n");
            printf("変える理由はこれを見て判断してください\n");
            printf("私はこれからはelseを使っていきたいと思います\n");
            printf("これで今回は終わりにしますお疲れ様でした\n");
            break;
        }
        case 9://#9 真偽を求める新しい式
        {
            printf("#9 真偽を求める新しい式\n");
            printf("今回は真偽の式の利用みたいなものです\n");
            printf("今回は内奥が少ないので短くなるかもしりません\n");
            printf("ではまず関数から\n");
            printf("||、&&が今回説明する関数です\n");
            printf("いつも通り例のプログラムからですね\n");
            printf("\n");
            printf("#include<stdio.h>\n");
            printf("\n");
            printf("int main()\n");
            printf("{\n");
            printf("int x,y;\n");
            printf("printf(\"x 1or0\");\n");
            printf("scanf(\"%%d\",&x);\n");
            printf("printf(\"y 1or0\");\n");
            printf("scanf(\"%%d\",&y);\n");
            printf("if(x||y)printf(\"今は真です\");\n");
            printf("if(!(x&&y))printf(\"今は偽です\");\n");
            printf("}\n");
            printf("\n");
            printf("このように使うことができます\n");
            printf("では解説しますね\n");
            printf("||は図っているもの例えばx||yは\n");
            printf("片方が1であれば答えが式の答えが1になるというものです\n");
            printf("&&は片方が0なら式の答えが0になるみたいなものです\n");
            printf("式であらわすと\n");
            printf("\n");
            printf("1||0=1\n");
            printf("\n");
            printf("0&&1=0\n");
            printf("\n");
            printf("という感じです\n");
            printf("どっちも0な場合||であっても0になります\n");
            printf("上手にやればすごいものができる式です\n");
            printf("これを極めるのも意外とあり？\n");
            printf("まぁそんなことは置いといて\n");
            printf("今回はこんなところで終わりにしたいと思います\n");
            break;
        }
        case 10://#10 空白を持つforの説明
        {
            printf("#10空白を持つforの説明\n");
            printf("今回は前回の最後に言った通りforの簡単な\n");
            printf("発展に行きたいと思います\n");
            printf("今回も短いのですぐ終わると思います\n");
            printf("ではまずプログラムをつくってみますね\n");
            printf("\n");
            printf("#include<stdio.h>\n");
            printf("\n");
            printf("int main()\n");
            printf("{\n");
            printf("char x=0;\n");
            printf("for(;x<=10;x++){\n");
            printf("printf(\"%%d回目の周回です\\n\",x);\n");
            printf("}\n");
            printf("}\n");
            printf("\n");
            printf("や\n");
            printf("\n");
            printf("#include<stdio.h>\n");
            printf("\n");
            printf("int main()\n");
            printf("{\n");
            printf("char x=0;\n");
            printf("for(;;){\n");
            printf("x++;\n");
            printf("printf(\"%%d回目の周回です\\n\",x);\n");
            printf("if(x>=10)break;\n");
            printf("}\n");
            printf("}\n");
            printf("\n");
            printf("これもそうですね\n");
            printf("今回の目標的なのは空白をもつforなので今回のforは\n");
            printf("変素などが入っていないところがあったと思います\n");
            printf("だけど関数の使い方によって\n");
            printf("空白があったって止めることはできるということが\n");
            printf("わかりましたね\n");
            printf("あぁこの二つのプログラムはどちらも一定数を超えると\n");
            printf("ループから抜け出す仕組みのプログラムです\n");
            printf("ほかに説明することもないので今回はこれぐらいにしたいと\n");
            printf("思います\n");
            printf("それではわからないことなどがあったらきいてください\n");
            printf("それでは本当にさようなら\n");
            printf("次回はたぶんcontinueをつかうプログラムを説明します\n");
            printf("あといろいろなものの活用的な感じです\n");
            break;
        }
        case 11://#11 continueの説明と活用
        {
            printf("#11 continueの説明と活用\n");
            printf("今回はcontinueとの組み合わせ掛けみたいなものです\n");
            printf("じゃあいつも通りプログラムを作り説明していきます\n");
            printf("\n");
            printf("#inclde<stdio.h>\n");
            printf("\n");
            printf("int main()\n");
            printf("{\n");
            printf("int x,y;\n");
            printf("do{\n");
            printf("printf(\"xに入れる数字を入れてください\");\n");
            printf("scanf(\"%%d\",x);\n");
            printf("if((x<=0)||(x>=1000)){\n");
            printf("printf(\"0〜1000まででお願いします\");\n");
            printf("continue;\n");
            printf("}while(0);\n");
            printf("printf(\"正確な数字です\");\n");
            printf("break;\n");
            printf("}\n");
            printf("return 0;\n");
            printf("}\n");
            printf("\n");
            printf("もう盛沢山ですねｗｗ\n");
            printf("僕もこれを理解するのに時間がかかって\n");
            printf("これを書くのが書き始めてから数時間立ちましたｗｗ\n");
            printf("じゃあ理解した内容だけを説明しますねｗ\n");
            printf("じゃあまずdoは今まで見たことないので大体の原因が\n");
            printf("doなんですがdoなんですがこれはwhileの違い形を作るときに使うやつですね\n");
            printf("do{から始まり}while()で終わるように作れば\n");
            printf("whileと同じことができます\n");
            printf("ただ違うことがあるならdoを使ったやつは最低でも1回はループしてくれます\n");
            printf("\n");
            printf("次はcontinueですねこれは\n");
            printf("名前の通りコンテニューです\n");
            printf("これは一番最後に通ったdo{←ここまで戻します\n");
            printf("つまりdo{}while()は必要なものでこれがないと\n");
            printf("一番最初まで戻されます\n");
            printf("それ以外は大体理解はしてると思うので説明を省きますね\n");
            printf("そういえばreturnを説明してなかったので説明しますね\n");
            printf("returnは簡単に言えば正常に終わらせるためのプログラムです\n");
            printf("0なら正常に終わらせるみたいなものです\n");
            printf("そんなものです(くわしくしらべてないなんて言えない)\n");
            printf("今回使ったのでほかに説明してないのはないですね\n");
            printf("ということで今回はこんな感じで\n");
            printf("わからないものがあれば聞いてください\n");
            printf("それではお疲れ様でした\n");
            break;
        }
        case 12://#12 gotoの説明
        {
            printf("#12 gotoの説明\n");
            printf("今回は使い方によってループと同じことをできる\n");
            printf("gotoの使い方と解説をしていきます\n");
            printf("いつも通りの流れで\n");
            printf("例プログラムを作ります\n");
            printf("\n");
            printf("#include<stdio.h>\n");
            printf("\n");
            printf("int main()\n");
            printf("{\n");
            printf("int x;\n");
            printf("start:\n");
            printf("x++;\n");
            printf("printf(\"%%d\",x);\n");
            printf("if(x>=50)goto end;\n");
            printf("else goto start;\n");
            printf("end:\n");
            printf("printf(\"system shut dowun\");\n");
            printf("return 0;\n");
            printf("}\n");
            printf("\n");
            printf("こんな感じですね\n");
            printf("じゃあ説明します\n");
            printf("まずgotoの使い方からですね\n");
            printf("gotoは指定したラベルの場所へ飛べる\n");
            printf("関数ですね\n");
            printf("ラベルの作り方は\n");
            printf("好きな文字の後に：←これをつけるとラベル判定になります\n");
            printf("gotoがあるラベルに飛ばすこともできます\n");
            printf("これで強制ループですね\n");
            printf("まぁwhile使ったほうが早いですけどｗ\n");
            printf("それでそこの中でifなどで区切ってほかのラベルに飛ばす\n");
            printf("こともできます\n");
            printf("breakは使えません理由は簡単でここでつかったらプログラムを\n");
            printf("終了判定になりエラーになります\n");
            printf("なぜ言ったかというとそれをやってしまったからですｗｗｗ\n");
            printf("あとgotoは楽ですがなぜか\n");
            printf("使ってはいけない暗黙のお約束があるようです\n");
            printf("別に使ってもいいと思いますけどね\n");
            printf("僕はラベルからラベルに飛ばすのは\n");
            printf("ごちゃごちゃになるので多分使いません\n");
            printf("それではお疲れ様でした\n");
            break;
        }
        case 13://#13 変数の発展
        {
            printf("#13 変数の発展\n");
            printf("今回はまえの変数のものの発展形を\n");
            printf("説明していきたいと思います\n");
            printf("じゃあまず例文てきな感じで\n");
            printf("例プログラムを作りたいと思います\n");
            printf("\n");
            printf("#include<stdio.h>\n");
            printf("\n");
            printf("int main()\n");
            printf("{\n");
            printf("short x=10000;\n");
            printf("long y=100000;\n");
            printf("double z=100000;\n");
            printf("unsigned short X=40000;\n");
            printf("unsigned long Y=2093049594;\n");
            printf("signed short Z=-1\n");
            printf("signed long Q=-50000\n");
            printf("\n");
            printf("printf(\"x=%%hd\\ny=%%ld\\nz=%%f\\nX=%%hu\\nY=%%lu\\nZ=%%d\\nQ=%%d\",x,y,z,X,Y,Z,Q););\n");
            printf("}\n");
            printf("\n");
            printf("longとshort型はint型と同じように数字を保存できます\n");
            printf("簡単に言うと\n");
            printf("short < int < long\n");
            printf("そしてunsingnedとsignedの違いは\n");
            printf("符号ありの正負の数と符号なしの正の数という違いです\n");
            printf("符号があると-1をそのまま-1と出力しますが\n");
            printf("符号がないと255と出力されます\n");
            printf("原因としてC言語の数字は二進数で管理されているからです\n");
            printf("細かく言うのはあれだから省きますが符号がないと\n");
            printf("マイナス値を入れたのに数が多くなってる？！\n");
            printf("ってことが起こるということです\n");
            printf("ちなみにshortのあとにintなどをつけなくても\n");
            printf("変数が生成されます\n");
            printf("つまり省略しても何の問題もないです！\n");
            printf("それと%%dだとうまくいかないこともあるらしい\n");
            printf("unsigned = %%u\n");
            printf("short = %%hd\n");
            printf("long = %%ld\n");
            printf("unsigned short = %%hu\n");
            printf("unsigned long = %%lu\n");
            printf("double = %%f\n");
            printf("long double = %%Hf\n");
            printf("long double = %%Lf\n");
            printf("僕もここはなかなか理解できてないので\n");
            printf("説明することがわからないので今回はこんぐらいにしますね\n");
            printf("それではお疲れ様でした\n");
            break;
        }
        case 14://#14 一次元配列
        {
        printf("#14 一次元配列\n");
        printf("今回は変数の応用てきな感じの奴を\n");
        printf("説明していきたいと思います\n");
        printf("まずプログラムを作りますね\n");
        printf("\n");
        printf("#include<stdio.h>\n");
        printf("\n");
        printf("int main()\n");
        printf("{\n");
        printf("int x{5};\n");
        printf("x[0]=1;\n");
        printf("x[1]=10;\n");
        printf("x[2]=100;\n");
        printf("x[3]=1000;\n");
        printf("x[4]=10000;\n");
        printf("printf(\"%%d\\n%%d\\n%%d\\n%%d\\%%d\\n\",x[0],x[1],x[2],x[3],x[4]);\n");
        printf("return 0;\n");
        printf("}\n");
        printf("\n");
        printf("これがプログラムです\n");
        printf("今回紹介するプログラムはx[5]\n");
        printf("という感じの関数です\n");
        printf("これは[]の中の数は同じ文字の変数を何個増やすかみたいなものです\n");
        printf("x[n]のnを含まない0〜n-1が範囲に入ります\n");
        printf("簡単に説明するとですね\n");
        printf("x[5]なら0〜4までの数を増やすことができます\n");
        printf("これで同じ変数名で何個も変数を増やすことができます\n");
        printf("ほかの説明することもないので\n");
        printf("今回はこれぐらいにします\n");
        printf("わからないことがあったら聞いてくれ\n");
        printf("ってことでお疲れ様でした\n");
        break;
        }
        case 15://#15 多次元配列
        {
            printf("#15 多次元配列\n");
            printf("今回は前回の一次元配列の応用編です\n");
            printf("前回はx[5]のような感じだったと思うのですが\n");
            printf("今回はx[2][3]のような変数です\n");
            printf("前回は同じ名前の変数を何個も作れるみたいなものでしたね\n");
            printf("今回は指定した数の変数の束を作るみたいなものです\n");
            printf("じゃあプログラムを\n");
            printf("\n");
            printf("#include<stdio.h>\n");
            printf("\n");
            printf("int main()\n");
            printf("{\n");
            printf("int x[2][2];\n");
            printf("x[0][0]=10;\n");
            printf("x[0][1]=100;\n");
            printf("x[1][0]=1000;\n");
            printf("x[1][1]=10000;\n");
            printf("printf(\"%%d %%d\\n%%d %%d\",x[0][0],x[0][1],x[1][0],x[1][1]);\n");
            printf("}\n");
            printf("\n");
            printf("このようになりますね\n");
            printf("これは前回と似ていますがそこの束の部分があるってだけですかね\n");
            printf("あとこのように束を作ることができるように\n");
            printf("もっと束を作ることができます\n");
            printf("だけど量も多くなるのでやらないことをお勧めします\n");
            printf("今回は前回と内容が似ているので説明することがないので今回は\n");
            printf("こんな感じで終わります\n");
            printf("わからないことがあったら聞いてください\n");
            printf("ってことでお疲れ様でした\n");
            break;
        }
        case 16://#16 文字列を変数に収納する方法
        {
            printf("#16 文字列を変数に収納する方法\n");
            printf("今回は文字列を変数に入れるみたいな\n");
            printf("ものを説明したいと思います\n");
            printf("いつも通りプログラムを組んでいきたいと思います\n");
            printf("\n");
            printf("#include<stdio.h>\n");
            printf("\n");
            printf("int main()\n");
            printf("{\n");
            printf("char x[5];\n");
            printf("int y;\n");
            printf("x[0]=\'h\';\n");
            printf("x[1]=\'e\';\n");
            printf("x[2]=\'l\';\n");
            printf("x[3]=x[2];\n");
            printf("x[4]=\'o\';\n");
            printf("for(y=0,y=4,y++)printf(\"%%s%%s%%s%%s%%s\",x[0],x[1],x[2],x[3],x[4]);\n");
            printf("return0;\n");
            printf("}\n");
            printf("\n");
            printf("このようになります\n");
            printf("これはx[0]などに文字を一つずつ割り当て\n");
            printf("それを出力するみたいなものですね\n");
            printf("このように変数に文字を保存しておくこともできます\n");
            printf("まぁこれをするぐらいなら普通に文字入れたほうが早いｗ\n");
            printf("まずこの分すらc言語の使用で0で終わっていないので\n");
            printf("記号などが出されたりするようです\n");
            printf("逆に言うと文字列は0で終わるというお約束があるのです\n");
            printf("ではちゃんとしてると思われるプログラムを組みます\n");
            printf("\n");
            printf("#include<stdio.h>\n");
            printf("\n");
            printf("int main()\n");
            printf("{\n");
            printf("char x[5];\n");
            printf("x[0]='h';\n");
            printf("x[1]='e';\n");
            printf("x[2]='l';\n");
            printf("x[3]=x[2];\n");
            printf("x[4]='o';\n");
            printf("x[5]=0;\n");
            printf("\n");
            printf("printf(x);\n");
            printf("return 0;\n");
            printf("}\n");
            printf("\n");
            printf("こんな感じのが多分正しいです\n");
            printf("説明を入れると\n");
            printf("まずprintf関数でxと入れたのは一次元配列のすべてを\n");
            printf("放出できるからですね\n");
            printf("そうするとhelloと言われます多分\n");
            printf("そしてx[5]にはちゃんと0が入っているので文字列としては認識\n");
            printf("されるはずです\n");
            printf("あと今回scanf関数なども使って文字を入れることもできるのですが\n");
            printf("それ専用の関数がありそれが\n");
            printf("getsという関数で本当に文字を入れるだけの関数です\n");
            printf("コードを描くとこんな感じです\n");
            printf("\n");
            printf("#include<stdio.h>\n");
            printf("\n");
            printf("int main()\n");
            printf("{\n");
            printf("int x[10]\n");
            printf("printf(\"好きな文字を入れてください9文字\");\n");
            printf("gets(x);\n");
            printf("return 0;\n");
            printf("}\n");
            printf("\n");
            printf("多分数字は入れられない\n");
            printf("gets関数とscanf関数の同じところは\n");
            printf("配列サイズを超えて入力をされると強制終了されるということですね\n");
            printf("セキュリティーなどを考慮するなら不向きだと思います\n");
            printf("以上！終わり！\n");
            printf("ってことでお疲れ様でした\n");
            break;
        }
        case 17://#17 文字列の配列
        {
            puts("#17 文字列の配列");
            puts("今回の文字列の配列は多次元配列とか");
            puts("文字列を変数に収納するものと");
            puts("同じっていうか応用に近しいものです");
            puts("だから多次元配置の延長線上にあるもの");
            puts("だと思ってもらえればいいです");
            puts("ってことでコードを描くとこうなります");
            puts("");
            puts("#include<stdio.h>");
            puts("");
            puts("int main(){");
            puts("char x[][2][128]={");
            puts("{\"hello\",\"world\"},");
            puts("{\"こんにちは\",\"こんばんは\"},");
            puts("{\"おはよう\",\"おやすみ\"}");
            puts("};");
            puts("printf(\"%%s\\t%%s\\n\",x[0][0],x[0][1]);");
            puts("printf(\"%%s\\t%%s\\n\",x[1][0],x[1][1]);");
            puts("printf(\"%%s\\t%%s\\n\",x[2][0],x[2][1]);");
            puts("}");
            puts("");
            puts("char x[][2][128]の説明からしていくと");
            puts("x[][2][128]の最初の[]は文字列の数を指定できます");
            puts("この場合[]が空欄なのはそこに数字を入れなくても機械側で");
            puts("自動割り当てをしてくれるためです");
            puts("何なら割り当てない方が数え間違えがなくていいのでお勧めです");
            puts("それで２個目の[]は２個目の{}の中の区切りの数");
            puts("もっと言うと{から,ここまでで１とカウントします");
            puts("そして３個目の[]は一つの区切りで与えるサイズ量です");
            puts("例えば{hello,world}の{から,までの間のサイズを指定できます");
            puts("例えばx[][3][10]だとすると");
            puts("{から,の文字数(サイズ)は１０文字までということになります");
            puts("ちなみに,から}でも同じです");
            puts("ってことで簡単にさっき説明したものを表すとこうなります");
            puts("");
            puts("変数[文字列の数][文字列内の区切りの数][文字列の長さ];");
            puts("");
            puts("ということになります");
            puts("これはPythonとかで言うクラスに似ている気がしなくもなくもないよね");
            puts("まぁC++とかならクラスあるから絶対Cで今回説明したやつやるなら");
            puts("C++でクラス使った方がいいｗ");
            break;
        }
        case 18://#18 ポインタ変数
        {
            puts("#18 ポインタ変数");
            puts("ポインタとは、簡単に言うと変数です");
            puts("このポインタというものは変数のように数値を入れえるもの");
            puts("ではなくメモリアドレス(わかりやすく言うと住所)");
            puts("を入れるものです");
            puts("メモリアドレスというものを軽く説明すると");
            puts("変数に入った数値は一時的にメモリに保存されるものらしいです");
            puts("その変数の数値を管理するためにアドレス(住所)が割り当てられます");
            puts("変数のアドレスを出すには&をつける必要があります");
            puts("とりあえずプログラムを書いてみますね〜");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main()");
            puts("{");
            puts("        char x[3] = { 'A' , 'B' , 127};");
            puts("        int y;");
            puts("");
            puts("        for (y = 0 ; y <= 2 ; y++) {");
            puts("                printf(\"x[%%d]のメモリアドレス = %%x\\n\" , y , &x[y] );");
            puts("        }");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("出力結果");
            puts("88f8a9");
            puts("88f8aa");
            puts("88f8ab");
            puts("※値が違ってもアドレスは変わりません");
            puts("つまりxの配列を変えてもアドレスの場所は変わらないのです");
            puts("ちなみに&xはアドレスを取得しています");
            puts("とりあえずメモリのアドレスがわかったとて");
            puts("何もできないので応用というか使い方を説明していきます");
            puts("まず前提として");
            puts("ポインタ変数にアドレスを代入することによって");
            puts("そのポインタ変数は直接メモリアドレスにアクセスできます");
            puts("イメージとしては遠隔で変数の数値を操作できます");
            puts("コードを描くとこうなります");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main()");
            puts("{");
            puts("        int *po , var;");
            puts("        var = 10101;");
            puts("        po = &var;");
            puts("");
            puts("        printf(\"ポインタに格納されている内容 = %%d\\n\" , *po);");
            puts("        printf(\"ポインタに格納されているアドレス = %%x\" , po);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果がこうなるはずです");
            puts("");
            puts("ポインタに格納されている内容 = 10101");
            puts("ポインタに格納されているアドレス = 5ffa18");
            puts("");
            puts("このコードで注意するべき場所があり");
            puts("一つ目のprintfではpoを指定するときに*がついています");
            puts("しかし二つ目では*がついていないのでそこを気を付けてください");
            puts("*をつけた方はアドレスが当てられてるものを表示します");
            puts("*がないほうはメモリアドレスを表示します");
            puts("まぁ例を言うと");
            puts("aという文字のアドレスが1001に入ってるとして");
            puts("*がついているとaを表示しいて");
            puts("*がついていないと1001を表示するみたいなものです");
            puts("それがわかったうえでもう一つコードを描きますね");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main()");
            puts("{");
            puts("        int *po , var;");
            puts("        var = 100;");
            puts("        po = &var;");
            puts("");
            puts("        *po = 1010;");
            puts("        printf(\"変数varの値 = %%d\" , var);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("これは一見出力されるのは100に見えますが");
            puts("実は出力されるのは1010になるんです");
            puts("原理を言いますとvarとpoが同期しているからです");
            puts("つまりpoの値を変えるとvarの値が変わります");
            puts("その逆もあります");
            puts("あとここでも注意なのですが");
            puts("数値をポイント変数にそのまま代入したい場合");
            puts("*をつけないとアドレスそのものを変えることになるので");
            puts("数値をそのまま入れたい場合は*をつけましょう");
            puts("ちなみに形式(intやchar)の違う変数を");
            puts("ポイント変数に入れるとおかしくなるのでお勧めはしません");
            break;
        }
        case 19://#19 ポインタ演算
        {
            puts("#19 ポインタ演算");
            puts("ポインタ変数の演算について話していきます");
            puts("とりあえず#18の説明を見たことを前提で話していきます");
            puts("ポインタ変数にもいろいろな形が存在し、変数と同じように使えます");
            puts("だたポインタ変数も算術ができるが整数以外はできないので気を付けてください");
            puts("例えば負の数や浮動小数点(小数点)などもできません");
            puts("簡単に言うとポインタ変数は整数のみの加減しかできないのです");
            puts("");
            puts("それと、ポインタ変数と通常の変数とでは違いがあります");
            puts("インクリメント(++)デクリメント(--)を使った算術は、不思議な結果を出すそうです");
            puts("例がこちらです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main()");
            puts("{");
            puts("        int ary[2] = { 1000 , 2000 };");
            puts("        int *po;");
            puts("");
            puts("        po = &ary[0];");
            puts("        printf(\"po\\t = %%x\\n\" , po);");
            puts("        po++;");
            puts("        printf(\"po++\\t = %%x\\n\" , po);");
            puts("        printf(\"*po++\\t = %%d\" , *po);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("出力結果は");
            puts("po       = dffba4");
            puts("po++     = dffba8");
            puts("*po++    = 2000");
            puts("こうなります");
            puts("普通なら1加算されるとdffba5になるように思えます");
            puts("しかしポインタがint型で作られているため整数は4バイトの長さで処理されます");
            puts("つまり1加算されると1バイトではなく4バイト分増えるのです");
            puts("ちなみに*po++ではアドレスがさす変数ではなくアドレスそのものを");
            puts("加算していることになります");
            puts("つまりアドレス間の移動変更みたいなものです");
            puts("もしアドレスがさす変数の値を増やしたいのであれば");
            puts("(*po)++とするといいらしいです");
            puts("簡単に表すと");
            puts("*po++ 	= アドレスそのものに加算");
            puts("(*po)++ = アドレス先の変数を加算");
            puts("という感じです");
            puts("まぁポインタ演算はこんな感じでした");
            break;
        }
        case 20://#20 配列とポインタ
        {
            puts("#20 配列とポインタ");
            puts("この説明ではポインタの説明を聞いたことを前提で話していきます");
            puts("初めにC言語では配列とポインタの関係は深く重要だそうです");
            puts("まぁ簡単にすると配列とポインタは深く関係してるってことです");
            puts("前に少し説明したgets()関数は配列を渡すことができます");
            puts("また添え字(多次元配列の[]これのこと)は指定しなくても配列を渡せます");
            puts("しかしgets()関数に渡しているのは配列ではなくポインタを渡している");
            puts("というのをまず理解しておいてください");
            puts("配列をした変数は、添え字を小楽して配列変数名だけにすると");
            puts("配列の先頭アドレスへのポインタを表します");
            puts("つまりx[10]があったとして");
            puts("*xと表示したときは*x[0]と同じってことですたぶん");
            puts("こういうこともありscanf()やgets()で多次元配列であっても");
            puts("変数名を指定していたわけです");
            puts("ちなみにscanfで配列に数字を入れる場合&を入れない約束があるらしいですｗ");
            puts("でもそれをする理由は配列の場合添え字省略が先頭アドレスへのポインタ");
            puts("だったかららしい");
            puts("とりあえず前回(*po)++と*po++の違いを軽く話しましたが");
            puts("今回はそれをもう少し細かく説明します");
            puts("とりあえずコードどーぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        int ary[3] = { 10,20,30 };");
            puts("        int *ary_p;");
            puts("        ary_p = ary;");
            puts("");
            puts("        printf(\"間接参照\\t=%%d,%%d,%%d\\n\", *ary_p , *(ary_p + 1) , *(ary_p + 2));");
            puts("        printf(\"添え字指定\\t=%%d,%d%,%%d\" , ary[0] , ary[1] , ary[2]);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("もう結構気持ち悪いよねｗｗ");
            puts("とりあえず説明しますと");
            puts("関節参照の方がポインタ変数を使って参照していて");
            puts("添え字指定が多次元配列からとってきています");
            puts("まぁ大体見ればわかるはず！");
            puts("それで多次元配列は何をしてるかわかると思うので");
            puts("ポインタ変数の方を説明すると");
            puts("aryのアドレスをary_pのポインタ変数に入れています");
            puts("それが ary_p = ary; のところです");
            puts("ここで&がついていないのは最初にも説明した通り");
            puts("多次元配列になっている変数を添え字省略すると");
            puts("先頭のアドレスへのポインタっていう扱いになるんですよ〜たぶん");
            puts("だから&がいらないんです");
            puts("それじゃあアドレスをポインタ変数に入れたのはわかったと思うんですけど");
            puts("関節参照の *(ary_p+1)とかって何？って思ったと思うので説明すると");
            puts("前回も説明した通り");
            puts("*をカッコ内に入れた場合はアドレス先の変数に代入");
            puts("*が外側ならアドレスに代入");
            puts("と説明した通りです");
            puts("ちなみに補足すると");
            puts("ポインタ変数にもういとど*をつけて式を作った場合");
            puts("それはアドレス先をあらわていることになります");
            puts("今回は*はカッコの外ですつまりアドレスに代入しています");
            puts("");
            puts("ここで少し多次元配列のアドレスの振り分けのされ方");
            puts("について説明しますね");
            puts("多次元配列は0,1,2,3,4と作れるじゃないですか？");
            puts("その時の作られた順(数が少ない順)にアドレスが振られていきます");
            puts("例えば最初の0に1000というアドレスを渡したなら");
            puts("1のアドレスは1001となるみたいなものです");
            puts("");
            puts("それで話を戻します");
            puts("さっきの説明を読んだうえで質問です");
            puts("アドレスこの場合1000に1をプラスしたとしましょう");
            puts("そしたらアドレスはどこを指していることになりますか？");
            puts("");
            puts("まぁ答えを言うとアドレスの値が1増えて1001になります");
            puts("つまり示している場所がx[0]からx[1]に変わったということです");
            puts("");
            puts("簡単に言うと多次元配列間の添え字間をプラスされた数だけ");
            puts("移動したって考えてください");
            puts("ちなみに忘れないでほしいのがary_pに入っているアドレスは");
            puts("あくまでary[0]のアドレスだけってことです");
            puts("ちなみに２次元配列でもできます");
            puts("まぁ二次元配列の場合");
            puts("{{1,2}");
            puts("{3,4}}");
            puts("の順でアドレスが割り振られるらしいです");
            puts("それとポインタ変数にしたものでも多次元配列ができます");
            puts("pがポインタ変数だった場合");
            puts("x[0]=p[0]");
            puts("こうやって添え字ごとに割り振ることもできます");
            puts("");
            puts("ちなみに最初の方に説明した通り配列変数だけ(添え字なし)だけのばあい");
            puts("先頭アドレスへのポインタであることは説明しましけど");
            puts("それを応用したらポインタ演算で配列にアクセスすることができます");
            puts("まぁ正式な使い方じゃないらしいので注意する必要もあるらしいです");
            puts("説明に戻るとポインタ変数は代入できない変数ですしかし");
            puts("ポインタ変数に格納されたアドレスは再格納しない限り");
            puts("変化しないので配列の先頭アドレスを示す定数と考えられます");
            puts("なのでwhileやforを使って配列にアクセスることができちゃうんですよね");
            puts("とりあえず配列とポインタの説明はこんぐらいで");
            break;
        }
        case 21://#21 文字列ポインタ
        {
            puts("#21 文字列ポインタ");
            puts("ポインタ変数については結構理解してきたと思いますが");
            puts("いままでは数字行ってしまえば値をポインタに入れたりしてたけど");
            puts("ほかにもchar型でもポインタ変数にできるんです");
            puts("まぁ宣言はいつも通り*をつけるだけなんですよね");
            puts("だからchar型で作ると char *x; となるわけです");
            puts("それで文字列を入れるなら""これで囲んで入れるだけです");
            puts("簡単に言うとprintfの()の中に文字列を入れるのと同じようなものです");
            puts("コードを描くとこんなもんです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        char *str = ""kitty on your lap"";");
            puts("");
            puts("        printf(\"先頭アドレス = %%c\\n\",*str);");
            puts("        printf(\"格納文字列 = %%s\" , str);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行すると");
            puts("");
            puts("先頭アドレス = k");
            puts("格納文字列 = kitty on your lap");
            puts("");
            puts("こうなるそうです");
            puts("これの説明をしていくと");
            puts("一つ目は%%cによって");
            puts("char型のstrに入ってる");
            puts("kitty on your lapの最初のkを");
            puts("出力したわけです");
            puts("二つ目は%%sによって");
            puts("strに入ったkitty on your lapを");
            puts("出力したわけです");
            puts("ちなみに最初の方で*をつける理由は");
            puts("*がついてない方はアドレス全体で文字を求めるかで");
            puts("*がついている方は文字列内の最初のアドレスから文字を求めるか");
            puts("の違いだと思ってます");
            puts("そしてついでに\\0(ヌル文字)を使ったコードを見せます");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        char *str = \"YUKI \\0 RENA \\0 MIMI\";");
            puts("        printf(\"%s\n%s\n%s\" , str , str + 7 , str + 14);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("これはstrの中の\\nまでの文字を表示するものです");
            puts("三つの文字列の中の始めたい文字の最初に");
            puts("アドレスを合わせてその場所から\\nまでの文字を表示するものです");
            puts("まぁちょっと難しくて理解がまだちょっと不十分だから");
            puts("これから先うまく使える自信ないっすｗ");
        }
        case 22://#22 ポインタ配列
        {
            puts("#22 ポインタ配列");
            puts("今回の説明はポインタ配列の話ですね");
            puts("ポインタ配列っていうのは多次元配列とかと同じようなものです");
            puts("作り方も多次元配列と同じで[]をつけるだけです");
            puts("とりあえずコードを描か着ますね");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        int get_n;");
            puts("        char *ary[] = { \"暇人"" , \"人間"" , \"宇宙人\" };");
            puts("        printf(\"あなたは誰ですか？\\n\");");
            puts("        printf(\"暇人 = 1\\n人間 = 2\\n宇宙人 = 3\\n\");");
            puts("        printf(\"1〜3の半角英数>\");");
            puts("");
            puts("        scanf(\"%%d\",&get_n);");
            puts("        if (( get_n <= 3 ) && ( get_n >= 1))");
            puts("");
            puts("                printf(\"あなたは%%sさんなんですね!\" , ary[get_n - 1]);");
            puts("        else printf(""不正な値です"");");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("ary[get_n-1]で-1をしている理由は");
            puts("多次元配列にはヌル文字いわゆる0が配列の最後に来ます");
            puts("つまりx[3]としたときに[3]にはヌル文字が入るということです");
            puts("簡単に言うと-1をして数を合わせていたということですね");
            puts("最後に");
            puts("");
            puts("アドレスを参照 , 代入");
            puts("ary_p[n] = &var;");
            puts("");
            puts("アドレスの内容(値)を参照 . 代入");
            puts("*ary_p[n] = var;");
            puts("");
            puts("&と*の違いをお忘れなく");
            puts("まぁポインタ配列は今までのを駆使した感じなんで説明することが");
            puts("このぐらいしかないので終わり〜");
            break;
        }
        case 23://#23 ポインタのポインタ
        {
            puts("#23 ポインタのポインタ");
            puts("これまでポインタについてやってきたけど");
            puts("これでポインタ系が完結かもしれません");
            puts("まぁ今回やるのはポインタのポインタです");
            puts("とりあえずポインタは");
            puts("宣言した変数のアドレス(住所)だったじゃないですか？");
            puts("しかしポインタ変数も普通の変数と同じように");
            puts("アドレスが割り振られるのです");
            puts("まぁ変数として存在している限り当たり前なんだけどねｗ");
            puts("とりあえずそのポインタのポインタについて話していきますね");
            puts("コードを描くとこんな感じです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("    char str[] = \"kitty on your lap\";");
            puts("    char *str_p;");
            puts("    char **str_pp;	/*ポインタのポインタ*/");
            puts("");
            puts("    str_p = str;");
            puts("    str_pp = &str_p;");
            puts("");
            puts("    printf(\"文字型配列変数\\n\");");
            puts("    printf(\"配列先頭アドレス = %%x\\n\" , str);");
            puts("    printf(\"保持する文字列 = %%s\\n\\n\" , str);");
            puts("");
            puts("    printf(\"ポインタの示す値\\n\");");
            puts("    printf(\"ポインタアドレス = %%x\\n\" , &str_p);");
            puts("    printf(\"保存する値 = %%x\\n\" , str_p);");
            puts("    printf(\"保持するアドレスが持つ内容 = %%s\\n\\n\" , str_p);");
            puts("");
            puts("    printf(\"ポインタのポインタが示す値\\n\");");
            puts("    printf(\"保持する値 = %%x\\n\" , str_pp);");
            puts("    printf(\"保持する値が持つ値 = %%x\\n\" , *str_pp);");
            puts("    printf(\"保持する値が持つ値の内容 = %%s\", *str_pp);");
            puts("");
            puts("    return 0;");
            puts("}");
            puts("");
            puts("出力結果");
            puts("");
            puts("文字型配列変数");
            puts("配列先頭アドレス = f4fe3a");
            puts("保持する文字列 = kitty on your lap");
            puts("");
            puts("ポインタの示す値");
            puts("ポインタアドレス = f4fe34");
            puts("保存する値 = f4fe3a");
            puts("保持するアドレスが持つ内容 = kitty on your lap");
            puts("");
            puts("ポインタのポインタが示す値");
            puts("保持する値 = f4fe34");
            puts("保持する値が持つ値 = f4fe3a");
            puts("保持する値が持つ値の内容 = kitty on your lap");
            puts("");
            puts("まぁ説明をしていくと");
            puts("str_pにはstr[]の文字列が入れられました");
            puts("この時配列された文字をポインタに入れると");
            puts("str[0]簡単に言うと一番最初の文字のアドレスが代入されます");
            puts("つまりstr_pにはstr[0]のアドレスが代入されています");
            puts("ちなみにstr[0]の[]を省略してもstrの最初のアドレスを");
            puts("表すことになります");
            puts("次にポインタのポインタであるstr_pp");
            puts("について説明します");
            puts("まずポインタのポインタの宣言の仕方は簡単に*を２個つけるだけです");
            puts("つまり **p って書けばいいのです");
            puts("それでstr_ppに何が入ったのかというと");
            puts("str_ppにstr_pのアドレスが代入されました");
            puts("アドレスの代入は&をつけるだけです");
            puts("この時str_ppはstr[0]ではなくstr_p[0]を表しています");
            puts("とりあえずこれでstr_ppからでもstrにアクセスできるようになりました");
            puts("まぁ今はそれだけかな");
            puts("いやぁポインタ系多いし");
            puts("理解するのに脳を柔軟に使わなくちゃいけなくて");
            puts("疲れたぁ");
            break;
        }
        case 24://#24 自作関数
        {
            puts("#24 自作関数");
            puts("今までの説明では基礎的なprintfやscanf、for、ifなどをやってきました");
            puts("しかし時々思いません？");
            puts("こういう関数があったらいいなと...");
            puts("それを実現できるようにするのが今回の説明");
            puts("かゆところに手が届く！かはわからないけど");
            puts("確実に今までのプログラミングを楽にするものであるのは確かです");
            puts("それでは取り合ずコードどーぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("void func() {");
            puts("        printf(\"kitty on your lap\");");
            puts("}");
            puts("");
            puts("int main() {");
            puts("        func();");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("出力結果が");
            puts("");
            puts("kitty on your lap");
            puts("");
            puts("になります");
            puts("なんでそうなったの？プログラムって上から下に行くよね？");
            puts("って思ったと思うけどそれであっています");
            puts("ただ違うところは int main のほかに void func が存在しています");
            puts("今回のカギはその viod func にあります");
            puts("それでは解説です");
            puts("まず見たことがないであろう func(); という関数がありますね");
            puts("これが出力をkitty on your lapにしたものです");
            puts("詳しく話していきますと");
            puts("まず最初にvoid func()というもので");
            puts("新しい囲い的なものがありますよね");
            puts("これがfunc()関数と関連があります");
            puts("見ればわかるかもしれませんが");
            puts("voidのあとにfunc()が来ていますよね");
            puts("実はこの二つが関係して文字を出力していたんです");
            puts("簡単に言うとこんにちはという文字が入った箱があるとしましょう");
            puts("その箱を開けると当たり前ですがこんにちはという文字が出てくる");
            puts("ただそれだけです");
            puts("それを何回でも開けられるようにしたのが");
            puts("今回の自作関数です");
            puts("まぁ自作するにはいろいろ条件があるんですが");
            puts("もう一度別のコードを描いた方が説明しやすいので");
            puts("描きます");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("void func2() {");
            puts("        printf(\"your lap\\n\");");
            puts("}");
            puts("");
            puts("void func1() {");
            puts("        printf(\"kitty on \");");
            puts("        func2();");
            puts("}");
            puts("");
            puts("int main() {");
            puts("        func1();");
            puts("        printf(\"ご主人様関数\\n\");");
            puts("        func1();");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("kitty on your lap");
            puts("ご主人様関数");
            puts("kitty on your lap");
            puts("");
            puts("となりますこれで気づいたかもしれませんが");
            puts("自作関数の囲いが作られてるのはすべてint main()の前なんです");
            puts("なぜかというとプログラムは上から下に実行されていくからですね");
            puts("まぁ感がいいなら気づくかもしれませんが");
            puts("囲いで囲まれたものが下にあると");
            puts("まだ読み込まれていないつまり存在していない判定なので");
            puts("いくら呼び出そうとしても呼び出せない状況になるんです");
            puts("だからわざわざint main()の前で宣言しておくんです");
            puts("ちなみに当たり前ですけど自作関数は");
            puts("何回でも呼び出せます");
            puts("ちなみに２個目のコードで");
            puts("func1がfunc2より下にある理由ですが");
            puts("func1でfunc2を呼び出すときfunc1より先に");
            puts("読み込まれていないとこれまたそんな関数ねぇよ");
            puts("と言われてしまうので先に読み込ませるのです");
            puts("まぁそれは昔までの話なんですけどね...");
            puts("詳しくは次の説明で");
            break;
        }
        case 25://#25 自作関数のプロトタイプ
        {
            puts("#25 自作関数のプロトタイプ");
            puts("前回の説明で関数を自作して呼び出せるようになったと思うので");
            puts("プロトタイプ的なものを教えていきたいと思います");
            puts("まず前提としてなぜプロトタイプがあるかというと");
            puts("前回は自作関数が二つとかだったからよかったものの");
            puts("本来アプリ開発をするならより多くの関数が作られるわけじゃないですか");
            puts("つまりいちいち上で指定しているといつかは");
            puts("スパゲッティーコードなるものになるんですよね");
            puts("それを少し緩和させることができるのが今回の");
            puts("自作関数のプロトタイプになります");
            puts("それではコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("void func(void);");
            puts("");
            puts("int main() {");
            puts("        func();");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("void func() {");
            puts("        printf(\"kitty on your lap\");");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("kitty on your lap");
            puts("");
            puts("この形を見てわかったかもしれないけど");
            puts("自作関数があとに来ています");
            puts("ついでに最初にvoid func();というものが来ています");
            puts("これが最初に来ることで自作関数が最初に読み込まれます");
            puts("なのでmain()の中でも正常に動くのです");
            puts("ちなみに自作関数を使う場合プロトタイプを");
            puts("使うことを強くお勧めします");
            puts("それともう一つコード書きます");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("void func();	/*前方宣言になってしまう*/");
            puts("");
            puts("int main() {");
            puts("        func();");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("void func() {");
            puts("        printf(\"kitty on your lap\");");
            puts("}");
            puts("");
            puts("実行結果は最初のコードと同じなのですが");
            puts("こちらは前方宣言となってしまいます");
            puts("コンパイラからするとプロトタイプの宣言がない関数の呼び出し");
            puts("というエラーが出る場合があるそうです");
            puts("引数で何も受け取らない関数の場合voidを指定しなければいけないのです");
            break;
        }
        case 26://#26 引数と戻り値
        {
            puts("#26 引数と戻り値");
            puts("引数と仮引数と戻り値について説明していきますね");
            puts("まずプログラミングには");
            puts("引数と戻り値というものがあります");
            puts("引数とは関数に渡される情報になります");
            puts("確か何度か使った言葉ですがこういう意味です");
            puts("今まで関数などで引数を渡してきました");
            puts("が説明なども特に指定なったので");
            puts("コードとかを書きながら使い方などを説明していきます");
            puts("それと引数を呼び出し元から受け取るには渡された値を");
            puts("保存する変数が必要になります");
            puts("引数リストで引数を受け取るための");
            puts("特別な変数を仮引数と言います");
            puts("コード書きますね");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("void func ( int list );");
            puts("");
            puts("int main() {");
            puts("        int list;");
            puts("        printf(""関数に渡す値を入力してください>"");");
            puts("        scanf(\"%%d\",&list);");
            puts("        func(list);             /*変数listが関数に渡される*/");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("void func( int list )");
            puts("{");
            puts("        printf(\"渡された値は%%dです\" , list );");
            puts("}");
            puts("");
            puts("実行結果はlistに入ったものが出力されることになってます");
            puts("それでコードを見ておかしくね？って思ったかもしれませんが");
            puts("int listが2回宣言されています");
            puts("しかしvoid func (int list)のint listは仮引数で");
            puts("mainの中にあるint listは変数として存在しているものです");
            puts("つまり全くの別物ということです");
            puts("それともう一つコード書きます");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("void func ( char list);");
            puts("");
            puts("int main() {");
            puts("        int list;");
            puts("        printf(\"関数に渡す値を入力してください>\");");
            puts("        scanf(\"%%d\",&list);");
            puts("        func(list);             /*変数listが関数に渡される*/");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("void func( char list ) {");
            puts("        printf(\"渡された値は%%dです\" , list );");
            puts("}");
            puts("");
            puts("これは見てておかしいところがわかりやすいですね");
            puts("自作変数で使われてる仮引数はchar型なのに");
            puts("main内での宣言がint型なんですよね");
            puts("ちなみに仮引数がchar型なので上位8ビットは切り捨てられます");
            puts("まぁこれで仮引数の変数とmain内での変数が別物であるのがわかったところで");
            puts("引数には複数の数を指定できることについて話します");
            puts("とりまコードどーぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("void func( char str[], int var);");
            puts("");
            puts("int main() {");
            puts("        func(""kitty on your lap"" , 9);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("void func( char str[], int var) {");
            puts("        printf(\"%%s\" , str + var);");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("your lap");
            puts("");
            puts("これを説明すると");
            puts("まず第1引数はchar型(文字列)で第2引数はint型(数値)ですね");
            puts("第一引数で渡された文字列を");
            puts("第二引数で渡された値を添え字として");
            puts("その要素から出力します");
            puts("とりあえずこれが引数と仮引数の説明でした");
            puts("次は戻り値について説明します");
            puts("関数には説明した通り戻り値が存在しています");
            puts("今まではvoidとおいてきたところに");
            puts("本当なら戻り値というものが入ります");
            puts("とりあえず戻り値というのは");
            puts("呼び出された値をもとあった場所に戻す");
            puts("みたいなことができます");
            puts("これを利用して関数などを制御しているらしいです");
            puts("値を返すには関数の中で");
            puts("return ステートメントを使用します");
            puts("ちなみに今まで使ってきたreturnはそういう意味だったのです");
            puts("もちろん返す値も変えることができます");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("char* func(void);");
            puts("");
            puts("int main() {");
            puts("        char *str;");
            puts("        str = func();");
            puts("");
            puts("        printf(\"%%s\",str);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("char* func() {");
            puts("        return \"kitty on your lap\";");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("kitty on your lap");
            puts("");
            puts("これはただ単に何もせず文字列のポインタを返すみたいな");
            puts("遠回りなことをしているんです");
            puts("まぁここは文字列以外にも数字でも返すことができるんですよね");
            puts("次は引数から値をもらって戻り値で値を返す関数を作りましょう");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int func(int var1 , int var2);");
            puts("");
            puts("int main() {");
            puts("        int var;");
            puts("        var = func(13 , 17);");
            puts("");
            puts("        printf(\"戻ってきた値 = %%d\" , var);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("int func(int var1 , int  var2 ) {");
            puts("        return var1 + var2;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("戻ってきた値 = 30");
            puts("");
            puts("になるはずです");
            puts("これは自作関数内で計算をし戻り値で値を代入しています");
            puts("とりあえず引数、仮引数、戻り値はこんな感じでした");
            break;
        }
        case 27://#27 変数の範囲
        {
            puts("#27 変数の範囲");
            puts("これまで２回ほど自作関数について話してきました");
            puts("そして今回も自作関数についての話です");
            puts("とりあえず自作関数で気になることって");
            puts("変数の有効範囲ですよね？ね？");
            puts("前回の説明を読んだ人ならわかると思うけど");
            puts("main関数と自作関数は別物だってのはわかりましたよね");
            puts("簡単に言うと自作関数内で作られた変数と");
            puts("main関数内の変数は別物ということです");
            puts("だからmain関数と自作関数で");
            puts("同じ関数名の関数があっても");
            puts("成り立つのです");
            puts("自作関数内で宣言された変数をローカル変数といい");
            puts("ローカル変数は、宣言された関数内");
            puts("つまりmain関数で宣言された変数は");
            puts("main関数内でしか効力を発揮しない");
            puts("ということです");
            puts("コードを書きますとこうなります");
            puts("");
            puts("#include<stdio.h>");
            puts("");
            puts("void func(void);");
            puts("");
            puts("int main() {");
            puts("        int var = 10;");
            puts("        printf(\"main()関数のvar = %%d\\n\",var);");
            puts("        func();");
            puts("        printf(\"もう一度main()関数のvar = %%d\\n\" , var);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("void func() {");
            puts("        int var = 5;");
            puts("        printf(\"func()関数のvar = %%d\n\",var);");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("main()関数のvar = 10");
            puts("func()関数のvar = 5");
            puts("もう一度main()関数のvar = 10");
            puts("");
            puts("となります");
            puts("当たり前ですがmainとfuncは分離しているため");
            puts("どちらとも変数varが出す値が個別のものになっています");
            puts("でももう少し信頼できるコードを用意しました");
            puts("");
            puts("#include<stdio.h>");
            puts("");
            puts("void func(void);");
            puts("");
            puts("int main() {");
            puts("        int var;");
            puts("        printf(\"main()関数のvar = %%x\\n\" , &var);");
            puts("        func();");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("void func() {");
            puts("        int var;");
            puts("        printf(\"func()関数のvar = %%x\" , &var);");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("main()関数のvar = bff8fc");
            puts("func()関数のvar = bff8cc");
            puts("");
            puts("となります");
            puts("ここからわかる通りどちらの変数も");
            puts("アドレスが違うことがわかります");
            puts("ここから考えるにどちらとも独立して存在しています");
            puts("それとローカル変数で重要なのは");
            puts("関数終了時に変数は消滅してしまうということです");
            puts("関数が一連の作業を終えて元の場所に戻ってしまったとき");
            puts("関数で使われてたローカル変数はなくなってしまいます");
            puts("まぁもう一回自作関数を実行すれば同じように");
            puts("ローカル変数も作られるのでご心配なく");
            puts("");
            puts("ローカル変数は関数内でしか動作しない変数でした");
            puts("しかしそれだとさすがに不便ではありません？");
            puts("その時に出てくるのがグローバル変数です");
            puts("そうですローカルと逆つまり関数外でも同様に動きます");
            puts("ちなみにグローバル変数の宣言方法は");
            puts("関数外で変数を宣言するだけです");
            puts("グローバルというだけあって度の関数からでもアクセスできます");
            puts("しかし、すべての関数からアクセスできるため");
            puts("管理には注意が必要です");
            puts("それではコードどうぞ");
            puts("");
            puts("#include<stdio.h>");
            puts("");
            puts("void func(void);");
            puts("");
            puts("int var = 10;");
            puts("");
            puts("int main() {");
            puts("        printf(\"main() : varのアドレス = %%x\\n\" , &var);");
            puts("        printf(\"main() : varの内容 = %%d\\n\" , var);");
            puts("        func();");
            puts("        var = 100;");
            puts("        func();");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("void func() {");
            puts("        printf(\"func() : varのアドレス = %%x\\n\" , &var);");
            puts("        printf(\"func() : varの内容 = %%d\\n\" , var);");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("main() : varのアドレス = d63004");
            puts("main() : varの内容 = 10");
            puts("func() : varのアドレス = d63004");
            puts("func() : varの内容 = 10");
            puts("func() : varのアドレス = d63004");
            puts("func() : varの内容 = 100");
            puts("");
            puts("当たり前ですがアドレスがすべて同じですねｗ");
            puts("これでわかる通りグローバル変数は");
            puts("どこの関数でも動作する変数になりました");
            puts("ちなみにローカル変数とグローバル変数を");
            puts("同じ名前で作った場合ローカル変数の方が");
            puts("優先される仕組みになってます");
            break;
        }
        case 28://#28 再帰
        {
            puts("#28 再帰");
            puts("今までやってきたものを使えば");
            puts("大体ある関数から別の関数を出す方法はわかったと思う");
            puts("だけど関数を呼び出してて思いません？");
            puts("これ自分自身も呼び出せるんじゃないかって");
            puts("まぁ簡単に言うと今動いてる関数内で");
            puts("もう一度関数を出せるのかってことですね");
            puts("実際それができそのことを再帰と言います");
            puts("再帰を使うことでループを作ることができます");
            puts("ちなみにwhileやforと違うところは");
            puts("whileやforなどよりループの間隔が遅いところですね");
            puts("再帰は一部アルゴリズムを");
            puts("簡素化するのに用いられることがあるそうです");
            puts("");
            puts("#include<stdio.h>");
            puts("");
            puts("void func(int );");
            puts("");
            puts("int main() {");
            puts("        func(0);");
            puts("");
            puts("        printf(\"プログラムを終了します\");");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("void func(int max) {");
            puts("        if (max <= 10000) {");
            puts("                printf(\"%%d\\r\",max);");
            puts("                func(max + 1);");
            puts("        }");
            puts("}");
            puts("");
            puts("実行結果は");
            puts("1〜10000を表示した後にプログラムを終了します");
            puts("と表示します");
            puts("forやwhileと比べて体感0.5秒ぐらいの遅延を感じましたね");
            puts("とりあえずこの再帰はお互いの関数を呼び合う形もあり");
            puts("これは相互再帰と言います");
            puts("コードをどーぞ");
            puts("");
            puts("#include<stdio.h>");
            puts("");
            puts("void func1(int );");
            puts("void func2(int );");
            puts("");
            puts("int main() {");
            puts("        func1(0);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("void func1(int max) {");
            puts("        if (max <= 100) {");
            puts("                printf(\"%%d\",max);");
            puts("                func2(max + 1);");
            puts("        }");
            puts("}");
            puts("");
            puts("void func2(int max) {");
            puts("        printf(\" \");");
            puts("        func1(max + 1);");
            puts("}");
            puts("");
            puts("実行結果は");
            puts("0 2 4 6のように2飛ばしで100までカウントされます");
            puts("とりあえずC言語の関数を使った技術の一つとして覚えておいてください");
            puts("使うは別としてｗ");
            break;
        }
        case 29://#29 仮引数
        {
            puts("#29 仮引数");
            puts("前回仮引数を軽く説明しましたが");
            puts("もう少し掘り下げて説明します");
            puts("まず引数を渡す方法が２つあるんですが");
            puts("その一つ目のが");
            puts("値(value)を引数に渡す方法");
            puts("これが今まで関数に渡してきたものです");
            puts("二つ目が");
            puts("参照(reference)を引数に渡す方法");
            puts("参照とは変数のアドレスのことです");
            puts("前者の値を引数に渡すことを値渡しと呼び");
            puts("後者の参照を引数に渡すことを参照渡しと呼びます");
            puts("値渡しと参照渡しの違いは関数呼び出し元の変数の操作にかかわってきます");
            puts("値渡しは、呼び出し元で指定された値をコピーして仮引数に保存します");
            puts("つまり呼び出し元の変数の値は変えられません");
            puts("参照渡しは、引数で変数のアドレスを渡します");
            puts("関数内で宣言されたローカル変数をほかの関数から");
            puts("操作するには参照渡しを使います");
            puts("プログラムで意図的に引数に変数のアドレスを渡すことによって");
            puts("参照渡しができます");
            puts("コード書きますね");
            puts("");
            puts("#include<stdio.h>");
            puts("");
            puts("void call_by_value(int );");
            puts("void call_by_reference(int *);");
            puts("");
            puts("int main() {");
            puts("    int var = 10;");
            puts("");
            puts("    call_by_value(var);");
            puts("    printf(\"値渡し後 = %%d\n\" , var);");
            puts("");
            puts("    call_by_reference(&var);");
            puts("    printf(\"参照渡し後 = %%d\" , var);");
            puts("");
            puts("    return 0;");
            puts("}");
            puts("");
            puts("void call_by_value(int var) {");
            puts("    var = 100;");
            puts("}");
            puts("");
            puts("void call_by_reference(int *var) {");
            puts("    *var = 100;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("値渡し後 = 10");
            puts("参照渡し後 = 100");
            puts("");
            puts("値渡しはmain関数からvar変数の値をコピーして受け取ったにすぎないため");
            puts("変数を変えようとローカル変数なのでmain関数内の変数は変わりません");
            puts("しかし参照渡しでは");
            puts("アドレスごと渡しておりこれをポインタ変数で受け取ることで");
            puts("その内容を操作することが可能になります");
            puts("このようにグローバル変数を使わなくても");
            puts("関数間で変数の受け渡しができるのです");
            puts("ちなみにscanfで&を使ってた理由もこういうことです");
            break;
        }
        case 30://#30 コマンドライン
        {
            puts("#30 コマンドライン");
            puts("前回までは関数の話をしてきましたが今回は");
            puts("コマンドラインについて話していきます");
            puts("まずmain()関数も関数なので当然引数を受け取ります");
            puts("それじゃあ一体main()関数はどこから引数を受け取っているのでしょか？");
            puts("実はmain()関数はコマンドラインから引数を受け取ることができるのです");
            puts("実用的なアプリ開発をするのには欠かせない知識です");
            puts("今回の説明で作ったプログラムの実行はDOSプロンプト(簡単に言うとコマンドプロンプト)");
            puts("から引数を指定して実行する必要があります");
            puts("最初にmain()関数には二つの引数が渡されます");
            puts("・一つはコマンドラインから渡された引数の数");
            puts("・一つはコマンドライン引数で渡された文字列");
            puts("一般的には第一仮引数をargc、第二引数をargvと呼び");
            puts("argcには引数の数、argvには引数の文字列が入ります");
            puts("そのため普通はこのような形になります");
            puts("");
            puts("一般的なmain()関数の仮引数");
            puts("int main(int argc,char *argv[])");
            puts("");
            puts("仮引数の名前は任意なので別に好きな名前にしてもいいです");
            puts("しかしargcとargvを使うのが暗黙の了解になっているようです");
            puts("まぁほかのプログラマーにプログラムを見せる機会がなければ");
            puts("別に好きな名前にしてもいいとは思います");
            puts("ここで引数の内容にアクセスるには入れいつ変数argvに添え字で");
            puts("指定すればいいのです");
            puts("コードを書くとこうなります");
            puts("");
            puts("#include<stdio.h>");
            puts("");
            puts("int main(int argc , char *argv[]) {");
            puts("        int count = 0;");
            puts("        while (count < argc) {");
            puts("                printf(\"第%%d引数 = %%s\\n\" , count + 1 , argv[count]);");
            puts("                count++;");
            puts("        }");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("というコードを書いてコンパイルしたファイルにtestという名前を付け");
            puts("ファイルのファイルパスをコマンドプロンプトに書き");
            puts("そのあとに好きな文字を入れます");
            puts("(例)");
            puts("C:\\dir-name...\\>test kitty on your lap");
            puts("");
            puts("この時の実行結果が");
            puts("");
            puts("第1引数 = C:\\dir_name...\\TEST.EXE");
            puts("第2引数 = kitty");
            puts("第3引数 = on");
            puts("第4引数 = your");
            puts("第5引数 = lap");
            puts("");
            puts("と表示されるはずです");
            puts("引数の区切りの部分はOSで異なるらしいですが通常はスペースかタブで区切られます");
            puts("ちなみにwindows11で動作しました");
            puts("どうしても理解できなかったって人は");
            puts("");
            puts("#include<stdio.h>");
            puts("");
            puts("int main(int argc , char *argv[]) {");
            puts("        int count = 0;");
            puts("        while (count < argc) {");
            puts("                printf(\"第%%d引数 = %%s\\n\" , count + 1 , argv[count]);");
            puts("                count++;");
            puts("        }");
            puts("        printf(\"Enter>\");");
            puts("        gets(*argv);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("このコードを書いてコンパイルし");
            puts("exeになったファイルに");
            puts("なんでもいいのでファイルをD&Dすると");
            puts("ファイルパスを引数として受け取り");
            puts("そのままファイルパスをひょうじしてくれます");
            break;
        }
        case 31://#31 伝統形式
        {
            puts("#31 伝統形式");
            puts("今まで使ってきた関数名(引数リスト)という書き方は");
            puts("比較的新しい書き方でこのような書き方は");
            puts("ANSI C標準でC言語が標準化されたときに導入されたようです");
            puts("ANSI C標準以前の宣言方法を伝統形式や旧方式と呼ばれるそうです");
            puts("この方式でも現代のコンパイラでコンパイルすることができるそうです");
            puts("さらに過去のC言語ソースで伝統形式が使われてるのを");
            puts("見るかもしれません");
            puts("ってことで伝統形式の引数宣言を覚えておきましょう");
            puts("まぁ新しいほうを使うべきだとされているので");
            puts("これを覚えたとて使う機会はあまりないでしょうねｗ");
            puts("実際覚える理由は");
            puts("過去のＣ言語ソースを読めるようにするためですね");
            puts("それではコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int max(int , int );");
            puts("");
            puts("int main() {");
            puts("    int r_var , var1 , var2;");
            puts("");
            puts("    printf(\"最初の値を入力してください>\");");
            puts("    scanf(\"%%d\" , &var1);");
            puts("    printf(\"比較する値を入力してください>\");");
            puts("    scanf(\"%%d\" , &var2);");
            puts("");
            puts("    r_var = max(var1,var2);");
            puts("    printf(\"%%dのほうが大きいです\",r_var);");
            puts("");
            puts("    return 0;");
            puts("}");
            puts("");
            puts("int max(var1 , var2)");
            puts("int var1,var2;");
            puts("{");
            puts("    if (var1 > var2) return var1;");
            puts("    if (var2 > var1) return var2;");
            puts("    else return var1;");
            puts("}");
            puts("");
            puts("まぁこれは見たらわかりますよねｗ");
            puts("このコードでいつもと違うのは");
            puts("引数リストで仮引数となる変数名しか宣言していないことと");
            puts("そのあとにコードブロックに入る前にそれぞれ引数に形を宣言する形になっている");
            puts("などの違いがありますね〜");
            puts("引数の形が同じであれば");
            puts("int max(var1 , var2)");
            puts("このように宣言できるようです");
            puts("まぁ本当に伝統形式はこれだけです");
            break;   
        }
        case 32://#32 こうぞうたい
        {
            puts("#32 構造体");
            puts("この説明ではポインタと同じぐらい重要な");
            puts("構造体について話していきます");
            puts("ポインタと同じぐらい重要なだけあって");
            puts("構造体の説明が数個あるんですよね");
            puts("それの最初が今回の説明です");
            puts("ってことでとりあえず");
            puts("構造体とは何かについて説明していきます");
            puts("構造体(structure)はデータの集合体を１つの変数で");
            puts("共有するような形になります");
            puts("配列は一つの変数名に複数のデータを代入できるが");
            puts("すべてが同じ型ではないといませんでした");
            puts("しかし構造体では複数の型の関連数る変数を「集合」として扱えます");
            puts("通常一つの構造体が保有するデータは関連性があるもののみです");
            puts("もちろん強制はされませんが、設計論として関係のないデータを");
            puts("一つの構造体としてまとめるのは");
            puts("プログラムとして欠陥と考えられます");
            puts("まぁ簡単に言うと関係ないのが入ってると邪魔だよね");
            puts("みたいなことです");
            puts("たとえですが");
            puts("四角形は４つの数値から成り立ちますよね");
            puts("４つの数値は四角形の点の座標を格納します");
            puts("簡単にいうなれば４つで１つだよ見たいなことです");
            puts("まぁそういう集まりのことを構造体としてとらえるのです");
            puts("とりあえず構造体として関連しあう変数は構造体メンバと呼びます");
            puts("構造体を利用するには最初の構造体を");
            puts("実体化させる必要があるそうです");
            puts("ちなみに構造体変数のことをオブジェクトやインスタンス");
            puts("と呼ぶこともあるそうです");
            puts("構造体の宣言はstuctキーワードを用い宣言します");
            puts("まぁこんな感じです");
            puts("");
            puts("struct タグ名 {");
            puts("    型 メンバ１;");
            puts("    型 メンバ2;");
            puts("    型 メンバn;");
            puts("    .");
            puts("    .");
            puts("    .");
            puts("}構造体変数リスト;");
            puts("");
            puts("タグ名はそのままお好きな名前にしてもらって");
            puts("型はintやcharのことですね");
            puts("タグ名は構造体変数を新しく追加するときに必要になります");
            puts("ちなみに一応変数としての宣言なので");
            puts("最後に；セミコロンを忘れないでください");
            puts("それと構造体リストでの宣言のみであれば");
            puts("省略してもいいようです");
            puts("とりあえず例で軽く書くならこうなります");
            puts("");
            puts("struct {");
            puts("    char *name;");
            puts("    int age;");
            puts("}naru , sinobu;");
            puts("");
            puts("はい、勉強しながらこれを書いているので");
            puts("私にはよくわかりません★");
            puts("とりあえず最後についているnaru,sinobuは");
            puts("構造体に変数が宣言されているのです");
            puts("naruとsinobuは構造体変数の「実体」として");
            puts("存在します");
            puts("これが宣言されて初めて*nameやageといったメンバが使用できるようになります");
            puts("逆に言えばメンバは構造体変数がなければ");
            puts("使えないのです");
            puts("なぜならメンバはすべて構造体変数に対して");
            puts("定義されているためです");
            puts("構造体変数が生成されると");
            puts("各構造体変数にメンバが割り当てられ");
            puts("メンバはすべて、構造体変数に対して定義されます");
            puts("ちなみに構造体メイトメンバ名にはどっと演算子を使います");
            puts("こんな感じで");
            puts("");
            puts("構造体変数名.メンバ名");
            puts("");
            puts("これで宣言した構造体変数のメンバに値を");
            puts("代入や参照することができます");
            puts("とりあえずこんなこと言われてもわかりにくいと思うので");
            puts("コードをどーぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("struct {");
            puts("        char *name;");
            puts("        int age;");
            puts("}naru , sinobu;");
            puts("");
            puts("int main() {");
            puts("        naru.name = \"成瀬川なる\";");
            puts("        naru.age = 17;");
            puts("        sinobu.name = \"前原しのぶ\";");
            puts("        sinobu.age = 13;");
            puts("");
            puts("        printf(\"名前\\t\\t年齢\\n\");");
            puts("        printf(\"%%s\\t%%d\\n\" , naru.name , naru.age);");
            puts("        printf(\"%%s\\t%%d\\n\" , sinobu.name , sinobu.age);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("名前            年齢");
            puts("成瀬川なる      17");
            puts("前原しのぶ      13");
            puts("");
            puts("となります");
            puts("このコードの場合naru.nameがnameメンバにアクセスています");
            puts("この時構造体は構造体変数別にメモリアドレスが割り振られています");
            puts("つまり構造体変数別でメンバ変数が割り当てられているってことです");
            puts("まぁ確認するためにはいつも通りアドレス出力ですよねｗ");
            puts("ちなみにアドレス出力するためには");
            puts("構造体変数名の前に&をつけるだけです");
            puts("ってことでアドレス出力させるコードがこちらです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("struct {");
            puts("        char *name;");
            puts("        int age;");
            puts("}naru , sinobu;");
            puts("");
            puts("int main() {");
            puts("        printf(\"naru.name = %%x\\n naru.age = %%x\\n\" , &naru.name , &naru.age);");
            puts("        printf(\"sinobu.name = %%x\\n sinobu.age = %%x\\n\" , &sinobu.name , &sinobu.age);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("naru.name = f5603c");
            puts("naru.age = f56040");
            puts("sinobu.name = f56044");
            puts("sinobu.age = f56048");
            puts("");
            puts("となりメンバ変数のアドレスが違うことがわかりますよね");
            puts("まぁこのように構造体変数別にメンバ変数が構成されていることがわかりますね");
            puts("ちなみに後から構造体変数を追加したい！");
            puts("ってなった時でも大丈夫！");
            puts("ちゃんとあとからでも構造体変数を追加できます");
            puts("やり方は簡単");
            puts("関数内で");
            puts("");
            puts("struct タグ名 追加構造体変数名;");
            puts("");
            puts("と宣言すると構造体変数が新しく作られます");
            puts("コードで見せるとこうなります");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("struct LOVE_HINA {");
            puts("        char *name;");
            puts("        int age;");
            puts("}naru , sinobu;");
            puts("");
            puts("int main() {");
            puts("        struct LOVE_HINA motoko;");
            puts("        naru.name = ""成瀬川なる"";");
            puts("        naru.age = 17;");
            puts("        sinobu.name = ""前原しのぶ"";");
            puts("        sinobu.age = 13;");
            puts("        motoko.name = ""青山素子"";");
            puts("        motoko.age = 15;");
            puts("");
            puts("        printf(\"名前\\t\\t年齢\\n\");");
            puts("        printf(\"%%s\\t%%d\\n\" , naru.name , naru.age);");
            puts("        printf(\"%%s\\t%%d\\n\" , sinobu.name , sinobu.age);");
            puts("        printf(\"%%s\\t%%d\\n\" , motoko.name , motoko.age);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("名前            年齢");
            puts("成瀬川なる      17");
            puts("前原しのぶ      13");
            puts("青山素子        15");
            puts("");
            puts("実行結果を見るにちゃんと追加されていますよね");
            puts("それとC言語ではstructキーワードを明示的に使わなければ");
            puts("構造体変数を宣言できません");
            puts("今は触れてないC++では、型が定義されていれば省略できるようなので");
            puts("C++ユーザーはここの違いをちゃんと意識しないといけないようですね");
            puts("これで構造体の基本的な説明は終わりです");
            puts("こんだけ説明してまだ基本なんて信じられませんよねｗ");
            break;
        }
        case 33://#33 続・こうぞうたい
        {
            puts("#33 続・こうぞうたい");
            puts("前回の説明ではこうぞうたいの作り方について話しましたね");
            puts("まぁ今回はあれに配列要素を入れただけです");
            puts("ちなみにこうぞうたい変数とメンバ変数どちらでも配列できます");
            puts("ってことで二つの例を出しましょう");
            puts("");
            puts("struct タグ名 こうぞうたい変数名[配列数];");
            puts("");
            puts("こうぞうたい変数名[添え字].メンバ名");
            puts("");
            puts("この二つですね");
            puts("まぁ今回はただ配列要素を入れただけなんで");
            puts("使い方的はに普通の配列と同じです");
            puts("とりあえずコードを書くのですが");
            puts("配列型こうぞうたい変数の宣言とアクセスに注目してください");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("struct LOVE_HINA {");
            puts("        char *name;");
            puts("        int age;");
            puts("};");
            puts("");
            puts("int main() {");
            puts("    int ary_index;");
            puts("    struct LOVE_HINA structNA[3];");
            puts("");
            puts("    structNA[0].name = \"成瀬川なる\";");
            puts("    structNA[0].age = 17;");
            puts("    structNA[1].name = \"前原しのぶ\";");
            puts("    structNA[1].age = 13;");
            puts("    structNA[2].name = \"青山素子\";");
            puts("    structNA[2].age = 15;");
            puts("");
            puts("    printf(\"なる = 0 , しのぶ = 1 , 素子 = 2>\");");
            puts("    scanf(\"%%d\", &ary_index);");
            puts("    if ((ary_index >= 0) && (ary_index <= 2)) {");
            puts("        printf(\"名前\\t\\t年齢\\n\");");
            puts("        printf(\"%%s\\t%%d\" , structNA[ary_index].name , structNA[ary_index].age);");
            puts("    }");
            puts("    else printf(\"エラー : その番号のデータはありません\");");
            puts("");
            puts("    return 0;");
            puts("}");
            puts("実行結果は");
            puts("");
            puts("なる = 0 , しのぶ = 1 , 素子 = 2>0");
            puts("");
            puts("と聞かれて選択した数字の情報を出すようなプログラムです");
            puts("ちなみに軽く解説をしますと");
            puts("struct LOVE_HINA structNA[3];で");
            puts("こうぞうたいにstructNA[3]配列型こうぞうたい変数が作られています");
            puts("それでそのあと添え字ごとにメンバ変数に値を入れていき");
            puts("選択した数字の情報を出すようなプログラムを作っています");
            puts("それとこうぞうたい変数は双方が同じ型であれば");
            puts("こうぞうたい変数をほかのこうぞうたい変数に代入することができます");
            puts("この時対象となるのはこうぞうたい変数だけではなくメンバ変数の内容も継承されます");
            puts("コードをどーぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("struct copy {");
            puts("        char str[128];");
            puts("        int var1;");
            puts("        double var2;");
            puts("}st_var1;");
            puts("");
            puts("int main() {");
            puts("        struct copy st_var2;");
            puts("");
            puts("        printf(\"文字列の入力>\");");
            puts("        scanf(\"%%s\" , st_var1.str);");
            puts("        st_var1.var1 = 100;");
            puts("        st_var1.var2 = 10.1435;");
            puts("");
            puts("        st_var2 = st_var1;");
            puts("");
            puts("        printf(\"str = %%s\\n\" , st_var2.str);");
            puts("        printf(\"var1 = %%d\\n\" , st_var2.var1);");
            puts("        printf(\"var2 = %%g\" , st_var2.var2);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("str = (指定した文字列)");
            puts("var1 = 100");
            puts("var2 = 10.1435");
            puts("");
            puts("となります");
            puts("ちなみに値を代入したところは見たらわかると思いますが");
            puts("st_var2 = st_var1;");
            puts("ここです");
            puts("これで簡単にst_var1を簡単に全部コピーできますね");
            puts("それとこの前説明した自作関数などとも組み合わせて");
            puts("使うことができます");
            puts("まぁプログラミングなんて応用だからできて(ry");
            puts("こうぞうたいでもローカル変数やグローバル変数が存在しています");
            puts("関数内で宣言されこうぞうたい変数はローカル変数");
            puts("こうぞうたい定義時に宣言されたこうぞうたい変数はグローバル変数です");
            puts("まぁこの辺は自作関数の説明でも似たようなことがあったので");
            puts("大体想像できたかと思います");
            puts("ちなみにこうぞうたい変数は");
            puts("自作関数の時に説明した");
            puts("グローバル変数、ローカル変数と同じ特徴があります");
            puts("つまりローカル変数は宣言された関数内でしか効力を発揮しません");
            puts("グローバル変数はどの関数内でも効力を発揮します");
            puts("ただそれだけです");
            puts("ちなみに自作関数の説明の時に");
            puts("自作関数にアドレスを渡す参照渡しをしていましたが");
            puts("ローカルメンバ変数でそれをやるのはいい対策ではないらしいです");
            puts("ほかの関数にこうぞうたいの値を渡したい場合");
            puts("ローカルメンバ変数の参照渡しではなく");
            puts("ローカルこうぞうたい変数の参照渡しをする必要があるようです");
            puts("それにこうぞうたい変数は、こうぞうたい変数を代入できるように");
            puts("同じ形のこうぞうたい変数であれば関数間の受け渡しも可能らしいです");
            puts("まぁ完全に同じものを送りたいのなら");
            puts("同じ形じゃないといけないんですけどね");
            puts("ことちらは言葉じゃ説明が難しいので");
            puts("コードを書きます");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("struct LOVE_HINA {");
            puts("    char *name;");
            puts("    int age;");
            puts("}naru , sinobu;");
            puts("");
            puts("void func(struct LOVE_HINA);");
            puts("");
            puts("int main() {");
            puts("    struct LOVE_HINA motoko;");
            puts("");
            puts("    naru.name = \"成瀬川なる\";");
            puts("    naru.age = 17;");
            puts("    sinobu.name = \"前原しのぶ\";");
            puts("    sinobu.age = 13;");
            puts("    motoko.name = \"青山素子\";");
            puts("    motoko.age = 15;");
            puts("    ");
            puts("    printf(\"名前\\t\\t年齢\\n\");");
            puts("    func(naru);");
            puts("    func(sinobu);");
            puts("    func(motoko);");
            puts("");
            puts("    return 0;");
            puts("}");
            puts("");
            puts("void func(struct LOVE_HINA hina) {");
            puts("    printf(\"%%s\\t%%d\\n\",hina.name , hina.age);");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("名前            年齢");
            puts("成瀬川なる      17");
            puts("前原しのぶ      13");
            puts("青山素子        15");
            puts("");
            puts("このようにローカルこうぞうたい変数であれば");
            puts("参照渡しが可能なのです");
            puts("ちなみにこれ普通にこうぞうたい変数名を指定した後にメンバ名を指定するより");
            puts("手間が省けていいなって思いましたね");
            puts("当たり前ですがローカル変数のデメリットも突破できます");
            puts("さらに、自作関数独特の戻り値で値を返すことも");
            puts("こうぞうたい変数でもできちゃうんですよね");
            puts("方法は、同じく戻り値の形をこうぞうたいの形に合わせます");
            puts("");
            puts("struct LOVE_HINA func(void);");
            puts("");
            puts("戻り値を返す方法を使えば面倒なこうぞうたい変数の初期化を");
            puts("一括することができます");
            puts("たとえば、引数でメンバに初期化する値を受け取り");
            puts("あとはこうぞうたい変数を返せばいいのです");
            puts("コードどーぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("struct LOVE_HINA {");
            puts("    char *name;");
            puts("    int age;");
            puts("}naru , sinobu;");
            puts("");
            puts("void func(struct LOVE_HINA);");
            puts("struct LOVE_HINA LOVE_HINA(char * , int);");
            puts("");
            puts("int main() {");
            puts("    struct LOVE_HINA motoko;");
            puts("");
            puts("    naru = LOVE_HINA(\"成瀬川なる\" , 17);");
            puts("    sinobu = LOVE_HINA(\"前原しのぶ\" , 13);");
            puts("    motoko = LOVE_HINA(\"青山素子\" , 15);");
            puts("    ");
            puts("    printf(\"名前\\t\\t年齢\\n\");");
            puts("    func(naru);");
            puts("    func(sinobu);");
            puts("    func(motoko);");
            puts("");
            puts("    return 0;");
            puts("}");
            puts("");
            puts("void func(struct LOVE_HINA hina) {");
            puts("    printf(\"%%s\\t%%d\\n\",hina.name , hina.age);");
            puts("}");
            puts("");
            puts("struct LOVE_HINA LOVE_HINA(char *name , int age) {");
            puts("    struct LOVE_HINA hina;");
            puts("    hina.name = name;");
            puts("    hina.age = age;");
            puts("");
            puts("    return hina;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("名前            年齢");
            puts("成瀬川なる      17");
            puts("前原しのぶ      13");
            puts("青山素子        15");
            puts("");
            puts("このようになります");
            puts("実際これを見ててstruct LOVE_HINA LOVE_HINA(char * , int);");
            puts("この部分がマジで意味わからなさ過ぎて頭パンクしそうでしたｗ");
            puts("とりあえず説明ですが");
            puts("このプログラムでは");
            puts("こうぞうたいを初期化するための関数LOVE_HINA()を作りました");
            puts("これで、何個こうぞうたいを作ろうともこの関数を呼び出すだけなので");
            puts("かなり便利に作業効率を上げられますね");
            puts("ちなみにこれ気づいた方もいるかもしれませんが");
            puts("関数の名前がタグと同じなんですよね");
            puts("しかしこのプログラム実は");
            puts("関数の名前とタグの名前が同じでも衝突しないのです");
            puts("ちなみにメンバは構造体によって呼び出される変数のため");
            puts("メンバと変数名の衝突もないらしいです");
            puts("ぼくにはもう意味が分からないですｗ");
            break;
        }
        case 34://#34 構造体ポインタ
        {
            puts("#34 構造体ポインタ");
            puts("前回は構造体の配列について話しましたよね");
            puts("前回の配列で説明したやり方は");
            puts("戻り値を受け取る方法でした");
            puts("しかし、構造体は多くの変数を持つため");
            puts("実用的なプログラムの場合は");
            puts("相当な領域を使用することが考えられます");
            puts("サイズの大きい構造体を関数に値渡しすることは");
            puts("合理的ではありません");
            puts("まぁ理由はご想像の通り");
            puts("時間もかかるし容量も必要になります");
            puts("それを改善するのがポインタを使って");
            puts("参照渡しをすることです");
            puts("構造体変数は普通の変数の");
            puts("参照渡しと同じやり方で行えます");
            puts("普通の参照渡しでもポインタにしていたので");
            puts("構造体変数でもポインタにしなくてはいけません");
            puts("構造体変数のポインタも普通のと同じく*を使います");
            puts("問題のアクセス方法ですが構造体ポインタは");
            puts("ドット演算子は使えません");
            puts("代わりに構造体変数がポインタであることを");
            puts("明示的に表すアロー演算子を用います");
            puts("アロー演算子なこのように書きます");
            puts("->");
            puts("どっからどう見ても矢印ｗ");
            puts("とりあえずこれを使ったコードがこちらです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("struct {");
            puts("        int var;");
            puts("}obj , *po;");
            puts("");
            puts("int main() {");
            puts("        po = &obj;");
            puts("        obj.var = 100;");
            puts("");
            puts("        printf(""%%d"" , po->var);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("出力結果");
            puts("");
            puts("100");
            puts("");
            puts("これはpoポインタ変数にobjのアドレスを代入したことによって");
            puts("po=objみたいな関係になったわけです");
            puts("これによってpoからobjの値を出せるようになったため");
            puts("最後の文字列を出力する際に");
            puts("po->varでpoポインタから参照し");
            puts("obj.varの値を出力したのです");
            puts("ポインタで構造体変数を参照渡しするのであれば");
            puts("実行速度に大きな影響を及ぼすことなく");
            puts("構造体を関数で処理数ることによって作業の効率化をはかれます");
            puts("コードを書くとこうなります");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("struct LOVE_HINA {");
            puts("    char *name;");
            puts("    int age;");
            puts("};");
            puts("");
            puts("struct LOVE_HINA LOVE_HINA(char * , int);");
            puts("void write(struct LOVE_HINA *);");
            puts("");
            puts("int main() {");
            puts("    struct LOVE_HINA naru = LOVE_HINA(\"成瀬川なる\", 17);");
            puts("    struct LOVE_HINA sinobu = LOVE_HINA(\"前原しのぶ\" , 13);");
            puts("    printf(\"名前\\t\\t年齢\\n\");");
            puts("    write(&naru);");
            puts("    write(&sinobu);");
            puts("");
            puts("    return 0;");
            puts("}");
            puts("");
            puts("struct LOVE_HINA LOVE_HINA(char name[] , int age) {");
            puts("    struct LOVE_HINA obj;");
            puts("    obj.name = name;");
            puts("    obj.age = age;");
            puts("    return obj;");
            puts("}");
            puts("");
            puts("void write(struct LOVE_HINA *obj) {");
            puts("    printf(\"%%s\\t%%d\\n\" , obj->name , obj->age);");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("名前            年齢");
            puts("成瀬川なる      17");
            puts("前原しのぶ      13");
            puts("");
            puts("となります");
            puts("コードでポインタが使われているところは");
            puts("自作関数のwrite()で使われています");
            puts("ちなみにメンバ変数で->を使わないと");
            puts("アドレスが表示されてしまうので気を付けてくださいね");
            puts("ポインタ構造体変数の説明は以上です");
            break;
            
        }
        case 35://#35 構造体ネスト
        {
            puts("#34 構造体ポインタ");
            puts("前回は構造体変数のポインタについて教えていきました");
            puts("今回は構造体変数の中に構造体変数を入れる方法について教えていきます");
            puts("今回はマジで頭パンクするんで頑張って理解してくださいね！");
            puts("実際僕は理解するまで頭パンク寸前でした");
            puts("とりあえず例でコードを軽く書きます");
            puts("");
            puts("struct base {");
            puts("    int a;");
            puts("};");
            puts("struct sec {");
            puts("    struct base obj1;");
            puts("}obj2;");
            puts("");
            puts("こうなります");
            puts("ちなみにこれは何を言いたいかというと");
            puts("構造体変数obj2内に構造体baseがあり");
            puts("その中には文字列aがあるのみたいな状態です");
            puts("ちなみにこれを式などで使う場合");
            puts("obj2.obj1");
            puts("このようにします");
            puts("これはobj2の中のobj1にアクセスしたいよ〜");
            puts("ってことを言っています");
            puts("ちなみに必ず外側から内側に参照していきます");
            puts("こんなこと言ってもあれ何で");
            puts("コードどーぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("struct Param {");
            puts("    char *name;");
            puts("    int age;");
            puts("};");
            puts("");
            puts("struct LOVE_HINA {");
            puts("    struct Param hina;");
            puts("}naru , sinobu;");
            puts("");
            puts("struct LOVE_HINA2 {");
            puts("    char *tabacco;");
            puts("    struct Param hina;");
            puts("}haruka;");
            puts("");
            puts("void Param(struct Param * , char * , int);");
            puts("");
            puts("int main() {");
            puts("    printf(\"名前\\t\\t年齢\n\");");
            puts("    Param(&naru.hina , \"成瀬川なる\" , 17);");
            puts("    Param(&sinobu.hina , \"前原しのぶ\" , 13);");
            puts("    Param(&haruka.hina , \"浦島はるか\" , 27);");
            puts("    haruka.tabacco = \"マルボ○\";");
            puts("    printf(\"はるかさん、タバコは%%sらしい…\" , haruka.tabacco);");
            puts("");
            puts("    return 0;");
            puts("}");
            puts("");
            puts("void Param(struct Param *obj , char *name , int age) {");
            puts("    obj->name = name;");
            puts("    obj->age = age;");
            puts("    printf(""%%s\\t%%d\n"" , obj->name , obj->age);");
            puts("}");
            puts("");
            puts("出力結果は");
            puts("");
            puts("前            年齢");
            puts("成瀬川なる      17");
            puts("前原しのぶ      13");
            puts("浦島はるか      27");
            puts("はるかさん、タバコはマルボ○らしい…");
            puts("");
            puts("となります");
            puts("LOVE_HINA、LOVE_HINA2構造体のメンバparam型のメンバ変数が");
            puts("ありますよね");
            puts("構造体をネストすることによって");
            puts("特定のメンバをほかの構造体に継承させることができます");
            puts("簡単に言うと");
            puts("構造体１の中に構造体２のメンバ変数が間接的にある");
            puts("みたいなことです");
            puts("ちなみにこれはオブジェクト指向の");
            puts("継承とは関係がないそうです");
            puts("このように構造体ネストを使えば");
            puts("構造体の中にわざわざ新しいメンバ変数を");
            puts("作らなくてもよくなります");
            puts("つまり使いまわしができるということです");
            puts("ちなみにポインタと使い合わせたらこうなります");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("struct test {");
            puts("        int a;");
            puts("};");
            puts("");
            puts("struct {");
            puts("        struct test base;");
            puts("}obj , *po;");
            puts("");
            puts("int main() {");
            puts("        obj.base.a = 100;");
            puts("        po = &obj;");
            puts("        printf(\"%%d\" , po->base.a);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("冷静に考えれば実行結果はわかりますが");
            puts("実行っけかを書いておきますね");
            puts("");
            puts("100");
            puts("");
            puts("これは100を出力します");
            puts("あたりまえです");
            puts("まぁ構造体ネストの説明はこのぐらいです");
            puts("ってことで終わり");
            break;
        }
        case 36://#36 ビットフィールド
        {
            puts("#36 ビットフィールド");
            puts("前回の説明では構造体のネストを説明しましたが");
            puts("今回は構造体のビットフィールドについてお教えします");
            puts("まぁまずビットフィールドはあまり見られないらしいですけどねｗ");
            puts("とりあえずこのビットフィールドというのは");
            puts("一つのメモリ領域に名前を付けてビット単位で振り分けるものです");
            puts("例えば1ビットのchar型の変数を作る");
            puts("などの使い方ですね");
            puts("ちなみに4ビット領域を持つ変数は作成できないらしいです");
            puts("まぁこのように変数の領域を定めたいときにビットフィールドを使います");
            puts("ビットフィールドは構造体の生成とほぼ同じです");
            puts("ビットフィールドで使われる型は");
            puts("通常intまたはunsignedです");
            puts("singnedの場合は上位ビットが符号に使われます");
            puts("ちなみに書き方はこうなります");
            puts("");
            puts("型　名前　サイズ；");
            puts("");
            puts("型は説明した通り");
            puts("名前には構造体のメンバ同様");
            puts("ビット領域の名前を指定します");
            puts("サイズにはビット領域を指定します");
            puts("4と指定したら指定した名前の領域に4ビット");
            puts("割り当てられます");
            puts("このような特徴から、ビットフィールドは特定のビット数で");
            puts("確実に表現できる情報に用いられます");
            puts("たとえば、boolean型(真偽しかとらない型)の変数の作成などにはビットフィールドが有効です");
            puts("1ビット生成しておけば、確実に0か1しか入りません");
            puts("ってことでコードどーぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("struct {");
            puts("        unsigned bool: 1;");
            puts("}Boolean;");
            puts("");
            puts("int main() {");
            puts("        Boolean.bool = 2;");
            puts("        printf(\"2 = %%d\\n\" , Boolean.bool);");
            puts("");
            puts("        Boolean.bool = 3;");
            puts("        printf(\"3 = %%d\" , Boolean.bool);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("2 = 0");
            puts("3 = 1");
            puts("");
            puts("ってことで解説ですね");
            puts("この時uoolean型は2進数上で");
            puts("0なら1に1なら0という処理をします");
            puts("この時構造体変数Booleanは2と3の値を");
            puts("もらいましたね");
            puts("いつもの４バイトなら");
            puts("2と3が表示されましたが");
            puts("1ビットしかないので");
            puts("2は2進数で0010になるのですが");
            puts("1ビットしかないので");
            puts("最後の0しでしか値を出せません");
            puts("つまり0ということになるのです");
            puts("3の場合も同じく2進数にすると");
            puts("0011になるので");
            puts("出力が1になるのです");
            puts("ただビットフィールド自体１ビットでも");
            puts("構造体変数の領域は通常の４バイトの領域であることに注意してください");
            puts("もちろんビットフィールドは一つの構造体に任意の数を生成することができます");
            puts("ビットフィールドが使われている構造体に");
            puts("通常のメンバを宣言することも可能です");
            puts("このビットフィールドを使うことで");
            puts("特殊なデータ型を扱う変数の生成に活用したり");
            puts("不用意なデータの代入で起こるエラーを未然に防ぐことが可能です");
            puts("上手に使い分けましょう");
            break;
        }
        case 37://#37 共用体
        {
            puts("#37 共用体");
            puts("前回はビットフィールドを教えましたもう一度");
            puts("構造体に戻り共用体を教えます");
            puts("まぁ構造体に戻りって言ってるけど");
            puts("構造体とはあまり関係ないんだけどね");
            puts("とりあえず共用体とは構造体と類似した機能で");
            puts("共用体は一つのメモリに複数の変数を割り当てます");
            puts("ただ、共用体に割り当てられたアドレスはすべて同じです");
            puts("アドレスが一つということは");
            puts("扱える変数が１つしかありません");
            puts("不便ですよねぇｗ");
            puts("それで共用体の作り方ですが");
            puts("共用体を作る場合unionキーワードを使用します");
            puts("ちなみに作り方は構造体と同じです");
            puts("");
            puts("union タグ名{");
            puts("    型 メンバ名;");
            puts("    ...");
            puts("} 共用体変数名;");
            puts("");
            puts("こんな感じですね");
            puts("まぁさっきも軽く触れましたが");
            puts("共用体メンバはすべて同じメモリ空間に割り当てられています");
            puts("一つのメンバの値を変更すると");
            puts("当然アドレス先の内容が変わるので");
            puts("ほかのメンバの値も変わります");
            puts("共用体も構造体とアドレスが");
            puts("一つというところ以外は同じで");
            puts("メンバ変数へのアクセスの形も同じです");
            puts("つまりこういうことです");
            puts("");
            puts("共用体変数.メンバ名;");
            puts("共用体変数->メンバ名;");
            puts("");
            puts("これはまぁ構造体ができる方なら");
            puts("構造体と違いがないことがわかりますね");
            puts("まぁこんなにしゃべっててもあれなので");
            puts("コードをどうぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("union UNION {");
            puts("        char ch;");
            puts("        int n;");
            puts("        double m;");
            puts("};");
            puts("");
            puts("int main() {");
            puts("        union UNION obj;");
            puts("        obj.m = 0;");
            puts("");
            puts("        obj.ch = '@';");
            puts("        printf(\"%%c : %%d : %%g\\n\" , obj.ch , obj.n , obj.m);");
            puts("        obj.n++;");
            puts("        printf(\"%%c : %%d : %%g\\n\" , obj.ch , obj.n , obj.m);");
            puts("        obj.m = 3.26083e-322;");
            puts("        printf(\"%%c : %%d : %%g\\n\" , obj.ch , obj.n , obj.m);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("@ : 64 : 3.16202e-322");
            puts("A : 65 : 3.21143e-322");
            puts("B : 66 : 3.26083e-322");
            puts("");
            puts("これは最初の文字を数字などに直した結果なのですが");
            puts("この三つのどれかが変わったらどれかが変わる");
            puts("そのような仕組みになっています");
            puts("ちなみに共用体は本当にこれだけです");
            puts("共用体の中のメンバの値が変わればほかのメンバの値も変わるよ");
            puts("てきなそれだけです");
            puts("ポインタも同じでメンバの値が変わればほかのメンバ値も変わります");
            puts("ってことで今回は構造体が理解できていれば");
            puts("難しくなったですね！");
        }
        case 38://#38 プリプロセッサ
        {
            puts("#38 プリプロセッサ");
            puts("今までC言語をコンパイルしてきたときに");
            puts("絶対コンパイラを使ってきましたよね？");
            puts("そのコンパイラの話になってきます");
            puts("実はC言語はプリプロセッサ命令というもので、コンパイル時に");
            puts("コンパイラに命令を与えることができます");
            puts("代表的なものが");
            puts("#include");
            puts("ですね");
            puts("これはC言語そのものではなく");
            puts("プリプロセッサに対する命令です");
            puts("これをプリプロセッサディレクティブと呼びます");
            puts("もう一つ頻繁に使用されるプリプロセッサディレクティブ");
            puts("がマクロ置換です");
            puts("マクロは定義に名前を与えるもので、C言語の開発率を");
            puts("向上させてくれるらしいです");
            puts("マクロの定義は#difineディレクティブで行います");
            puts("");
            puts("#difine マクロ名 文字列");
            puts("");
            puts("マクロ内にはマクロの名前を");
            puts("文字列はそのマクロ名の内容を指示します");
            puts("マクロはコンパイル時にソースコードに置き換えられます");
            puts("これは内部フォーマットではないので");
            puts("文字列と型はなんの関係もないらしいです");
            puts("ちなみにマクロの定義では");
            puts("マクロ名と文字列の間には、必ず１つ以上のスペースを入れ");
            puts("一行完結です");
            puts("#include同様にステートメントではないので");
            puts("セミコロンは必要ありません");
            puts("マクロ名はC言語の変数の命令規則に従います");
            puts("しかし多くの場合マクロ名は変数と区別するために大文字にします");
            puts("例でコードを書くとこんな感じ");
            puts("");
            puts("#include <stdio.h>");
            puts("#define SAKURA \"Sakura Kinomoto\"");
            puts("");
            puts("int main() {");
            puts("        printf(\"I'm %%s\" , SAKURA);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("出力結果は");
            puts("");
            puts("I'm Sakura Kinomoto");
            puts("");
            puts("となります");
            puts("これは変数を作り出しているわけではなく");
            puts("printfのSAKUEAの部分がsakura kinomotoに置き換えられています");
            puts("ちなみにマクロは比較的大規模なプログラムや");
            puts("GUIプログラム(SDK MFC)になると多用することになるらしいです");
            puts("多くのライブラリもマクロによる定義を使用しています");
            puts("#defineディレクティブは、C言語のブロックの影響を受けません");
            puts("どの場所にでも定義することができ");
            puts("一度どれを定義すればそれ以降はすべての場所で使用できます");
            puts("それともう一つコードを書きます");
            puts("");
            puts("#include <stdio.h>");
            puts("#define ARYMAX 5");
            puts("");
            puts("");
            puts("int main() {");
            puts("    int ary[ARYMAX] , count;");
            puts("    for (count = 0 ; count < ARYMAX ; count++) {");
            puts("                #define DEF 10");
            puts("                ary[count] = DEF + count;");
            puts("                printf(\"%%d \" , ary[count]);");
            puts("        }");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("10 11 12 13 14");
            puts("");
            puts("このようになります");
            puts("ここではDEFを変数のように使っていますが");
            puts("コンパイラ側では");
            puts("10+count");
            puts("としてコンパイルされます");
            puts("そう置き換えられているので");
            puts("コンパイラ側では");
            puts("DEFが10になっているのです");
            puts("ちなみに定義されたマクロは");
            puts("それ以降ずっと有効です");
            puts("逆に言えば定義されるより上で");
            puts("マクロを使おうとしても使えません");
            puts("しかし有効になてしまったマクロが");
            puts("うっかり変数と衝突してしまうことも考えられます");
            puts("このような事態を避けるため");
            puts("局所的マクロにすることができます");
            puts("一度定義したマクロを");
            puts("放棄または未定義状態にするための");
            puts("ディレクティブで#undef");
            puts("というものがおあります");
            puts("使い方は簡単");
            puts("#undef マクロ名");
            puts("この時マクロ名のところは");
            puts("定義されているものでないといけません");
            puts("コードで書くとこんな感じです");
            puts("");
            puts("#include <stdio.h>");
            puts("#define YUKI \"Kitty on your lap\\n\"");
            puts("");
            puts("int main() {");
            puts("        #ifdef YUKI");
            puts("                printf(YUKI);");
            puts("        #endif");
            puts("");
            puts("        #undef YUKI");
            puts("");
            puts("        #ifdef YUKI");
            puts("                printf(YUKI);");
            puts("      #else");
            puts("              printf(\"ひざの上の同居人\");");
            puts("      #endif");
            puts("      return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("Kitty on your lap");
            puts("ひざの上の同居人");
            puts("");
            puts("となります");
            puts("ちなみに#ifdefはマクロが定義されているなら");
            puts("trueを返し");
            puts("定義されていなければ");
            puts("falseを返します");
            puts("それと最後にある");
            puts("#endifは");
            puts("#ifdefで始められたコンパイルブロックを");
            puts("閉じる際に必ず必要になるものです");
            puts("これがなかったら#elseの時しか");
            puts("書いたプログラムが実行されなくなります");
            puts("それと#defineには、もう少し高度な使用方法もあります");
            puts("これはマクロ関数と呼ばれ");
            puts("プリプロセッサディレクティブには変わりありませんが");
            puts("少しだけ関数的な処理ができるマクロです");
            puts("マクロ関数も");
            puts("やはり仮引数を指定して引数を受け取ることができます");
            puts("しかしプリプロセッサディレクティブであるいじょう");
            puts("動的なプログラムではありません");
            puts("比較的簡易な計算処理をマクロ関数で定義すると");
            puts("開発効率を向上できます");
            puts("マクロ定義は変わらず#defineを使っていきます");
            puts("マクロ名に引数リストを指定することで");
            puts("置き換えるときに指定の定義を算術できます");
            puts("");
            puts("#define マクロ名(引数リスト) 処理");
            puts("");
            puts("これを使ったプログラムがこれです");
            puts("");
            puts("#include <stdio.h>");
            puts("#define ADD(m , n) m = m + n");
            puts("");
            puts("int main() {");
            puts("        int a = 0;");
            puts("        ADD(a , 10);");
            puts("");
            puts("        printf(\"%%d\" , a);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("10");
            puts("");
            puts("まぁこれは予想できましたね");
            puts("解説をすると");
            puts("ADDがマクロ関数になっています");
            puts("この時マクロを使ってaを10に置き換えています");
            puts("正しく言うならa=a+10のaの部分が0だたので");
            puts("a=0+10となりaが10になったんですけどね");
            puts("ちなみにこれは値を渡したり参照しているわけではありません");
            puts("コンパイル時にプリプロセッサによって");
            puts("こう展開されただけなのです");
            puts("");
            puts("ADD(a , 10) -展開-> a = a + 10");
            puts("");
            puts("ちなみにこれはグラフィックを扱うアプリケーションなどでは");
            puts("似たような計算式を多用するらしいです");
            puts("何度も書き直すといくら単純な計算式でも");
            puts("人為的なミスが起こります");
            puts("そのようなこともマクロ関数を使うことで");
            puts("未然に防ぎ開発率の向上を図れるということです");
            puts("つまりミスが減るので開発率の向上につながるということです");
            puts("ただしマクロ関数は算術されて展開されるわけではないので");
            puts("展開後の算術後の算術優先順位で");
            puts("予想していなかった計算順になり");
            puts("正しい答えが得られないことがあるらしいです");
            puts("このような理由でマクロ関数はカッコをつけて");
            puts("計算順序を保護するのが一般的です");
            puts("このように");
            puts("");
            puts("#include <stdio.h>");
            puts("#define ADD(m , n) ((m) + (n))");
            puts("");
            puts("int main() {");
            puts("        int a;");
            puts("        a = ADD(2 * 5 , 9 / 3);");
            puts("        printf(\"%%d\" , a);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("これはもう読めますよね");
            puts("出力結果は");
            puts("(2*5)+(9/3)で");
            puts("答えが１３です");
            puts("ってことで出力結果が");
            puts("13");
            puts("になるわけです");
            puts("それと最後に組み込みマクロについてお話します");
            puts("組み込みマクロとは最初から定義されているマクロのことです");
            puts("こみこみマクロはコンパイラによっては");
            puts("特有のマクロが追加されていたりするかもしれません");
            puts("ここではANSI C標準が定める組み込みマクロを紹介します");
            puts("組み込みマクロで");
            puts("代表的かつ実用的なものは4つあり");
            puts("一つ目が");
            puts("__LINE__");
            puts("ですこれは現在の行番号を出してくれます");
            puts("二つ目が");
            puts("__FILE__");
            puts("ですこれは名前の通り");
            puts("コンパイルされているファイル名です");
            puts("三つ目は");
            puts("__DATE__");
            puts("これはコンパイルの時の日付です(月/日/年)");
            puts("四つ目は");
            puts("__TIME__");
            puts("これはコンパイル時の時間です(時間:分:秒)");
            puts("これを使ったコードをどーぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        printf(\"LINE = %%d\\n\" , __LINE__);");
            puts("        printf(\"FILE = %%s\\n\" , __FILE__);");
            puts("        printf(\"DATE = %%s\\n\" , __DATE__);");
            puts("        printf(\"TIME = %%s\\n\" , __TIME__);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("出力結果");
            puts("");
            puts("LINE = 4");
            puts("FILE = 邱ｴ鄙堤畑.c");
            puts("DATE = Feb 24 2025");
            puts("TIME = 16:07:05");
            puts("");
            puts("このようになります");
            puts("ファイル名は日本語なので文字化けしていますが");
            puts("普通なここにちゃんとした文字が出ます");
            puts("ちなみにプロジェクトによっては");
            puts("ソースファイルがなん十個にも分かれてたりします");
            puts("ファイル名を表示されたり最終コンパイル時間を表示させるなど");
            puts("開発効率の向上に必要なこともあるかもしれません");
            puts("とりあえず次ですが");
            puts("何らかの理由でファイル名と行数を");
            puts("変えなくてはならない場合");
            puts("行数とファイル名を関連付けず変更をする#lineディレクティブがあります");
            puts("");
            puts("#line 行番号 \"ファイル名\"");
            puts("");
            puts("行番号とファイル名を指定することで");
            puts("関連付けられている内容を変更できます");
            puts("ちなみにこれで行数が変わったりファイル名が");
            puts("変わることはありません");
            puts("定数__LINE__と__FILE__の内容を変更するディレクティブです");
            puts("つまり__LINE__や__FILE__で");
            puts("出力される結果を変更できるということです");
            puts("関連付けられている内容を変更するのでコンパイラエラーメッセージも");
            puts("それに従います");
            puts("コードはこんな感じです");
            puts("");
            puts("#include <stdio.h>");
            puts("#define YUKI \"Kitty on your lap\\n\"");
            puts("");
            puts("int main() {");
            puts("        printf(\"LINE = %%d\\n\" , __LINE__);");
            puts("        printf(\"FILE = %%s\\n\" , __FILE__);");
            puts("");
            puts("        #line 100 \"love_hina\"");
            puts("");
            puts("        printf(\"LINE = %%d\\n\" , __LINE__);");
            puts("        printf(\"FILE = %%s\\n\" , __FILE__);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果は");
            puts("");
            puts("LINE = 5");
            puts("FILE = 邱ｴ鄙堤畑.c");
            puts("LINE = 101");
            puts("FILE = love_hina");
            puts("");
            puts("こうなりちゃんと変更されていることがわかります");
            puts("組み込みマクロはこんな感じでファイル名や行番号を変えることができます");
            puts("これから先こういうのも利用してアプリを作れるようになりたいですねｗ");
        }
        case 39://#39 デバック
        {
            puts("#39 デバック");
            puts("前回はプリプロセッサについてお教えしましたが");
            puts("今回はもう少し深堀していきます");
            puts("まずプリプロセッサディレクティブは");
            puts("プログラムの一部を条件によって選択して");
            puts("コンパイルする命令があります");
            puts("条件付きコンパイルによって");
            puts("柔軟なコンパイルが可能になります");
            puts("条件付きコンパイルは");
            puts("ifステートメント同様に");
            puts("指定された定数式が真であれば");
            puts("指定範囲をコンパイルします");
            puts("");
            puts("#if 定数式");
            puts("文");
            puts("#endif");
            puts("");
            puts("#ifディレクティブは、#endifまでの文の並びをコンパイルします");
            puts("ただしこの作業は");
            puts("コンパイルより前にされるため");
            puts("定数は定数以上の意味を持ちません");
            puts("つまり変数は指定できません");
            puts("定数式の真偽はソースコードに直接記述することになります");
            puts("このコードによって、コンパイル処理の流れを変えデバックなどに");
            puts("利用することができます");
            puts("とりあえずコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("#define DEBUG 1");
            puts("");
            puts("int main() {");
            puts("        #if DEBUG");
            puts("                printf(\"Back To Your True Shape\\n\");");
            puts("        #endif");
            puts("        printf(\"CLOW CARD\");");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("Back To Your True Shape");
            puts("CLOW CARD");
            puts("");
            puts("これはマクロ DEBUG を #ifが評価しています");
            puts("DEBUG が新であれば、#endifまで文字をコンパイルします");
            puts("何度も言うようにこれは実行時に判定されるのではなく");
            puts("コンパイル前に処理されます");
            puts("ちなみにプリプロセッサディレクティブにもifがあるならelseもあります");
            puts("まぁ使い方的には#ifと#elseという書き方になるんですけどね");
            puts("とりあえず普通のifとelseが使えるなら説明は不要です");
            puts("でも簡単に説明だけ書いておきますね");
            puts("#endif はひとつしか必要ありません");
            puts("#else は#ifが偽の時に指定された文をコンパイルします");
            puts("ちなみに#ifディレクティブには");
            puts("#elifディレクティブというものがあります");
            puts("これはif-else-ifというときに使えます");
            puts("これは多くのプラットフォームでコンパイルされること");
            puts("想定したソースなど");
            puts("複雑な条件コンパイルを作るときに向いています");
            puts("簡易的に書くとこんな感じです");
            puts("");
            puts("#if 定数式");
            puts("文");
            puts("#elif 定数式");
            puts("文");
            puts("#elif 定数式");
            puts("...");
            puts("#endif");
            puts("");
            puts("次に実際にコードを見せますね");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        #if 0");
            puts("                printf(\"Kitty on your lap\\n\");");
            puts("        #elif 1");
            puts("                printf(\"Back To Your True Shape\\n\");");
            puts("        #endif");
            puts("        printf(\"CLOW CARD\");");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("Back To Your True Shape");
            puts("CLOW CARD");
            puts("");
            puts("となります");
            puts("このコードは#elifを用いて");
            puts("段階的に比較を行う例です");
            puts("これらの条件コンパイラには");
            puts("開発者や開発目的");
            puts("プロジェクトの規模によってさまざまでしょう");
            puts("さらに、マクロ名が定義されているか否かで");
            puts("コンパイルを分岐させることもできます");
            puts("この場合マクロに");
            puts("関連付けられている文字に作用しない");
            puts("という特徴があります");
            puts("マクロはマクロ名だけ定義さえすれば");
            puts("その内容を省略することができました");
            puts("簡単に言うと#defineでマクロ名だけを指定した状態です");
            puts("この意味のなさそうな機能も");
            puts("マクロの定義で分岐する");
            puts("条件コンパイルを使用すると");
            puts("威力を発揮します");
            puts("マクロ定義で分岐するには");
            puts("#ifdefディレクティブを使います");
            puts("偽の時に処理する内容は#elseを併用することができます");
            puts("簡易的に書くとこうなります");
            puts("");
            puts("#ifdef マクロ名");
            puts("文");
            puts("#else");
            puts("文");
            puts("#endif");
            puts("");
            puts("マクロ名には存在を認識するマクロ名を指定します");
            puts("指定されたマクロが定義されていなければ偽と判断されます");
            puts("コードを書くとこんな感じ〜");
            puts("");
            puts("#include <stdio.h>");
            puts("#define DEBUG");
            puts("");
            puts("int main() {");
            puts("        #ifdef DEBUG");
            puts("                printf(\"Back To Your True Shape\\n\");");
            puts("        #else");
            puts("                printf(\"Kitty on your lap\\n\");");
            puts("        #endif");
            puts("        printf(\"CLOW CARD\");");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("Back To Your True Shape");
            puts("CLOW CARD");
            puts("");
            puts("となります");
            puts("マクロ名 DEBUG は文字列なども入っていません");
            puts("しかしマクロ自体は定義されているため");
            puts("真を受け取ったというわけです");
            puts("ちなみに逆の作用をする#ifndefディレクティブがあります");
            puts("これはマクロが定義されていなければコンパイルするということです");
            puts("まぁ近い方的にはさっき書いたコードの#ifdefと入れ替える感じで");
            puts("入れると違いがわかるんじゃないでしょうか");
            puts("とりあえず#ifdefを使うか");
            puts("#ifndefを使うかは、状況に合わせて便利な方を判断してください");
            puts("ちなみに#ifdef以外にも、同様の結果を得る方法があります");
            puts("それは#ifとdefinedプリプロセッサ演算子を併用します");
            puts("こんな感じです");
            puts("");
            puts("#if defined マクロ名");
            puts("");
            puts("definedは#ifか#elifのみで使用できます");
            puts("指定されたマクロ名が定義されてれば真");
            puts("定義されてなければ偽");
            puts("ほかの人が書いたソースを読む機会があれば");
            puts("その時に読めるようにしておくために");
            puts("definedの方も覚えておきましょう");
            puts("");
            puts("#include <stdio.h>");
            puts("#define DEBUG");
            puts("");
            puts("int main() {");
            puts("        #if defined DEBUG");
            puts("                printf(\"Back To Your True Shape\\n\");");
            puts("        #else");
            puts("                printf(\"Kitty on your lap\\n\");");
            puts("        #endif");
            puts("        printf(\"CLOW CARD\");");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("Back To Your True Shape");
            puts("CLOW CARD");
            puts("");
            puts("こうなります");
            puts("ちなみにdifinedに!をつけることで");
            puts("真偽を反転させることができます");
            puts("ちなみにデバック用のプリプロセッサ演算子がありまして");
            puts("それが#errorです");
            puts("これはコンパイル時にあえてエラーを出し");
            puts("コンパイルを中止するディレクティブです");
            puts("作り方はこうです");
            puts("");
            puts("#error メッセージ");
            puts("");
            puts("メッセージには");
            puts("エラー時に出力するメッセージを指定します");
            puts("ダブルクォーテーションは必要ありません");
            puts("メッセージは");
            puts("エラー報告と一緒に出力されます");
            puts("エラー報告はコンパイラによって異なります");
            puts("それと#errorの下にある関数は実行されません");
            puts("これで今回は終わりです");
            puts("お疲れさまでした〜");
            puts("てかこれ__FILE__とか#defineとか出てきたけど");
            puts("このディレクティブとか覚えるの大変そうだなぁ...");
            break;
        }
        case 40://#40 #と##演算子
        {
            puts("#40 #と##演算子");
            puts("前回もマクロ系について話してきましたが");
            puts("今回もマクロ系ですｗ");
            puts("とりあえず今回やっていくことを話すと");
            puts("マクロ関数だけで使用できる便利な演算子があるので");
            puts("それについて教えていきます");
            puts("そのマクロ関数で使える便利な演算子");
            puts("の一つが");
            puts("文字列化演算子です");
            puts("これはマクロ関数で受け取った値に対して");
            puts("#をつけることで");
            puts("それを文字列まぁダブルクォーテーションを");
            puts("つけた状態に置き換えるというものです");
            puts("ちなみ忘れないでほしいのが置き換えてるだけということ");
            puts("マジで何回も言うけどこの意識があるかないかで");
            puts("かなり変わってくると思います");
            puts("とりあえず簡易的に書くとこうです");
            puts("");
            puts("#define STRING(str) #str");
            puts("");
            puts("このマクロ関数は");
            puts("仮引数の値をダブルクォーテーションを");
            puts("つけた状態に置き換えます");
            puts("とりあえずコードどうぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("#define PRINT(str) printf(#str \"\\n\")");
            puts("#define STRING(str) #str");
            puts("");
            puts("int main() {");
            puts("        PRINT(Kitty on your lap);");
            puts("        printf(\"%%sバイトは1キロバイト\" , STRING(1024));");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("");
            puts("実行結果");
            puts("");
            puts("Kitty on your lap");
            puts("1024バイトは1キロバイト");
            puts("");
            puts("と出力されます");
            puts("まぁ簡単に説明すると");
            puts("PRINTの方でprintfがあると思いますが");
            puts("ダブルクォーテーションがないですが");
            puts("ちゃんと出力されています");
            puts("なのでダブルクォーテーションの代わりに");
            puts("#を用いても問題ないということがわかりましたね");
            puts("まぁマクロの場合だけだけどｗ");
            puts("ちなみに＃を使うときの利点ですが");
            puts("頻繁にダブルクォーテーションが出てくるときに");
            puts("便利です");
            puts("ちなみにこれは文字列内で\"や\\などをそのまま");
            puts("出力します");
            puts("それで次の演算子です");
            puts("次はトークンを接合する演算子です");
            puts("この演算子は通常のマクロと関数マクロで使えます");
            puts("トークンを接合するというのは");
            puts("名前(例えば変数名)を指定するのに");
            puts("２つ目の文字をくっつけて置き換える作業です");
            puts("まぁ簡単に言えば");
            puts("変数名を合体させるよ的なことです");
            puts("トークン連結には##を使います");
            puts("ちなみに簡易例だとこんな感じです");
            puts("");
            puts("左辺 ## 右辺");
            puts("");
            puts("左辺と右辺にはそれぞれトークンを指定します");
            puts("##によって、この二つのトークンが置き換えられます");
            puts("つまりa##1としたときa1に置き換えられるという仕組みです");
            puts("ってことでこんなに話しててもわからないと思うので");
            puts("コードどうぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("#define var(i) printf(\"var\" #i \" = %%d\\n\" , var ## i)");
            puts("");
            puts("int main() {");
            puts("        int var1 = 10 , var2 = 20;");
            puts("        var(1);");
            puts("        var(2);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("出力結果は");
            puts("");
            puts("var1 = 10");
            puts("var2 = 20");
            puts("");
            puts("となります");
            puts("ちなみに補足ですが");
            puts("printf内に(\"var\"#i\"=%%d\\n\",var ## i)");
            puts("ですが");
            puts("最初のダブルクォーテーションはvarを表示するための");
            puts("ダブルクォーテーションです");
            puts("そこで文字列iを入れたいので#iとして");
            puts("そのあとに=%%d\\nというのを入れたいので");
            puts("またダブルクォーテーションで囲んだということです");
            puts("それで最後にvarと変数iの値を連結させて");
            puts("変数を出力しています");
            puts("ちなみにほかにもマイクロソフト社のコンパイラ(VC++)であれば");
            puts("#@演算子というものがあります");
            puts("#@は文字定数の置換えですが");
            puts("仕様は推奨されてないようです");
            puts("とりあえず今回はこのぐらいです");
            puts("お疲れさまでした");
            break;
        }
        case 41://#41 ファイル操作
        {
            puts("#41 ファイル操作");
            puts("前回はマクロについて話してきました");
            puts("今までではメモリにデータの読み書きを行ってきました");
            puts("今回はメモリではなくファイルに");
            puts("データの読み書きを行っていくための");
            puts("関数を教えていきます");
            puts("実際に実用するプログラムでは、この操作ができなくちゃ");
            puts("話にならないですね");
            puts("とりあえずC言語というものは");
            puts("どのような入力デバイスであろうとも");
            puts("同じ手法で操作することができます");
            puts("これは、ストリームと呼ばれる抽象的な");
            puts("インタフェイスを操作するためです");
            puts("C言語プログラマーは");
            puts("論理的なインタフェイスである「ストリーム」を通して");
            puts("ファイルの入力操作を行います");
            puts("それでファイルに読み書きをするためにまず");
            puts("ファイルをストリームに結び付ける必要があります");
            puts("そのため");
            puts("FILE構造体を使用します");
            puts("FILE構造体はストリームの状態に関する情報を格納し");
            puts("ストリーム入出力操作で使います");
            puts("FILE構造体は");
            puts("stdio.hで定義されています");
            puts("とりあえず簡易的に書きますね");
            puts("");
            puts("FILE *fp;");
            puts("");
            puts("このようにファイル構造体のポインタを宣言します");
            puts("宣言したファイルを開くには");
            puts("fope()関数を使います");
            puts("開くためのコードはこんな感じです");
            puts("");
            puts("FILE *fopen(const char *ファイル名,const char *モード);");
            puts("");
            puts("この関数はファイルへのポインタを返します");
            puts("つまりファイル内のどの場所にあるかを返してくれます");
            puts("ここでもう少しわかりやすくするなら");
            puts("どこの何に何をしたいの？みたいなものが");
            puts("上の簡易コードです");
            puts("本当にそれですｗ");
            puts("まぁそれをするうえでFILE構造体のポインタ変数を");
            puts("宣言していたんですよねｗ");
            puts("ファイル名は開きたいファイル名を指定します");
            puts("ファイル名だけの場合実行ファイルがあるディレクトリ内で");
            puts("ファイルを検索します");
            puts("ほかのディレクトリから検索する場合は、そのプラットフォーム固有の");
            puts("方法でディレクトリを指定します");
            puts("windowsなら\\で区切ってあるやつです");
            puts("それでモードですが");
            puts("r,w,a,r+,w+,a+という六つが存在しています");
            puts("rから説明していくと");
            puts("rは読み込み用としてファイルを開きます");
            puts("つまりファイルを開きます");
            puts("ファイルがない場合はNULL(エラー)を返します");
            puts("wは書き込みモードでファイルを開きます");
            puts("つまり書き込むためにファイルを開きます");
            puts("ファイルがない場合は新しく作成します");
            puts("ファイルがある場合はファイルの内容を破壊しますｗｗ");
            puts("そう破壊ですｗｗ");
            puts("それで");
            puts("aですが");
            puts("追加モードでファイルを開きます");
            puts("つまりファイルに追記できるもーどどえす");
            puts("ファイルがない場合は作成します");
            puts("+がついたものは説明したものにプラスして");
            puts("読み書きができる状態で開きます");
            puts("しかしr+だけは既存のファイルでないと使えません");
            puts("ちなみにrモードでファイルのオープンに失敗するとNULLを返します");
            puts("NULLはstdio.hで定義されているNULLポインタと呼ばれるマクロらしいです");
            puts("NULLポインタは評価結果が0になる整数定数");
            puts("void*型にキャストされた式(void*型は後記)などが返すポインタで");
            puts("標準機関などで頻繁に使用されています");
            puts("NULLはいかなるポインタと比較しても等しくならないポインタ");
            puts("として保障されています");
            puts("しかしマイクロソフトのコンパイラ固有の");
            puts("仕様のbasedポインタは例外らしいですｗ");
            puts("ちなみにNULLが返されることを利用して");
            puts("NULLであればファイルが開けなかったとなるので");
            puts("強制終了するなどのシステムも作れます");
            puts("その時に使うのが");
            puts("exit()関数で");
            puts("これはすべてのバッファをフラッシュ(後処理)をする");
            puts("みたいな関数です");
            puts("普通ファイルシステムはセクタごとにディスクへ");
            puts("書き出しを行っています");
            puts("そのため、１セクタ分のデータがたまるまでは");
            puts("バッファにデータが蓄えられますが");
            puts("exit()関数などを呼び出すとバッファに残っているデータも自動的に");
            puts("書き込まれるようになっています");
            puts("この作業をバッファをフラッシュするといいます");
            puts("exit()関数はstdilb.hヘッダファイルに登録されています");
            puts("");
            puts("void exit(int ステータス);");
            puts("");
            puts("ステータスには終了状態を表します");
            puts("正常終了なら0");
            puts("エラーの時はそれ以外の数値を指定するのが");
            puts("一般的です");
            puts("とりあえず");
            puts("ファイルを開いたら最後に");
            puts("何をしますか？");
            puts("そうです");
            puts("ファイルを開いたら閉じますよね？");
            puts("ってことでファイルを閉じる関数もあります");
            puts("それがfclose()関数というものです");
            puts("これは説明した通り");
            puts("開いたファイルを閉じます");
            puts("ただそれだけですちなみに使い方は");
            puts("");
            puts("int fclose(FILE *ストリーム);");
            puts("");
            puts("*ストリームには閉じるファイルストリームを指定します");
            puts("通常はfopen()関数で取得した有効な");
            puts("ファイルポインタでなければなりません");
            puts("fclose()関数もバッファのフラッシュを行います");
            puts("いろいろ説明してきましたがここで一回");
            puts("コードをどうぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("#include <stdlib.h>");
            puts("");
            puts("int main() {");
            puts("        char fileName[128];");
            puts("        FILE *fp;");
            puts("");
            puts("        printf(\"ファイル名を入力してください>\");");
            puts("        scanf(\"%%s\" , fileName);");
            puts("");
            puts("        fp = fopen(fileName , \"r\");");
            puts("        if (fp == NULL) {");
            puts("                printf(\"ファイルが開けませんでした\");");
            puts("                exit (1);");
            puts("        }");
            puts("        printf(\"ファイルのオープンに成功しました\");");
            puts("");
            puts("        fclose(fp);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("これはファイルの読み込みに成功したら");
            puts("ファイルのオープンに成功しましたという文字が出力されます");
            puts("失敗したらNULLが返され");
            puts("逆の結果が返されます");
            puts("重要なのは以下のプログラムです");
            puts("");
            puts("FILE *fp;");
            puts("fp = fopen(fileName , \"r\");");
            puts("fclose(fp);");
            puts("");
            puts("この基本的な作業を中心に");
            puts("ファイルポインタを操作していきます");
            puts("なのでまずはストリームにファイルを");
            puts("読み込む作業に慣れてください");
            puts("それでファイルの内容を表示する方法についてお教えします");
            puts("ちょっと前にrでファイルを読み込むといいましたが");
            puts("正しくは読み込む準備をしただけです");
            puts("なので読み込む方法をお教えします");
            puts("読み込んだファイルの内容を出力する方法は");
            puts("いくつかあるうちの一つがfgetc()関数です");
            puts("簡易的に書くとこうなります");
            puts("");
            puts("int fgetc(FILE *ストリーム);");
            puts("");
            puts("この関数は指定されたストリームの");
            puts("次の文字をint型で返します");
            puts("正確に言うと");
            puts("unsigned char型で読み込んだ文章をint型に");
            puts("キャストして返しているらしいです");
            puts("ファイル操作の関数に共通しているお約束なのですが");
            puts("エラーが発生したときや");
            puts("ファイルの最後に達したときにEOFを返します");
            puts("EOFマクロは通常-1の値で");
            puts("End Of Fileを表します");
            puts("fgets()関数が返すのはint型ですが");
            puts("下位8バイトはファイルから");
            puts("読み込まれた内容なので問題ないです");
            puts("ってことでそれを利用した");
            puts("コードがこんな感じです");
            puts("");
            puts("#include <stdio.h>");
            puts("#include <stdlib.h>");
            puts("");
            puts("int main() {");
            puts("    char fileName[128];");
            puts("    int getf;");
            puts("    FILE *fp;");
            puts("");
            puts("    printf(\"ファイル名を入力してください>\");");
            puts("    scanf(\"%%s\" , fileName);");
            puts("");
            puts("    fp = fopen(fileName , \"r\");");
            puts("    if (fp == NULL) {");
            puts("        printf(\"ファイルが開けませんでした\");");
            puts("        exit (1);");
            puts("    }");
            puts("    while(1) {");
            puts("        getf = fgetc(fp);");
            puts("        if (getf == EOF) break;");
            puts("        printf(\"%%c\" , getf);");
            puts("    }");
            puts("");
            puts("    fclose(fp);");
            puts("    return 0;");
            puts("}");
            puts("");
            puts("このコードは確実にROFを");
            puts("この方法ではエラーなのかファイルの終わりまで達したのかが");
            puts("わかりません");
            puts("そこで出てくるのがfeof()関数です");
            puts("これは指定されたストリームの現在のファイルポインタの");
            puts("一が最後化を調べるために使います");
            puts("この関数を使えば必ずファイルの最後を");
            puts("求めることができます");
            puts("簡易的コードです");
            puts("");
            puts("int feof(FILE *ストリーム);");
            puts("");
            puts("指定されたストリームファイルの位置がEOFならば0以外を返します");
            puts("ファイルの最後でない場合は0を返します");
            puts("ちなみにコード実行時に同時にエラーをチェックする");
            puts("ferror()関数も存在します");
            puts("簡易関数はこんな感じ");
            puts("");
            puts("int ferror(FILE *ストリーム);");
            puts("");
            puts("この関数は、ストリームでエラーが発生すると0以外の値を返します");
            puts("しかし通常はこの巻子を呼び出さなくてもファイル関数の戻り値で");
            puts("チェックできるため普段は使われないらしいです");
            puts("ちなみに最後にコードどうぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("#include <stdlib.h>");
            puts("");
            puts("int main() {");
            puts("    char fileName[124];");
            puts("    int getf;");
            puts("    FILE *fp;");
            puts("");
            puts("    printf(\"ファイル名を入力してください>\");");
            puts("    scanf(\"%%s\" , fileName);");
            puts("");
            puts("    fp = fopen(fileName , \"r\");");
            puts("    if (fp == NULL) {");
            puts("        printf(\"ファイルが開けませんでした\");");
            puts("        exit (1);");
            puts("    }");
            puts("");
            puts("    while(1) {");
            puts("        if (ferror(fp)) {");
            puts("            printf(\"エラーが発生しました\");");
            puts("            break;");
            puts("        }");
            puts("        getf = fgetc(fp);		");
            puts("        if (!feof(fp)) printf(\"%%c\" , getf);");
            puts("        else break;");
            puts("    }");
            puts("");
            puts("    fclose(fp);");
            puts("    return 0;");
            puts("}");
            puts("");
            puts("ってことでね今回紹介したもの以外にももっと");
            puts("ファイル操作関数は存在するので");
            puts("次の回でお話ししますね！");
            break;
        }
        case 42://#42 標準入出力
        {
            puts("#42 標準入出力");
            puts("前回はファイル操作の基本をやってきました");
            puts("今回はより厳密にファイルの入出力を管理してみましょう");
            puts("ってことで今回は標準出力というファイルとは");
            puts("切っても切り離せない大切な内容を説明します");
            puts("実は今まで無意識のうちに標準出力を使ってきました");
            puts("例えば標準出力とは");
            puts("文字列などの出力先を言います");
            puts("メモリに格納した文字列なども");
            puts("一種のファイルとして考えることができます");
            puts("次の章でやりますが");
            puts("これをディスクに保存することもできるし");
            puts("画面に出力することもできます");
            puts("この画面すなわちディスプレイが");
            puts("標準出力になります");
            puts("逆に、キーボードからの入力が");
            puts("標準入力となります");
            puts("しかし必ずもそうであるとは限りません");
            puts("例えばMS-DOS上で標準出力をテキストファイルに");
            puts("標準出録をテキストファイルに出力することが");
            puts("できます(リダイレクトといいます)");
            puts("FILE構造体で次のような標準入出力ストリームが定義されています");
            puts("FILE *stdin: 標準入力");
            puts("FILE *stdout: 標準出力");
            puts("FILE *stderr: 標準エラー出力");
            puts("例えばfputc()関数などでこれを利用することができます");
            puts("ちなみにfputc()関数はストリームに対して指定文字を書き込みます");
            puts("簡単に言うと標準出力することによって画面に出力できるってことです");
            puts("ってことでfputc()関数の簡易コードです");
            puts("");
            puts("int fputc(int 書き込む文字 , FILE *ストリーム);");
            puts("");
            puts("ちなみにこの関数は");
            puts("書き込む文字はint型ですが");
            puts("その文字をint型からunsigned char型にキャストして出力します");
            puts("まぁ簡単に言うとint型に入ってた文字列を");
            puts("char型に直したよみたいなことです");
            puts("ちなみにfgetc()関数");
            puts("OS側で標準出力を変更できるらしいです");
            puts("ではアプリケーションに重大なエラーが");
            puts("起きたことをユーザーに知らせたいとします");
            puts("しかしユーザーは作業を簡易化するために出力をリダイレクトしてたら");
            puts("エラー報告ができないのです");
            puts("そこで用意されているのが");
            puts("標準出力エラーです");
            puts("これを利用することで");
            puts("エラーが発生したときに標準出力以外を");
            puts("使うことができる");
            puts("ちなみにコード書くとです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        char str[] = \"Kitty on your lap\\n\";");
            puts("        char er[] = \"エラーです : 猫耳を愛しましょう\";");
            puts("        int count ;");
            puts("");
            puts("        for (count = 0 ; str[count] != 0 ; count++) {");
            puts("                fputc(str[count] , stdout);");
            puts("        }");
            puts("        for (count = 0 ; er[count] != 0 ; count++){");
            puts("                fputc(er[count] , stderr);");
            puts("        }");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("普通に実行すると");
            puts("標準出力、標準エラー出力とも");
            puts("ディスプレイに出力されます");
            puts("しかしリダイレクトすると");
            puts("標準エラー出力だえが");
            puts("ディスプレイ出力されるはずです");
            puts("fputc()関数のような");
            puts("FILE構造体の書き込み方を指定する関数などでは");
            puts("fputc()関数を使うのもありです");
            puts("fputc()関数に足しいてfputs()関数も存在します");
            puts("簡易コードです");
            puts("");
            puts("int fputs(const char *文字列,FILE *ストリーム);");
            puts("");
            puts("fputc()関数と違うのは");
            puts("文字ではなく文字列を指定できることです");
            puts("エラーが生じるとEOFを返します");
            puts("成功した場合は正数を返します");
            puts("fputs()関数には文字列の末尾にある");
            puts("ヌル文字を書き込まない");
            puts("という特徴があるらしいです");
            puts("てことでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        char str[] = \"Kitty on your lap\";");
            puts("");
            puts("        fputs(str , stdout);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("今のところファイルへの書き出しや読み込みを");
            puts("やってきませんでしたが");
            puts("このファイル操作をする関数を");
            puts("覚えておけば");
            puts("すぐにファイルへの読み書きができるようになるので");
            puts("頑張ってください");
            puts("ちなみに");
            puts("fputcと似たいものfputsがあるなら");
            puts("fgetcと似たものであるfgetsもあります");
            puts("簡易コードです");
            puts("");
            puts("char *fgets(char *文字列,intサイズ,FILE ストリーム);");
            puts("");
            puts("文字列は、読み込んだ文字列を保存するための");
            puts("文字列バッファのポインタ");
            puts("サイズは読みださず長さを");
            puts("文字列で指定したバッファサイズ以下で指定します");
            puts("ストリームは呼び出すストリームを指定します");
            puts("戻り値は成功したときは");
            puts("読み込んだ文字列へのポインタが");
            puts("エラーかファイルの終了に達したときはNULLを返します");
            puts("この関数も通常はファイルを対象として使われます");
            puts("今回は標準入力を使います");
            puts("標準入力はデフォルトでキーボードに設定されています");
            puts("ってことでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        char str[256];");
            puts("");
            puts("        printf(\"入力してください>\");");
            puts("        fgets(str , 256 , stdin);");
            puts("        fputs(str , stdout);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("これはfgetsがscanfのような働きをしていて");
            puts("fgetsで入力した文字をfputsで出力しています");
            puts("これを見るとコンソール入出力とファイル操作関数は");
            puts("ほとんど同じことができてしまいますね");
            puts("実際その通りで");
            puts("このようにファイル入出力関数をコンソールに使用することができるのです");
            puts("実際その実行する相手がファイル化コンソール化の違いなだけです");
            puts("それで注意してほしいのがstdin、stdout、stderrは内容の変更ができません");
            puts("これらのポインタは定数のため、新しい値を代入することはできないのです");
            break;
        }
        case 43://#43 ファイルの書き込み
        {
            puts("#43 ファイルの書き込み");
            puts("前回は標準入出力について教えていきましたが");
            puts("今回はいよいよファイルへの出力をしていきます");
            puts("まぁ前回標準出力に書き込みをしたんで");
            puts("禅か今なんだfputc()関数などでstdoutを");
            puts("FILE *変数名で作った");
            puts("変数に置き換えるだけです");
            puts("とりあえずファイルに書き込むときはwでしたね");
            puts("fopen()関数でファイルモードをwを指定して");
            puts("開きます");
            puts("そのファイルポインタに対して");
            puts("データを出力すればいいのです");
            puts("簡易コードを書くならこうですね");
            puts("");
            puts("FILE *変数名");
            puts("変数名 = fopen(ファイル名,\"モード\");");
            puts("fptus(\"文字列\",変数名);");
            puts("");
            puts("って感じですね");
            puts("軽く解説すると");
            puts("入力したファイル名でストリームにファイルを");
            puts("読み込みます");
            puts("この時wは前も説明した通り");
            puts("ファイルがなければ作成");
            puts("ファイルがあれば内容を破壊し");
            puts("また書くことができるようにします");
            puts("それでfputs()関数で文字列をファイルに書き込みます");
            puts("そして１文字づつ書き込みたい場合");
            puts("fputc()関数を使用します");
            puts("まぁこれは前回の復習兼応用ですね");
            puts("前回の内容と組み合わせれば");
            puts("ファイルのコピーを取るプログラムも作成できます");
            puts("やり方ですが");
            puts("まず読み込みモードでファイルを開き、変数にその内容を保存します");
            puts("次に書き込みモードでファイルを開き変数の内容を保存するという");
            puts("流れになります");
            puts("これがそのコードになります");
            puts("");
            puts("#include <stdio.h>");
            puts("#include <stdlib.h>");
            puts("");
            puts("int main() {");
            puts("	char fileName[128] , saveName[128];");
            puts("	int text;");
            puts("	FILE *load , *save;");
            puts("");
            puts("	printf(\"コピーしたいファイル名を入れてください>\");");
            puts("	scanf(\"%%s\" , fileName);");
            puts("");
            puts("	if ((load = fopen(fileName , \"r\")) == NULL) {");
            puts("		printf(\"ファイルを開けませんでした\");");
            puts("		exit(1);");
            puts("	}");
            puts("");
            puts("	printf(\"コピーファイル名を入力してください\n存在する場合は内容を破壊します>\");");
            puts("	scanf(\"%s\" , saveName);");
            puts("	");
            puts("	if ((save = fopen(saveName , \"w\")) == NULL) {");
            puts("		printf(\"書き込みに失敗しました\");");
            puts("		exit(1);");
            puts("	}");
            puts("");
            puts("	while(1) {");
            puts("		text = fgetc(load);");
            puts("		if(!feof(load)) fputc(text , save);");
            puts("		else break;");
            puts("	}");
            puts("");
            puts("	fclose(load);");
            puts("	fclose(save);");
            puts("	return 0;");
            puts("}");
            puts("");
            puts("まぁこれは前回stdoutに出力していた部分を");
            puts("書き込み用で開いたファイルに出力することによって");
            puts("簡単にファイルに保存することができますね");
            puts("ファイルを上書きや新規作成でなく");
            puts("ファイルに追記したければ");
            puts("ファイルモードをaで開けばいいだけです");
            puts("ちなみにこれまでやってきた");
            puts("ファイル操作をする関数は");
            puts("やや低レベルの操作が中心でした");
            puts("ですがC言語では");
            puts("さらに一括したファイル操作が可能な");
            puts("関数があります");
            puts("それと関係がある話なのですが");
            puts("printf()関数やscanf()関数は");
            puts("最初の方に触ってきたので");
            puts("もう十分触れる自信はありますよね？");
            puts("そんなfputs()関数などより慣れ親しんだ");
            puts("関数で出力や入力をしたくないですか？");
            puts("そこで出てくるのがprintf()関数とscanf関数の");
            puts("ストリーム版です");
            puts("その関数の名は");
            puts("fprintf()関数とfscanf関数です");
            puts("ってことでfprintf()の使い方について軽く教えますね");
            puts("");
            puts("int fprintf(FILE *ストリーム,const char *フォーマット,…);");
            puts("");
            puts("って感じです");
            puts("fprintf()は第一引数に有効なストリームを指定します");
            puts("第二引数以降はprintfと同じように使えます");
            puts("標準出力の代わりにデータを");
            puts("ストリームに書き出す関数です");
            puts("この流れで行くとfscanf()もわかると思いますが");
            puts("説明します");
            puts("");
            puts("int fscanf(FILE *ストリーム,const *フォーマット,…);");
            puts("");
            puts("です");
            puts("これもただ第一引数に有効なストリームを入れるだけです");
            puts("ちなみにこちらはfprintf()が標準出力に対して");
            puts("fscanf()は読み込み出す関数です");
            puts("この二つの関数を使うことで");
            puts("これまでコンソールで行ってきた処理と同じ感覚で");
            puts("ファイル操作を行うことができます");
            puts("それと");
            puts("fscanf()関数は");
            puts("エラーが発生するか");
            puts("最初の変換の前にファイルストリームの");
            puts("終端を検出するとEOFを返します");
            puts("scanf()関数と同様スペースや改行を発見するとそこで");
            puts("読み込みを止めてしまいます");
            puts("次にfprintf()関数の説明ですが");
            puts("fprintf()関数はストリームにデータを出力します");
            puts("それだけです");
            puts("ちなみに");
            puts("fprintf()やfscanf()関数で");
            puts("ストリーム標準出力に変えることによって");
            puts("printf()やscanf()関数と同様の使い方ができます");
            puts("つまりfprintf()やscnaf()の対象がストリームに");
            puts("なっただけの関数です");
            puts("結論を言いますと");
            puts("ファイル操作時に");
            puts("どの関数が最も効果的か判断してください");
            break;
        }
        case 44://#44 ファイルサイズを得る
        {
            puts("#44 ファイルサイズを得る");
            puts("今回は時々思いません？");
            puts("宣言した変数のサイズが知りたいな...と");
            puts("まぁそんなことたまにしかないと思うんですけどもｗ");
            puts("今回それを解決するための関数をお教えします");
            puts("ちなみにこんなこと言っているけど");
            puts("ANSI C標準では正確なサイズは定義されていないのだとか");
            puts("なので使ってるコンパイラとかで");
            puts("どれだけのビット数があるのか気になったときとか\"にも\"");
            puts("使えます");
            puts("それでコンパイラなどで環境が変われば");
            puts("ビット数が変わるといいましたが");
            puts("ビット数が変わればソースを書き直さなければなりません");
            puts("だけど全部書き換えは面倒じゃない？");
            puts("そこで最初に言った");
            puts("データサイズ行ってしまえば変数のビット数を");
            puts("プログラム内で調べることのできる");
            puts("");
            puts("sizeof演算子");
            puts("");
            puts("なるものがあります");
            puts("使い方ですがこんな感じです");
            puts("");
            puts("sizeof(型);");
            puts("sizeof 変数名;");
            puts("");
            puts("こんな感じで指定された形や");
            puts("変数のデータサイズを返します");
            puts("サイズはバイト単位で返されます");
            puts("この演算子は前回で完結したと思われる");
            puts("ファイル操作などで活用できるらしいです");
            puts("ってことでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        int i;");
            puts("        printf(\"int = %%d : i = %%d\\ndouble = %%d\" ,");
            puts("                sizeof(int) , sizeof i , sizeof(double));");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("出力結果");
            puts("");
            puts("int = 4 : i = 4");
            puts("double = 8");
            puts("");
            puts("この数値はちょっと前にも説明した通り");
            puts("環境によって変わるかもしれないので");
            puts("参考程度に見といてください");
            puts("ちなみに軽く説明ですが");
            puts("これはバイト数を表しているので");
            puts("int型が4バイトつまりint型のiも4バイトの");
            puts("領域を確保しています");
            puts("double型は8バイトの領域を");
            puts("持っていることがわかりますね");
            puts("まぁこんな感じでデータサイズを吐かれます");
            puts("ちなみになぜsizeofが演算子として扱われているかわかります？");
            puts("まぁ演算子って文字を見ればわかると思いますが");
            puts("数式でも真偽を扱うものでも");
            puts("使えます");
            puts("つまり");
            puts("sizeofで求めたバイト数にほかの数を加算して");
            puts("出力することも出きます");
            puts("ちなみにこれはバイト数が増えるとか");
            puts("っていう効果はないです");
            puts("それと変数のサイズを求められるということは");
            puts("一応変数(?)である構造体のサイズも得ることができます");
            puts("これがあるとかなり便利ですよね");
            puts("だってchar型が何バイトだから...");
            puts("って数えるより楽ですからｗ");
            puts("しかも一部のコンパイラの実装依存で");
            puts("サイズが変更することがあるからｗ");
            puts("それでここまで話したので");
            puts("構造体のサイズを得る方法を教えます");
            puts("それはいたって簡単");
            puts("こんな感じにするだけです");
            puts("");
            puts("sizeof(struct タグ名);");
            puts("");
            puts("ついに構造体にタグ名が使われましたねｗｗ");
            puts("それで説明ですが");
            puts("sizeofで構造体のサイズを知るときは");
            puts("structとタグ名を絶対使います");
            puts("ていうかタグ名を指定する場合");
            puts("structが必ず必要ですw");
            puts("定義された構造体変数の場合は必要がないです");
            puts("ってことでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("struct TEST {");
            puts("        unsigned int bit:8 ;");
            puts("}obj;");
            puts("");
            puts("int main() {");
            puts("        printf(\"obj = %%d\\n\" , sizeof(obj));");
            puts("        printf(\"struct TEST = %%d\" , sizeof(struct TEST));");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("出力結果は");
            puts("");
            puts("obj = 4");
            puts("struct TEST = 4");
            puts("");
            puts("となります");
            puts("これはビットフィールドによって8ビットにしていますが");
            puts("int型のバイト数が返されています");
            puts("なぜそうなるのかを説明しますと");
            puts("ビットフィールドではあまり触れてなかったと思いますが");
            puts("int型には4バイト(32ビット)が割り当てられています");
            puts("その中の8バイトだけを有効にして");
            puts("残りを無効にしているという状態です");
            puts("しかしsizeofは有効なバイト数を数えるのではなく");
            puts("確保されているビット数を数えるので");
            puts("８ビットにしても");
            puts("結局確保されている領域である");
            puts("４バイトの値が返されたのです");
            puts("まぁ簡単に言うとビットフィールドを使っても元の");
            puts("バイト数が表示されるよってことです");
            puts("まぁこんな感じで何らかの目的で");
            puts("構造体フィールドのサイズを指定する場合");
            puts("sizeof演算子を使用して設定するようにしましょう");
            puts("ってことでsizeofへの理解を深めるために");
            puts("もう少し説明いたします");
            puts("まずsizeofu演算子は");
            puts("確保されている領域の量を表すものです");
            puts("簡単に言うとメモリサイズ");
            puts("それじゃあ使用されている領域の量がわかりませんよね？");
            puts("そこで出てくるのが");
            puts("sizeof_t演算子です");
            puts("こちらの演算子は");
            puts("使用されている領域の量を表すものです");
            puts("簡単に言うとサイズです");
            puts("なので変数のサイズを求めたいのか");
            puts("メモリサイズを求めたいのかを");
            puts("判断して使うように気を付けてください");
            puts("sizeofとsizeof_tは似てるようで違うものなので");
            break;
        }
        case 45://#45 凡用ポインタ
        {
            puts("#45 凡用ポインタ");
            puts("今回は凡用ポインタなるものについて");
            puts("教えていきます");
            puts("まずポインタには");
            puts("ポインタ型でのみ存在する凡用ポインタなるものが");
            puts("あるんですよね");
            puts("これを深堀していくと");
            puts("実は型名がvoid *型なのです");
            puts("*がついているのが通常の");
            puts("voidとは異なる点ですね");
            puts("ちなみにvoid型はポインタ型でのみ");
            puts("使用できるものらしいです");
            puts("ちなみに通常の変数にはvoid型は存在しません");
            puts("てか使えません");
            puts("とりあえずこののvoid型というのが");
            puts("どういうものなのかというと");
            puts("あらゆるポインタ型に変換できるポインタ型です");
            puts("つまり万能ですｗ");
            puts("それで多くはどのような方でも受け取れる関数を作るのに使用されます");
            puts("凡用ポインタを使用すれば");
            puts("charだろうとintだろうと");
            puts("ポインタ型であれば");
            puts("どれでも受け取れます");
            puts("逆にvoid型のポインタを参照するには");
            puts("必ずキャストする必要があります");
            puts("理由はcharやintをなんでも受け取れる都合上");
            puts("型が定まっていないからですね");
            puts("それでキャストはC言語の任意らしいのですが");
            puts("C++では必ず必要となる工程らしいので");
            puts("C++を触る予定がある人は");
            puts("少し頭の片隅に入れておくといいかと思います");
            puts("まぁ簡単ちょっと複雑な言い方になるのですが");
            puts("簡単に言うと");
            puts("void型ポインタはどのデータ型にも変換することができるのです");
            puts("まぁコードを書くとこうですね");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("void outString(void *);");
            puts("");
            puts("int main() {");
            puts("        int i = 65 ;");
            puts("        double d = 10.101;");
            puts("");
            puts("        outString(&i);");
            puts("        outString(&d);");
            puts("        outString(\"Kitty on your lap\");");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("void outString(void *text) {");
            puts("        char *str = (char *)text;");
            puts("        printf(\"%%s\\n\" , str);");
            puts("}");
            puts("");
            puts("実行結果は");
            puts("");
            puts("A");
            puts("ﾁﾊ｡Eｶ3$@彖?");
            puts("Kitty on your lap");
            puts("");
            puts("こうなり文字化けする可能性もあるし");
            puts("数字が文字になるかもしれないというのがわかりましたね");
            puts("なのでvoid型が必ずしも正しく出力するとは思はないほうがいいです");
            puts("まぁほかの型でもそうなのですが");
            puts("void *型に入れた型と同じ型にキャストすれば解決します");
            puts("なのでできるだけ同じ型にキャストすることをお勧めします");
            puts("ってことで説明はこれで以上です");
            break;
        }
        case 46://#46 バイナリデータ
        {
            puts("前回はファイルのサイズを得る方法をお教えしました");
            puts("そして今回はまたファイル操作に戻ります");
            puts("とりあえず以前といっても前の前ぐらいで");
            puts("基本操作について教えていきましたよね");
            puts("しかし前の前に教えてfprintf()やfscanf()関数は");
            puts("整数型には不向きです");
            puts("理由は");
            puts("fprintf()関数などは二進数のデータ(バイナリデータ)");
            puts("を文字データに変換するからです");
            puts("つまり数値データは文字データにされるということです");
            puts("それでここではバイナリデータ");
            puts("をファイルに入出力する方法についてやってみましょう");
            puts("バイナリデータと文字データの変換に対して");
            puts("通常は意識する必要はないのですが");
            puts("変換作業がアプリケーションの");
            puts("実行速度に深刻な問題を起こす場合など");
            puts("直接バイナリデータを扱う必要が出てくるケースも");
            puts("あるそうです");
            puts("ってことでコードをどうぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("#include <stdlib.h>");
            puts("");
            puts("int main() {");
            puts("        int i;");
            puts("        FILE *fp;");
            puts("        printf(\"値を入力してください\");");
            puts("        scanf(\"%%d\" , &i);");
            puts("");
            puts("        if ((fp = fopen(\"test.txt\" , \"w\")) == NULL) {");
            puts("                fprintf(stderr , \"ファイル操作中にエラーが発生\");");
            puts("                exit(1);");
            puts("        }");
            puts("");
            puts("        fprintf(fp , \"%%d\" , i);");
            puts("        fclose(fp);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("これはそのままファイルに入力した数字を入れるやつです");
            puts("この場合バイナリではなくiの数値がASCIIコードに");
            puts("変換されて出力されます");
            puts("ちなみにASCIIコードとは文字を数字で表したものみたいなやつ");
            puts("それで65なら\"65\"と同じ意味なるということです");
            puts("もちろんそれが目的ならば問題ないのですが");
            puts("算術用として一時保存する場合は困ります");
            puts("それの解決策が");
            puts("fpirntf()やfscanf()を使うのも一つですが");
            puts("バイナリデータ専用としてより適した関数が用意されています");
            puts("それがfwrite()関数です");
            puts("使い方はこんな感じ");
            puts("");
            puts("size_t fwrite(void *バッファ ,size_t サイズ ,size_t カウント ,FILE *ストリーム);");
            puts("");
            puts("この関数はバッファ(一時的な数値の保管場所)から");
            puts("サイズ分のデータをカウント数ぶん繰り返し");
            puts("ストリームに出力します");
            puts("戻り値は実際に書き込んだ回数を返します");
            puts("void *型やsize_t型についてすでに説明しているので");
            puts("コードを書いても大丈夫ですよね");
            puts("");
            puts("#include <stdio.h>");
            puts("#include <stdlib.h>");
            puts("");
            puts("int main() {");
            puts("        char i[] = { 65 , 66 , 67 , 68 , 69 , 70 };");
            puts("");
            puts("        fwrite(&i , sizeof(char) , 6 , stdout);");
            puts("        printf(\"\\n\");");
            puts("        fwrite(&i , sizeof(char)+1 , 3 ,stdout);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("出力結果");
            puts("");
            puts("ABCDEF");
            puts("ABCDEF");
            puts("");
            puts("このプログラムでは、fwrite()を使って配列のバイナリデータを");
            puts("標準出力に出力しています");
            puts("なぜこうなったかというと");
            puts("ちょっと前にもお話したASCIIコード上だと");
            puts("64の番号にAが割り当てられているので");
            puts("ここではAが出力されたことになります");
            puts("つまりデータがバイナリデータで扱われたことになるのです");
            puts("さっきのコードではfwrite()関数を２回使っていますが");
            puts("表示されている文字が同じなので同じことをしている");
            puts("ということになります");
            puts("まぁ細かく言うと");
            puts("上のfwrite()は配列の内容を一つずつASCIIコードに");
            puts("あてはめて六回出力しています");
            puts("下のfwrite()は配列の内容を二つずつASCIIコードに");
            puts("あてはめて三回出力しています");
            puts("結果的には出力された数は変わりません");
            puts("しかしchar型の変数 i をint型に変えたら同じ結果は");
            puts("得られないらしいです");
            puts("理由はバイナリデータでは上位ビットが無視されないらしいので");
            puts("6バイトまでの出力ならi[0]とi[1]の途中(上位に2バイト)までしか");
            puts("出力されません(int型が4バイトの場合)");
            puts("次にバイナリデータを出力できるということは");
            puts("その逆である読み込みも当然できます");
            puts("ってことでバイナリデータの読み込み");
            puts("方法をお教えします");
            puts("まぁバイナリデータの出力がfwriteだったから");
            puts("サッシのいい人は気づいてるかもしれないけど");
            puts("読み込みは");
            puts("freadです");
            puts("はい読み込みということでreadですw");
            puts("ちなみにこんな感じの使い方です");
            puts("");
            puts("size_t fread(void *バッファ ,size_t サイズ ,size_t カウント ,FILE *ストリーム);");
            puts("");
            puts("引数や戻り値の内容はfwrite()と全く同じです");
            puts("それでこのfread()関数は");
            puts("ストリームからサイズ分を");
            puts("カウント回数回繰り返し");
            puts("バッファまぁ変数ですね");
            puts("その変数に読み込みます");
            puts("そして読み込んだ文字を出力するにはprintfとかで");
            puts("変数を指定してやると出力できます");
            puts("ってことでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("#include <stdlib.h>");
            puts("");
            puts("int main() {");
            puts("	int i[] = { 100 , 200 , 300 } , re[3];");
            puts("	FILE *fp;");
            puts("");
            puts("	if ((fp = fopen(\"test.txt\" , \"w\")) == NULL) {");
            puts("		printf(\"ファイル操作中にエラーが発生\");");
            puts("		exit(1);");
            puts("	}");
            puts("");
            puts("	fwrite(i , sizeof(int) , 3 , fp);");
            puts("	fclose(fp);");
            puts("");
            puts("	if ((fp = fopen(\"test.txt\" , \"r\")) == NULL) {");
            puts("		printf(\"ファイル操作中にエラーが発生\");");
            puts("		exit(1);");
            puts("	}");
            puts("");
            puts("	fread(re , sizeof(int) , 3 , fp);");
            puts("	fclose(fp);	");
            puts("");
            puts("	printf(\"%%d\" , re[0] + re[1] + re[2]);");
            puts("	return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("600");
            puts("");
            puts("これは大体わかりますかね");
            puts("まぁ説明をしていきます");
            puts("これはまずint型配列iに100,200,300の値が入れられました");
            puts("そして同じくint型配列reが作られました");
            puts("そのあとtest.txtというファイルを作りそこの中に");
            puts("100 200 300 をASCIIコードに変換した");
            puts("文字(一応文字ではなくバイナリデータらしい)を入れて");
            puts("そのあとにそのファイルから");
            puts("その文字を読み取り");
            puts("またASCIIコードで数字に変換した");
            puts("というわけです");
            puts("それでなぜfwriteがASCIIコードじゃないかというと");
            puts("fwriteの処理で");
            puts("数字が二進数にされ");
            puts("それが人間の読める形にした");
            puts("まぁASCIIコードに変換したら");
            puts("変な文字列になったって感じです");
            puts("たぶん");
            puts("とりあえずこのプログラムで確認したように");
            puts("アプリケーションの設定のデータなど");
            puts("読み込んで直接計算式に使用したりするデータなどは");
            puts("バイナリデータとして扱えます");
            puts("とくに今回紹介した関数は配列として扱うのに非常に優れています");
            puts("実用化するには");
            puts("戻り値を監視するなどして");
            puts("エラー対策もするのが一般的らしいです");
            puts("ってことでねバイナリデータはこんな感じでした");
            puts("ってことで最後に軽くまとめますね");
            puts("fwrite()は書籍化せずにストリームにデータを書き込む");
            puts("fread()は書籍化せずにストリームからデータを読み込む");
            puts("そして戻り値はどちらも同じく");
            puts("実際に書き込んだ項目数を返します");
            puts("エラーの場合はcount未満");
            puts("ってことで乙です");
            break;
        }
        case 47://#47 ランダムアクセス
        {
            puts("#47 ランダムアクセス");
            puts("今までファイルの読み取りは");
            puts("ファイルの先頭の文字から");
            puts("どんどん最後にひとつづつ近づいていく");
            puts("みたいな感じで行われていました");
            puts("これを繰り返し出力してきましたが");
            puts("このようなファイルの先頭から");
            puts("ひとつづつ読み取り最後に向かっていくような");
            puts("ファイル形式をシーケンシャルアクセス");
            puts("と呼びます");
            puts("単なるテキストファイルから");
            puts("文字を読み取る場合は");
            puts("これ以上に効率的な方法はないと");
            puts("思われます");
            puts("手間もかからず理想的な読み取り方でしょう");
            puts("しかしバイナリデータの場合は適しているとは思えません");
            puts("バイナリファイルの場合、その使用から");
            puts("多くの異なる目的を持ったデータが");
            puts("バイトごとまぁ簡単に言うと部屋ごとに");
            puts("並んでいることが多いでしょう");
            puts("このデータをちまちま読み取りアクセスして");
            puts("目的のデータだけを読み取るのは大変時間がかかります");
            puts("そこでバイナリファイルの場合任意の場所から");
            puts("アクセスできると便利だと思いません？");
            puts("このような特定の場所にアクセスできるようにする関数が");
            puts("fseek()関数という関数です");
            puts("ちなみに特定の場所のファイルにアクセスすることを");
            puts("ランダムアクセスといいます");
            puts("それでfseek()関数は");
            puts("");
            puts("int fseeek(FILE *ストリーム,long オフセット,int 初期位置);");
            puts("");
            puts("ストリームはstdoutとかの標準出力");
            puts("などではなく");
            puts("有効なFILE構造体を指定する必要があります");
            puts("そして初期位置には定義済みの定数を指定します");
            puts("その定数というものがこちらです");
            puts("");
            puts("・SEEK_CUR:現在のファイルポインタの位置");
            puts("・SEEK_SET:ファイルの先頭");
            puts("・SEEK_END:ファイルの終端");
            puts("");
            puts("の三つです");
            puts("それでオフセットは指定した位置からのバイト数を指定します");
            puts("ファイルポインタは初期位置からオフセットで指定した部分へ移動します");
            puts("戻り値は成功すれば0、それ以外は0以外を返します");
            puts("ランダムアクセスを制御するには");
            puts("プログラムによって");
            puts("現在のファイルポインタの位置を取得する必要があるかもしれません");
            puts("現在のファイルポインタの位置を取得するにはftell()関数を使用します");
            puts("書き方はこんな感じ");
            puts("");
            puts("long ftell(FILE *ストリーム);");
            puts("");
            puts("この関数は指定されたストリームのファイルポインタを返します");
            puts("次のこのプログラムを実行して");
            puts("ファイルポインタが移動しているか確認してみましょう");
            puts("");
            puts("#include <stdio.h>");
            puts("#include <stdlib.h>");
            puts("");
            puts("int main() {");
            puts("	char fileName[128];");
            puts("	int fileIndex , text;");
            puts("	FILE *fp;");
            puts("");
            puts("	printf(\"読み込むファイル名を指定してください>\");");
            puts("	scanf(\"%%s\" , fileName);");
            puts("	printf(\"ファイルを読み出す開始位置をバイト単位で指定してください>\");");
            puts("	scanf(\"%%d\" , &fileIndex);");
            puts("");
            puts("	if ((fp = fopen(fileName , \"r\")) == NULL) {");
            puts("		fprintf(stderr , \"ファイル操作でエラーが発生\");");
            puts("		exit(1);");
            puts("	}");
            puts("");
            puts("	fseek(fp , fileIndex , SEEK_SET);");
            puts("	printf(\"///ファイル位置 %d から読み出します///\\n\" , ftell(fp));");
            puts("");
            puts("	while(1) {");
            puts("		text = fgetc(fp);");
            puts("		if (!feof(fp)) printf(\"%%c\" , text);");
            puts("		else break;");
            puts("	}");
            puts("	fclose(fp);");
            puts("	return 0;");
            puts("}");
            puts("");
            puts("実行していただければわかりますが");
            puts("指定したバイト数移動したところから読み込みましたよね");
            puts("それで次ですがランダムアクセスを利用すれば");
            puts("効率的に一つのファイルのバイナリデータにアクセスできます");
            puts("実用的なアプリケーションになるとバイナリデータは");
            puts("設定の保存などで使用することになるでしょう");
            puts("この時設定数だけファイルを作るのでは");
            puts("とても非合理的なストリームになります");
            puts("ランダムアクセスを利用して一つのファイルに対して");
            puts("様々なデータを保存したいですよね");
            puts("ってことで次なのですが");
            puts("先にコードをどうぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("#include <stdlib.h>");
            puts("");
            puts("int main() {");
            puts("        int i[] = { 100 , 200 , 300 };");
            puts("        FILE *fp;");
            puts("");
            puts("        if ((fp = fopen(\"test.txt\" , \"wb\")) == NULL) {");
            puts("                fprintf(stderr , \"ファイル操作でエラーが発生\");");
            puts("                exit(1);");
            puts("        }");
            puts("");
            puts("        fseek(fp , 1024 , SEEK_SET);");
            puts("");
            puts("        fwrite(i , 4 , 3 , fp);");
            puts("        fclose(fp);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("ってことで");
            puts("これはファイルの先頭から１キロバイト先にデータを書き込んで");
            puts("それをfopen()関数によって開いて読み込もうとしているのですが");
            puts("fopen()のモードには");
            puts("ファイル追加または破壊");
            puts("ファイル読み込み");
            puts("ファイルに追記");
            puts("しかないです");
            puts("そして読み込もうとしてるのはバイナリデータです");
            puts("テキストではありません");
            puts("なので今から開くファイルが");
            puts("バイナリデータであることを明示しないといけません");
            puts("そこで出てくるのが\"wb\"です");
            puts("これをすることでfopen()に");
            puts("今から開くのがバイナリデータであることを");
            puts("知らせることができます");
            puts("そして上のプログラムを実行すると");
            puts("同じファイル内にtest.txtというファイルが作成されますが");
            puts("中は１キロバイト先までずっと空白です");
            puts("しかも１キロバイト先まで行っても");
            puts("意味の分からない文字があるだけです");
            puts("そしてランダムアクセス専用のファイルは");
            puts("ランダムアクセスという目的である以上");
            puts("読み始める場所を指定しなくてはいけません");
            puts("そのため書き込まれるデータが詳しく決まってない場合は適しません");
            puts("簡単に言うと");
            puts("読み込まれるデータの長さや桁数、文字数が決まっていない場合");
            puts("ランダムアクセスは向いていないということです");
            puts("まぁ今回はランダムアクセスについて話していきました");
            puts("設定を残しておけるのは便利ですが");
            puts("データがある程度決まっていないと");
            puts("うまく使えないのがちょっと傷ですね");
            
        }
        case 48://#48 記憶クラス
        {
            puts("#48 記憶クラス");
            puts("前回はランダムアクセスに話してきました");
            puts("そして今回は記憶クラスというものが４つあるので話していきます");
            puts("まぁクラスといっても");
            puts("オブジェクト指向のクラスとは違うんですけどねｗ");
            puts("");
            puts("");
            puts("そして一つ目の説明なのですが");
            puts("C言語では変数の保存先をさらに細かく指定できます");
            puts("この変数の保存方法の詳細を保存するのが記憶クラス指定子です");
            puts("さっきも言った通りオブジェクト指向でない");
            puts("C言語ではクラスという言葉は");
            puts("意味のないキーワードですが");
            puts("自動変数である指定するauto指定子が存在します");
            puts("ちなみに自動変数とはローカル変数のことであり");
            puts("C言語では指定する必要はありません");
            puts("この指定市は過去の言語の互換性のために残されています");
            puts("過去の言語とはC言語のもととなったB言語のことです");
            puts("詳しくはググってください");
            puts("でその互換性のあるauto指定子は");
            puts("こう使われてたらしいです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("char str;");
            puts("");
            puts("int main() {");
            puts("        auto char str[] = \"Kitty on your lap\";");
            puts("        printf(str);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("まぁ今ではもう使われなくなってしまった指定子ですね");
            puts("");
            puts("");
            puts("そして二つ目の説明です");
            puts("これまでのサンプルコード");
            puts("いわゆる私が例で載せていたコードたちです");
            puts("そのコードたちは単一のファイルでコンパイルしてきたはずです");
            puts("しかし実用的なアプリケーションの場合はどうでしょうか");
            puts("内容が複雑になればなるほど当然ソースは長くなります");
            puts("その場合当然プログラムを分けて開発します");
            puts("共同開発の場合はなおさらわけるでしょう");
            puts("この時の問題がグローバル変数の扱い方です");
            puts("とりあえずここでコードです");
            puts("");
            puts("/*-----test1.c-----*/");
            puts("#include <stdio.h>");
            puts("");
            puts("char *str;");
            puts("void outString(void);");
            puts("");
            puts("int main() {");
            puts("        str = \"Kitty on your lap\\n\";");
            puts("        printf(str);");
            puts("        outString();");
            puts("");
            puts("         return 0;");
            puts("}");
            puts("");
            puts("/*-----test2.c-----*/");
            puts("#include<stdio.h>");
            puts("");
            puts("void outString() {");
            puts("        printf(str);");
            puts("}");
            puts("");
            puts("この二つのプログラムをコンパイルしてみましょう");
            puts("複数のファイルをコンパイルする方法は");
            puts("開発環境のヘルプを見て探してください");
            puts("私はVScodeでやっているので");
            puts("Kitty on your lap");
            puts("Kitty on your lap");
            puts("と出力されましたが");
            puts("ほかの環境では");
            puts("未定義のシンボル str(関数 outString )");
            puts("と出るようです");
            puts("この時何が起きているかというと");
            puts("test2.cの方では変数strが認識されていません");
            puts("そしてグローバル変数でもファイル感は認識されないらしいです");
            puts("それを解決するために");
            puts("auto指定子とは別にextern指定子という記憶クラス指定子");
            puts("というものがあります");
            puts("これは明示的に変数が別の場所");
            puts("ここでは別の実行ファイルですでに宣言されていることを表します");
            puts("この指定子はコンパイラに変数の位置を教えるだけで");
            puts("新しいメモリ領域を割り当てません");
            puts("それで先ほどのコードを書き換えると");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("char *str;");
            puts("void outString(void);");
            puts("");
            puts("int main() {");
            puts("        str = \"Kitty on your lap\\n\";");
            puts("        printf(str);");
            puts("        outString();");
            puts("");
            puts("         return 0;");
            puts("}");
            puts("/*---------------------------------------*/");
            puts("#include<stdio.h>");
            puts("");
            puts("extern char *str;");
            puts("");
            puts("void outString() {");
            puts("        printf(str);");
            puts("}");
            puts("");
            puts("これで二つのファイルでグローバル変数である");
            puts("strは同じアドレスを指すようになりました");
            puts("一つのプロジェクトで複数のファイルに分割する場合");
            puts("このようにグローバル変数の値に注意する必要があります");
            puts("もちろんですが同一ファイルでも関数内の変数で");
            puts("グローバル変数を明示的に表すのに");
            puts("extern指定子を使ってグローバル変数の参照を持つ");
            puts("変数も宣言することができますが");
            puts("ローカル変数で宣言されていない変数は");
            puts("自動的にグローバル変数を参照しようとするので");
            puts("そのような意味でextern指定子が使われることがはありません");
            puts("");
            puts("");
            puts("そして３つ目です");
            puts("C言語ではCPUのレジスタ(CPUの中ある高速記憶装置)を使用してアクセス速度の向上を");
            puts("図ることができます");
            puts("これはとても高度な技術でバイアによってはアプリケーションの実行速度を");
            puts("大幅に向上させることができます");
            puts("CPUがダイレクトに操作、参照できるレジスタは高速ですが");
            puts("領域は小さく限りがあります");
            puts("そのため必ずレジスタを使えば早くなるとは限りません");
            puts("それで値をレジスタに保存することができるのですが");
            puts("保存するためにはregister指定子を使います");
            puts("何度も言いますがレジスタには限りがあるので");
            puts("範囲を超えるとコンパイラが自動的に");
            puts("普通の変数に変更するので");
            puts("レジスタに入れるのは極力少なめに");
            puts("それでレジスタはどのぐらい変数を");
            puts("入れるのが最適かといわれると");
            puts("１つの関数で２つ程度の変数を保存するのが");
            puts("最適とされています");
            puts("まぁ意味はないプログラムですが");
            puts("書きますねｗ");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        register int i , d = 10000;");
            puts("");
            puts("        for (i = 0 ; i < 10000 ; i++) {");
            puts("                printf(\"i = %%d : d = %%d\\n\" , i , d);");
            puts("                d--;");
            puts("        }");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("まぁプログラムが小さのでこんなのでは");
            puts("速さの違いなんてあまり出ません");
            puts("");
            puts("");
            puts("最後４つ目です");
            puts("まず通常のローカル変数は関数が呼び出されるたびに");
            puts("初期化されていました");
            puts("つまりあれですねローカル変数は使い捨て変数だったということです");
            puts("まぁ自作関数らへんで気づいてた人もいたんじゃないかな");
            puts("それでローカル変数は切り捨てられるため");
            puts("自作関数に渡すときはポインタ型を使っていましたが");
            puts("今回はポインタがじゃなくても渡せる指定子があります");
            puts("まぁ関数が終了しても消えない変数ってだけなんですがｗ");
            puts("まぁ説明ですが");
            puts("例えば関数内でループさせほかの関数で処理をするということになった時");
            puts("どこでも渡せるグローバル変数では");
            puts("ほかの場所に影響が出るため");
            puts("ローカル変数を使いたいが");
            puts("自作関数で処理をしている");
            puts("ためローカル変数は渡せない！");
            puts("ってなるじゃないですか？");
            puts("ポインタ型は別ですが");
            puts("その時に出てくるのがstatic指定子です");
            puts("これは変数の作成時のみ初期化します");
            puts("それ以降この変数は");
            puts("関数が終了しても廃棄されることはありません");
            puts("また呼び出しをしても初期化はされません");
            puts("ってことでこのコードを見てください");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("void func(void);");
            puts("");
            puts("int main() {");
            puts("        int count;");
            puts("");
            puts("        for (count = 0 ; count < 1000 ; count++) func();");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("void func() {");
            puts("        static int count = 1;");
            puts("        printf(\"%%d\\n\" , count);");
            puts("        count++;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("1");
            puts("2");
            puts("3");
            puts("4");
            puts("...");
            puts("1000");
            puts("");
            puts("となります");
            puts("まぁ見ればわかりますが");
            puts("これは1000回ループさせるものです");
            puts("しかし実行結果を見るにポインタで渡していないのに");
            puts("count変数が増えているのがわかりますね");
            puts("static指定子はこのように関数が終わっても消えません");
            puts("廃棄できないのです");
            puts("まぁグローバル変数と似てますが");
            puts("違うところが");
            puts("関数が終了しても消えない点大きな違いでしょうか");
            puts("まぁ関数が終了しても消えないところが");
            puts("メリットですがもしかしたら");
            puts("プログラムによっては");
            puts("デメリットになるかもしれないので");
            puts("関数が終了しても消滅させたくないっていうのがあるのであれば");
            puts("変数の作成でstatic指定子を用いてみてはどうでしょうか");
            puts("ちなみにstaticは自作関数内で指定することで効果があるようです");
            puts("");
            puts("ってことでこの４つの記憶クラスの");
            puts("説明は以上です");
            puts("お疲れさまでした");
            
        }
        case 49://#49 列挙型
        {
            puts("#49 列挙型");
            puts("前回は記憶クラスについて教えていきました");
            puts("そして今回は");
            puts("C言語の変数型で特殊な型である");
            puts("列挙型について教えておきます");
            puts("それで列挙型とは");
            puts("定数のリストを定義することができます");
            puts("列挙型を作成するにはenumキーワードを使います");
            puts("使い方はこんな感じです");
            puts("");
            puts("enum タグ名{定数リスト}変数;");
            puts("");
            puts("形的に気づいた人もいると思いますが");
            puts("これは構造体と同じ作り方をします");
            puts("まぁちょっと違うところは定数リストのところかな");
            puts("とりあえず構造体共用体をやってきた人なら");
            puts("やり方はわかると思います");
            puts("ってことでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("enum Kitty { MIMI , YUKI , RENA };");
            puts("");
            puts("int main() {");
            puts("        enum Kitty cats;");
            puts("");
            puts("        cats = MIMI;");
            puts("        printf(\"MIMI = %%d\\n\" ,cats);");
            puts("        cats = YUKI;");
            puts("        printf(\"YUKI = %%d\\n\" , cats);");
            puts("        cats = RENA;");
            puts("        printf(\"RENA = %%d\\n\" ,  cats);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("出力結果");
            puts("");
            puts("MIMI = 0");
            puts("YUKI = 1");
            puts("RENA = 2");
            puts("");
            puts("このプログラムはkittyという列挙型を定義しています");
            puts("列挙型の変数をmain()関数内で宣言し");
            puts("それぞれ定数の値を代入しています");
            puts("というか気づいたでしょうか");
            puts("列挙型に入れられた順番に0から割り当てられていることに");
            puts("つまり左から１ずつ加算した値になっていきます");
            puts("ちなみに代入される値を指定することもでき");
            puts("こんな感じで書きます");
            puts("");
            puts("enum Kitty {MIMI , YUKI = 5 , RENA};");
            puts("");
            puts("この場合");
            puts("MIMIが1");
            puts("YUKIが5");
            puts("RENAが6");
            puts("になります");
            puts("これで気づいたと思いますが");
            puts("指定した定数のあとの定数は");
            puts("指定した数から1プラスされた");
            puts("数になっています");
            puts("それで列挙型は左から順に");
            puts("1ずつ加算されていくといいましたが");
            puts("これをうまく使えば");
            puts("switchで選択しとして使えます");
            puts("ってことでこんな感じです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("enum Kitty { MIMI , YUKI = 5 , RENA } cats;");
            puts("");
            puts("int main() {");
            puts("        cats = RENA;");
            puts("");
            puts("        switch(cats) {");
            puts("        case MIMI:");
            puts("                printf(\"ミミ\");");
            puts("                break;");
            puts("        case YUKI:");
            puts("                printf(\"ユキ\");");
            puts("                break;");
            puts("        case RENA:");
            puts("                printf(\"レナ\");");
            puts("        }");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("レナ");
            puts("");
            puts("となります");
            puts("ちなみに");
            puts("");
            puts("enum TAG { AKARI } hiro;");
            puts("hiro = 10;");
            puts("int i = AKARI;");
            puts("");
            puts("列挙型に通常の数値を代入したら");
            puts("int型の変数にenumで定義した定数を代入します");
            puts("つまり定数が10だったら");
            puts("int型で宣言した変数に10が入ります");
            puts("そんな感じです");
            puts("まぁ上に軽く書いた使い方は");
            puts("エラーが発生しそうですが");
            puts("それは仕様上定義されておらず");
            puts("コンパイラ依存になります");
            puts("列挙型の局所性はコンパイラによって様々です");
            puts("列挙型の低数値がほかの型に");
            puts("代入できるかどうかなど");
            puts("使ってる環境で一度試してみてください");
            puts("それと");
            puts("enumで定義される定数は");
            puts("#defineと同質の定数となります");
            puts("なので定数などはメモリ領域を与えらないかつ");
            puts("定数なので置き換えられます");
            puts("ちなみにenumで定義された定数の");
            puts("割り当てられた数字を置き換えます");
            puts("ってことで説明は以上です");
            puts("乙です");
            break;            
        }
        case 50://#50 型修飾子
        {
            puts("#50 型修飾子");
            puts("前回は列挙型についてやっていきました");
            puts("今回は変数について軽く説明したいことがあるので");
            puts("それについて教えます");
            puts("まず変数を使っていて変わってしまうのがめんどくさい");
            puts("と思うときがあるかもしれません");
            puts("まぁ僕は思うことなんてなかったんですがw");
            puts("ってことで今回は一回値を入れたら");
            puts("変更ができない変数の作り方をお教えします");
            puts("それじゃあまず");
            puts("今回教えていくのは前に教えた");
            puts("定数に似ていますね");
            puts("そんでＣ言語では変数へのアクセス方法を");
            puts("指定する型修飾子というものがあります");
            puts("その中にconstという型修飾子");
            puts("というものがあります");
            puts("そしてconst型修飾子は");
            puts("最初に入れた値の変更を許さない変数を");
            puts("作ることができます");
            puts("定数と違うところはわかると思いますが説明します");
            puts("定数がメモリ領域を使用しない代わりに");
            puts("置き換える");
            puts("今回のconst型修飾子は");
            puts("メモリ領域を使用するということですね");
            puts("当然初期化時に与えられる値もプログラム内部で");
            puts("代入できます");
            puts("定数と違うのは");
            puts("プログラム内部で代入宣言ができるというところですかね");
            puts("ってことでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        const char str[] = \"Kitty on your lap\";");
            puts("        printf(str);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果は普通の変数と同じ扱い方をするので");
            puts("実行結果はわかりますね");
            puts("それじゃあ説明ですが");
            puts("constで指定された変数は初期値を与えると");
            puts("それ以降変更を許しません");
            puts("つまりプログラム内で変更をしようとすると");
            puts("エラーが起きます");
            puts("そしてconstは関数などで受け取った値を不用意に");
            puts("まぁ今回はこんなもんです");
            puts("変更をしないようにするのにもつかったりしますかね");
            
        }
        case 51://#51 ビット演算
        {
            puts("#51 ビット演算");
            puts("今回は条件式");
            puts("まぁifとかwhileとかの時に");
            puts("使った式について語ろうかと");
            puts("それで条件式を学習したときに");
            puts("真偽を論理演算で操作しましたが");
            puts("論理演算はビットごとの演算に");
            puts("使うことができます");
            puts("ビット演算はアルゴリズムや低レベルな");
            puts("処理には欠かせません");
            puts("またビットレベルの計算に強くなるためにも");
            puts("必要な知識です");
            puts("ビット演算には次の演算子が有効です");
            puts("");
            puts("& : ビットごとの理論積");
            puts("|  : ビットごとの論理和");
            puts("^ : ビットごとの排他的論理和");
            puts("~ : 1の補数");
            puts("");
            puts("ちなみに今回の内容については");
            puts("少しのビットの知識が必要かもしれません");
            puts("てか必要です");
            puts("");
            puts("");
            puts("それで説明していきますが");
            puts("論理積はそれぞれのオペランド(プログラム内での演算)の各ビットを比較し");
            puts("それぞれが1であれば1を");
            puts("そうでなければ0をという算術をします");
            puts("つまり 0011 & 1110");
            puts("としたら 0010");
            puts("となるということです");
            puts("コードで使えばこんな感じ");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        unsigned char i = 0xff;");
            puts("        printf(\"%%x\" , i & 0x0f);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("f");
            puts("");
            puts("論理積の演算では比較対象のビットが0であれば0に1であれば比較元(左辺)の値になります");
            puts("上のプログラムではiは16進数ffの値つまり10進数の255の値を持っています");
            puts("これに16進数0fの値を論理積で計算します");
            puts("つまりこういうこと");
            puts("");
            puts("1111 1111 & 0000 1111");
            puts("");
            puts("結果は上位ビットがすべて0になり下位4ビットはそのままになります");
            puts("この場合0000 1111となり結果(16進数のf)となります");
            puts("この性質を生かせばASCIIコードやゾーン10進数の知識さえあれば");
            puts("その変換プログラムを作成することもできるらしいです");
            puts("まぁ僕はASCIIコードとゾーン10進数の知識はないので");
            puts("ぼくには無理なのですがｗ");
            puts("それじゃあ次は文字データの5をバイナリデータの5に変換してみます");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        unsigned char i = '5';");
            puts("        printf(\"%%d\\n\" , i);");
            puts("        printf(\"%%d\" , i & 0x0f);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("53");
            puts("5");
            puts("");
            puts("となります");
            puts("ちなみに特定のビットが真か偽(0か1)か");
            puts("を調べるにも論理積が使われます");
            puts("");
            puts("");
            puts("論理和はビットの一方が1であれば1という算術をします");
            puts("例えばですがすべてが0のものと");
            puts("すべてが1のものを比較すると");
            puts("すべてが1になった値が返ってきます");
            puts("つまり");
            puts("1010 | 0101");
            puts("をしたら");
            puts("1111が返されるということです");
            puts("ってことでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        unsigned char i = 0x0f;");
            puts("        printf(\"%%d\" , i | 0xf0);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("255");
            puts("");
            puts("このコードを2進数で表すとこうなります");
            puts("");
            puts("0000 1111 & 1111 0000");
            puts("");
            puts("こうなりますこれは10進数の255になるので");
            puts("実行結果が255になるというわけです");
            puts("");
            puts("");
            puts("排他的論理和は");
            puts("一方が1の時だけ1という結果を出します");
            puts("比較したビットが同じであれば必ず0になります");
            puts("簡単に表すとこうですね");
            puts("1000 ^ 1011は");
            puts("0011になります");
            puts("特徴として");
            puts("同じ値を比較すると必ず結果は0になるということと");
            puts("一方の演算(オペランド)の各ビットが1の場合");
            puts("比較もとのビットが反転するということです");
            puts("ってことでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        unsigned char i = 0x7f;");
            puts("        printf(\"%%d\\n\" , i ^ 0xff);");
            puts("        printf(\"%%d\" , i ^ i);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("128");
            puts("0");
            puts("");
            puts("最初の演算では変数iのビットを反転しています");
            puts("16進数0x7fは2進数で0111 1111です");
            puts("これを2進数 1111 1111を排他的論理和で演算すると");
            puts("ビットが反転し1000 000という結果になり");
            puts("これは10進数は128になります");
            puts("実行結果が128になります");
            puts("そして i^i は同じものを排他的論理和で比較しています");
            puts("この時ビットはすべて同じなので");
            puts("すべて0になります");
            puts("つまり出力される値も0になるということです");
            puts("");
            puts("");
            puts("そして補数について教えます");
            puts("まず1の補数とはビット内容を反転させます");
            puts("つまり");
            puts("0を1に1を0にという感じです");
            puts("たとえです");
            puts("0101 1001を1の補数をすると");
            puts("1010 0110となるのです");
            puts("以前2進数による負数をを表現させるサインフラグ(あるビットが1なら負0なら正みたいなやつ)");
            puts("について少しだけ触れました");
            puts("これは2の補数と呼ばれるものです");
            puts("これは1の補数で出てきた2進数に1を加算した結果になるのです");
            puts("たとえですが");
            puts("0011 1111 を1の補数をしたら");
            puts("1100 0000を返しますこれに1を加算した");
            puts("1100 0001が2の補数です");
            puts("この1を加算数ものが2の補数です");
            puts("少し理解したところでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        printf(\"%%d\" , (~100) + 1);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("-100");
            puts("");
            puts("ちなみにビット演算は実際のプログラムで");
            puts("多用されるようなのでそれぞれの性質を");
            puts("覚えておくだけでも便利でしょう");
            puts("");
            puts("そして最後にビットシフトについて教えます");
            puts("ビットシフトとはビットを左または右に移動させる演算です");
            puts("ビットシフトには");
            puts("ビットシフト演算子を用いて行います");
            puts("");
            puts("値<<シフト数");
            puts("値>>シフト数");
            puts("");
            puts("<<はビットを左にシフト");
            puts(">>はビットを右にシフト");
            puts("");
            puts("値をいくつシフトするかはシフト数で指定できます");
            puts("シフトしたことでできた空白は0で埋められます");
            puts("(例)");
            puts("");
            puts("1111 1111 >>2");
            puts("これは右に2シフトですね");
            puts("ちなみにこうなるはずです");
            puts("0011 1111");
            puts("ちなみにこれの使いどころですが");
            puts("実は右にシフトするたびに2で除算した結果と同じになり");
            puts("左にシフトするのも同じく2で乗算した結果と同じです");
            puts("ってことでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        char i = 100;");
            puts("        printf(\"%%d\\n\" , i >> 2);");
            puts("        printf(\"%%d\" , i << 1);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("25");
            puts("200");
            puts("");
            puts("となります");
            puts("iを右に2シフトすると");
            puts("100を2で2回割ることと");
            puts("同じになり");
            puts("結果が25になるのです");
            puts("逆にiを左にシフトすると");
            puts("100を2で1回掛けるのと");
            puts("同じ結果になります");
            puts("ちなみに一般的なCPUは算術演算よりもシフト演算の方が");
            puts("処理が早いというメリットがあります");
            puts("まぁ通常のコンパイラでは最適化されるから変わらないらしいけどねｗｗ");
            puts("もちろんデータ型のサイズを超えるシフトをすると切り捨てられます");
            puts("またシフトすると演算(オペランド)が負の数の場合");
            puts("空白は0ではなく1で埋められます");
            puts("これによって負の数のシフトも意識することなく");
            puts("正数と同様に算術できます");
            puts("まぁ簡単に言うと負の数で乗算除算ができるということです");
            break;
        }
        case 52://#52 関数ポインタ
        {
            puts("#52 関数ポインタ");
            puts("今回は自作関数のポインタについて教えます");
            puts("それでまず");
            puts("コンパイラはコンパイル時に");
            puts("各関数にエントリーポイントなるものを作成します");
            puts("プログラムの実行時に関数が呼び出されると");
            puts("実行制御はこの");
            puts("エントリーポイントに移行します");
            puts("エントリポイントは言わば関数のアドレスみたいなもんです");
            puts("アドレスであるということは");
            puts("ポインタ変数を持つことができます");
            puts("関数ポインタはアドレスを格納する関数と");
            puts("同じ戻り値の方のポインタを用意します");
            puts("簡単に言うと自作関数の型と");
            puts("今回紹介する関数の型を同じにしないと");
            puts("使えないよということです");
            puts("仮引数がある場合はつづけて仮引数も指定します");
            puts("宣言時には優先順位の関係から");
            puts("必ずポインタ名に()を付けます");
            puts("こんな感じで書きます");
            puts("");
            puts("型(*変数名)(仮引数);");
            puts("");
            puts("関数のエントリポイントをポインタに格納すと");
            puts("ポインタから関数を呼び出せます");
            puts("こうすることで間接参照で関数の");
            puts("呼び出しをすることができるのです");
            puts("ってことでコードどうぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("void func(void);");
            puts("");
            puts("int main() {");
            puts("        void (*po)() = func;");
            puts("        po();");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("void func() {");
            puts("        printf(\"Kitty on your lap\");");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("Kitty on your lap");
            puts("");
            puts("となります");
            puts("これは*poにfunc関数のアドレス(エントリポイント)を渡しています");
            puts("そのとpo()でfunc関数を間接参照しているため");
            puts("func関数から実行したのではなく");
            puts("po()で実行している");
            puts("しかしpo()では通常の関数なのかポインタなのかわかりにくい");
            puts("プログラムになってしまいます");
            puts("そこで、多くのプログラマー違う書き方で");
            puts("間接参照であることを表す記述方法を用います");
            puts("それがこちらです");
            puts("");
            puts("(*po)();");
            puts("");
            puts("こうすれば一見しただけでポインタからの");
            puts("間接参照ということがわかりやすくなりましたね");
            puts("そして次は仮引数と戻り値を指定した");
            puts("関数の間接参照の例をどうぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int func(int , int);");
            puts("");
            puts("int main() {");
            puts("        int (*po)(int , int) , i;");
            puts("        po = func;");
            puts("");
            puts("        i = (*po)(10 , 3);");
            puts("        printf(\"%%d\" , i);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("int func(int i , int j) {");
            puts("        return i << j;");
            puts("}");
            puts("");
            puts("出力結果");
            puts("");
            puts("80");
            puts("");
            puts("これはまぁなんとなくどうしてこうあったかわかるはず");
            puts("これは上から説明していくと");
            puts("int型の関数ポインタと変数iを作っています");
            puts("そのあとに関数ポインタに関数のアドレスを代入して間接参照できるようにしています");
            puts("そのあと変数iにfunc関数に間接参照をしています");
            puts("その時関数に10と3を渡していますね");
            puts("それでfunc関数では10に2を3回掛けるということをしています");
            puts("つまり 20 40 80 と掛けられていきます");
            puts("それでfunc関数内の変数iが戻り値で80を返したことで");
            puts("main()関数内のiに80が入れられ");
            puts("80が出力されたということです");
            puts("説明するとこうなりますね");
            puts("ちなみにポインタ型にも配列がありましたよね？");
            puts("この関数ポインタを使えば");
            puts("関数を配列することもできます");
            puts("それで今までは関数には配列という要素はなかったのですが");
            puts("関数ポインタが来たことで配列ができるようになりました");
            puts("ちなみに関数配列というものはとても便利です");
            puts("説明していきますと");
            puts("プログラムの実行時に直接実行する関数を指定することが");
            puts("できるようになります");
            puts("しかもとても簡単に");
            puts("コードで見せるとこんな感じです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("void kitty(void);");
            puts("void sakura(void);");
            puts("void hina(void);");
            puts("");
            puts("int main() {");
            puts("	void (*po[])() = { kitty , sakura , hina };");
            puts("	int i;");
            puts("");
            puts("	printf(\"実行する関数の番号を指定してください 0〜2>\");");
            puts("	scanf(\"%%d\" , &i);");
            puts("	if ((i < 0) | (i > 2)) return 0;");
            puts("	(*po[i])();");
            puts("	return 0;");
            puts("}");
            puts("");
            puts("void kitty() {");
            puts("	printf(\"Kitty on your lap\\n\");");
            puts("}");
            puts("");
            puts("void sakura() {");
            puts("	printf(\"Card Captor SAKURA\");");
            puts("}");
            puts("");
            puts("void hina() {");
            puts("	printf(\"LOVE HINA\");");
            puts("}");
            puts("");
            puts("出力結果は岩はなくてもわかるかもしれませんが言いますと");
            puts("関数ポインタ配列で最初にkitty,sakuram,hinaという三つの文字列が配列されます");
            puts("そしてscanfのところでは関数ポインタの配列番号を聞いています");
            puts("それで入力された数字に対して実行する感じですね");
            puts("これは(*po)();であって少しわかりにくいと思うので");
            puts("軽く話していくと");
            puts("最初の説明通り関数を");
            puts("(*po)()=func;");
            puts("としたら間接的に");
            puts("func();と同義になっていることはわかりますよね");
            puts("それで配列をした場合");
            puts("(*po[])()={kitty,sakura,hina,};");
            puts("この場合");
            puts("(*po[1])();だとすると");
            puts("これは");
            puts("titty();ということになるのです");
            puts("(*po[2])();の場合は");
            puts("sakura();");
            puts("となります");
            puts("まぁ簡単に言うと配列の場所にある文字の関数が実行される的なことです");
            puts("ちなみにこのような関数ポインタ配列は");
            puts("独自の開発環境はマクロ用のインタプリンタの開発など");
            puts("低レベルなシステムプログラムでこの機能は活用されるようです");
            puts("まぁアイデア次第でこのプログラムは非常に強力で便利な機能になると思います");
            puts("ってことで関数ポインタの説明は以上です");
            puts("お疲れさまでした");
            break;
            
        }
        case 53://#53 動的メモリ
        {
            puts("#53 動的メモリ");
            puts("今回は動的メモリちゅうもんをやっていきます");
            puts("もうね動的メモリなんて専門的な用語出てきちゃって");
            puts("理解に苦しむ気しかしませんｗｗ");
            puts("それでまず通常の変数で割り当てられるメモリは静的なのです");
            puts("文字列を格納するのにも変数の宣言時にサイズを指定してきました");
            puts("いわば配列ですね");
            puts("しかしこれはハードウェアの性能をフルに生かすことができないらしいです");
            puts("文字型の配列を1,000バイト確保しても");
            puts("プログラム内では10バイトしか使わなければ");
            puts("990バイトの領域は無駄な領域になってしまいます");
            puts("当然逆にメモリの割り当てが少なければ");
            puts("コンパイルがうまくできず再びコンパイルする羽目になって");
            puts("時間がかかってしまいますよね");
            puts("そこで動的メモリというものが要求されてきます");
            puts("動的にメモリを割り当てるというのはプログラムの実行中に");
            puts("動的に確保する領域を変化させるということで");
            puts("簡単に言えば自動で適した領域を確保してくれるみたいに思っててくれていいです");
            puts("これができれば必要に応じたメモリを割り当てることができます");
            puts("そして肝心な動的メモリの割り当てには");
            puts("malloc()関数を使います");
            puts("この関数は指定したサイズの領域を確保して");
            puts("void型のポインタを返します");
            puts("使い方はこんな感じ");
            puts("");
            puts("void *malloc(size_t サイズ);");
            puts("");
            puts("これは割り当てるサイズをバイト単位で指定できます");
            puts("malloc()は、指定されたサイズの領域を確保したスペースへのポインタを返します");
            puts("つまり指定された分のサイズを確保してそのアドレスを返してくれるよってことです");
            puts("これにより効率のいいメモリ管理ができるわけです");
            puts("ただしこの関数は");
            puts("メモリが足りない場合NULLを返します");
            puts("ちなみにメモリに変数が入らなかったらいけないので");
            puts("malloc()はNULL(使用メモリがある)かどうかを");
            puts("調べてから使うのが一般的です");
            puts("まぁ当たり前ですねｗｗ");
            puts("それでコードを作るとこうです");
            puts("");
            puts("#include <stdio.h>");
            puts("#include <stdlib.h>");
            puts("#include <string.h>");
            puts("");
            puts("int main() {");
            puts("	char *po;");
            puts("	po = (char *)malloc(sizeof(char) * 128);");
            puts("	if (po == NULL) exit(1);");
            puts("");
            puts("	strcpy(po , \"Kitty on your lap\");");
            puts("	printf(\"%%s\" , po);");
            puts("	return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("kitty on your lap");
            puts("");
            puts("ってことで説明の前に補足ですが");
            puts("malloc(sizeof(char) * 128);という部分は");
            puts("char(1バイト) x 128としているので");
            puts("char型は1バイトしか確保しないのでmaloc(128);としても基本同じらしいです");
            puts("ただし各型で確保するメモリサイズは環境やプラットフォームごとに異なります");
            puts("そのため、どのような方であれC言語プログラマの多くはsizeof演算子を使って");
            puts("型のサイズを得てそれに割り当てるようにサイズを乗算する");
            puts("形をとることが多いようです");
            puts("さて通常は割り当てられたメモリはプログラム終了時に開放されますが");
            puts("当然長いプログラムなどではプログラマが状況によって任意に");
            puts("解放しなければならない場合もあるでしょう");
            puts("そうでないとしても最後には必ずメモリを開放しますよね");
            puts("その時に使う関数がfree()関数です");
            puts("使い方はこんな感じ");
            puts("");
            puts("void free(void *メモリ);");
            puts("");
            puts("メモリには割り当てたメモリブロックを使用します");
            puts("この時必ず有効なポインタ(mallocなどで割り当てたポインタ)を指定してください");
            puts("それではコードです");
            puts("");
            puts("<#include <stdio.h>");
            puts("#include <stdlib.h>");
            puts("#include <string.h>");
            puts("");
            puts("int main() {");
            puts("	char *po;");
            puts("	po = (char *)malloc(sizeof(char) * 128);");
            puts("	if (po == NULL) exit(1);");
            puts("");
            puts("	strcpy(po , \"Kitty on your lap\");");
            puts("	printf(\"%%s\" , po);");
            puts("	free(po);");
            puts("	return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("kitty on yor lap");
            puts("");
            puts("となります");
            puts("これでコンパイル時ではなくプログラムの状況によってメモリを割り当てることができます");
            puts("それとメモリの割り当てには");
            puts("ほかのもcalloc()関数というものがあります");
            puts("この関数は各要素のバイト数も同様に指定することもできます");
            puts("");
            puts("void *calloc(size_t 要素数,size_t 要素サイズ);");
            puts("");
            puts("要素数には割り当てるメモリブロックの要素数を指定します");
            puts("これはmallocと同じです");
            puts("要素サイズには、各要素のバイトサイズを指定することができます");
            puts("戻り値もmallocと同様に割り当てたスペースポインタです");
            puts("上のコードをcalloc()で書き直すとこうなります");
            puts("");
            puts("#include <stdio.h>");
            puts("#include <stdlib.h>");
            puts("#include <string.h>");
            puts("");
            puts("int main() {");
            puts("	char *po;");
            puts("	po = (char *)calloc(128 , sizeof(char));");
            puts("	if (po == NULL) exit(1);");
            puts("");
            puts("	strcpy(po , \"Kitty on your lap\");");
            puts("	printf(\"%%s\" , po);");
            puts("	free(po);");
            puts("	return 0;");
            puts("}");
            puts("");
            puts("実行結果はcallocに書き直しただけなので変化はありません");
            puts("ちなみにこの説明は説明を読みながら書いているので");
            puts("実行例とかを実行して気づいたことなのですが");
            puts("mallocやcallocで返される値をすべて");
            puts("アドレスに変換してるんですよね");
            puts("まぁポインタに格納してるんで当たり前ですが");
            puts("それと途中で出てきたstrcpy()関数について説明が");
            puts("されてなかったので説明しますと");
            puts("変数に変数または文字などをコピーする関数です");
            puts("使い方はたぶんこんな感じ");
            puts("");
            puts("strcpy(変数名A,変数名B);");
            puts("");
            puts("って感じで変数Aに変数Bの文字または値を入れることのできるもので");
            puts("変数Bのところには変数でなくても文字や数字を入れることができると");
            puts("思われます");
            puts("そしてこちらはstring.hというヘッダファイルにあるものですね");
            puts("ちなみに文字列を入れる場合配列やchar型と同じ領域を確保していないと");
            puts("いけないと思われます");
            puts("ってことで説明したいことももうないんで以上です");
            puts("お疲れさまでした");
            break;            
        }
        case 54://#54 新しい型名
        {
            puts("#54 新しい型名");
            puts("皆さんは宣言された既存の変数に新しい名前を");
            puts("つけたいとは思いませんか？");
            puts("Cライブラリで多く使われてるので");
            puts("知る必要があるので学んでいきましょう");
            puts("それで既存の変数の名前を変えたい！ってなった時には");
            puts("typedefキーワードを使用します");
            puts("自己説明的な型名を作成したり");
            puts("移植性の向上に使われるのが一般的です");
            puts("それで使い方です");
            puts("");
            puts("typedef 既存の型名 新しい型名;");
            puts("");
            puts("既存の型名には、もともと存在するC言語既存の型名を指定します");
            puts("そして、新しい型名がその方に着ける新しい型名です");
            puts("ちなみにtypedefで注意してほしいのが名前を変えるわけではなく");
            puts("別名を作成するだけということです");
            puts("例としてはMicrosoftのコンパイラのstdioヘッダファイルでは");
            puts("このような分があるようです");
            puts("");
            puts("typedef unsigned int size_t;");
            puts("");
            puts("size_tはわかっていますね");
            puts("まぁこれはsizeofとsize_tの関係性がわかれば");
            puts("typedefが何をやっているのかがわかると思います");
            puts("ってことでtypedefを使ったコードをどうぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("typedef const char final;");
            puts("typedef FILE stream;");
            puts("typedef signed int Integer;");
            puts("");
            puts("int main() {");
            puts("        final str[] = \"Kitty on your lap\";");
            puts("        stream *fp;");
            puts("        Integer i = 10;");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("これは実行しても何も出力されないのですが");
            puts("説明をしますとconst charと同じ効果を持ったfinal");
            puts("という関数が作られました");
            puts("それでfinalという関数を通して文字列が入れられました");
            puts("この時const charで変数strを宣言したのと同じ状態です");
            puts("これでなんとなくわかってきたと思うので");
            puts("typedefの魅力をほかにも話していきましょう");
            puts("高度なプログラマになればより複雑な型を");
            puts("typedefで指定することで");
            puts("独自のライブラリをより自己説明的に");
            puts("カプセル化できたりもします");
            puts("簡単に言うと");
            puts("好きなようにライブラリを作れるようになる");
            puts("みたいなことですね");
            puts("そして私たちはすでに高度なtypedefの恩恵を受けていて");
            puts("それがFILE構造体です");
            puts("コンパイラによって書き方は別らしいのですが");
            puts("");
            puts("typedef struct");
            puts("{");
            puts("        unsigned char  *curp;   \t/* Current active pointer           \t*/");
            puts("        unsigned char  *buffer; \t/* Data transfer buffer             \t*/");
            puts("        int             level;  \t/* fill/empty level of buffer       \t*/");
            puts("        int             bsize;  \t/* Buffer size                      \t*/");
            puts("        unsigned short  istemp; \t/* Temporary file indicator         \t*/");
            puts("        unsigned short  flags;  \t/* File status flags                \t*/");
            puts("        wchar_t         hold;   \t/* Ungetc char if no buffer         \t*/");
            puts("        char            fd;     \t/* File descriptor                  \t*/");
            puts("        unsigned char   token;  \t/* Used for validity checking       \t*/");
            puts("}       FILE;                              /* This is the FILE object \t*/");
            puts("");
            puts("これはBorland C++ Compiler 5.5のstdioヘッダファイルの一部らしいです");
            puts("FILE構造体型がtypedefによって定義されているのがわかりますね");
            puts("MicrosoftのVCも少し書き方が変わりますがほぼ同じように書かれているようです");
            puts("");
            puts("#include <stdio.h>");
            puts("#define true 1");
            puts("#define false 0");
            puts("");
            puts("typedef struct {");
            puts("        unsigned boolean: 1;");
            puts("} BOOL;");
            puts("");
            puts("int main() {");
            puts("        BOOL i;");
            puts("        i.boolean = true;");
            puts("        printf(\"%d\" , i.boolean);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("このように複雑なstructやenmuなどの方にtypedefを定義することもできます");
            puts("今回はこのぐらいで終わりです");
            puts("乙です");
            break;
        }
        case 55://#55 printf()関数
        {
            puts("#55 printf()関数");
            puts("今まで構造体やファイル操作などをしてきましたが");
            puts("最初に戻ってprintf()関数の説明をしたいと思います");
            puts("これまでデータの出力になんとなく用いてきたprintf()関数ですが");
            puts("printf()関数は文字列から数値まですべてを");
            puts("書式化して表現するという多機能な一面を持っています");
            puts("そして今回は基本的なprintf()関数の説明はさすがにしません");
            puts("今回説明するのはprintf()の知られざる秘密について説明しますｗ");
            puts("まずprintf(9関数には多くのフォーマット指定子が存在しますよね");
            puts("フォーマット演算子とは%%で始まるもの例えば");
            puts("%%dや%%sなんかが多用するでしょう");
            puts("しかし意外と使い慣れてないかもしれないので");
            puts("今一度フォーマット指定子の一覧を見てみましょう");
            puts("");
            puts("%%d または %%i: 符号付き10進整数");
            puts("%%u: 符号なし10進整数");
            puts("%%o: 符号なし8進整数");
            puts("%%x または %%X: 符号なし16進整数（小文字または大文字）");
            puts("%%f: 浮動小数点数");
            puts("%%e または %%E: 浮動小数点数（指数表記、小文字または大文字）");
            puts("%%g または %%G: 浮動小数点数（短い形式で表示、小文字または大文字）");
            puts("%%a または %%A: 浮動小数点数（16進指数表記、小文字または大文字）");
            puts("%%c: 文字");
            puts("%%s: 文字列");
            puts("%%p: ポインタ（アドレス）");
            puts("%%n: これまでの出力した文字数を格納するポインタ");
            puts("");
            puts("%%: パーセント記号自体を表示");
            puts("");
            puts("%%h: 短い整数（short型）");
            puts("%%hh: 非常に短い整数（char型）");
            puts("%%l: 長い整数（long型）");
            puts("%%ll: 非常に長い整数（long long型）");
            puts("%%j: intmax_t型（最大幅の整数型）");
            puts("%%z: size_t型");
            puts("%%t: ptrdiff_t型");
            puts("");
            puts("となります");
            puts("フォーマット指定子にはこれだけあるのですが");
            puts("さすがに%%sや%%dは問題ないでしょう");
            puts("そしてこの中で今回初めて使ったのは");
            puts("%%nと%%pです");
            puts("そして今回は");
            puts("その片方の%%nについて軽く話します");
            puts("一覧としてフォーマット指定子を書いたときに");
            puts("一緒に書いてあるのですが");
            puts("%%nはこの指定子までの文字列を格納するというものです");
            puts("%%nに対応する引数は必ず整数型へのポインタである必要があります");
            puts("とりあえず%%nだけのコードをどうぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("#define STR \"Kitty on your lap\"");
            puts("");
            puts("int main() {");
            puts("        int i , j;");
            puts("        printf(\"Kitty on your lap%%n\\n\" , &i);");
            puts("        printf(\"%%nKitty on your lap\\n\" , &j);");
            puts("");
            puts("        printf(\"i = %%d , j = %%d\" , i , j);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果は");
            puts("");
            puts("Kitty on your lap");
            puts("Kitty on your lap");
            puts("i = 17 , j = 0");
            puts("");
            puts("となるようです");
            puts("私の環境ではうまく動作しませんでしたｗ");
            puts("それで事細かく説明していくと");
            puts("まずint型のiとjが宣言されているのは見ればわかりますが");
            puts("そのあとのprintf()関数の内容が少し違いますね");
            puts("そこの違いというのが文字列のあとに%%nをつけるか");
            puts("文字列より前に%%nをつけるかの違いです");
            puts("まぁ%%nは文字列の最初から%%nまでの文字を");
            puts("アドレスとしてポインタに格納するといいましたが");
            puts("その違いですね");
            puts("最初のprintf()は最後に%%nをつけているので");
            puts("iにKitty on your lapのアドレスが格納されて");
            puts("jは最初に%%nを宣言しているため空白いわば0が");
            puts("格納されました");
            puts("その結果出力された数字が変わったということです");
            puts("そしてフォーマット指定子の");
            puts("文字、文字列、正数、浮動小数点などのデータにおいても");
            puts("たぶんもう大丈夫でしょう");
            puts("そしてさらにフォーマット指定子の数値データ引数の");
            puts("デフォルトサイズを指定することができます");
            puts("これはh,l,Lのいずれを指定することができます");
            puts("hはsyort intを(uの場合はshort unsigned int)");
            puts("lまたはLはlong intを(uの場合は long unsingned int)");
            puts("を表します");
            puts("ってことでコードを書くとこんな感じ〜");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        printf(\"%%ld\\n\" , 0x7fffffff);");
            puts("        printf(\"%%hd\\n\" , 0x7fffffff);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("出力結果は");
            puts("");
            puts("2147483647");
            puts("-1");
            puts("");
            puts("こうなったね");
            puts("ちなみにshortのhだけど");
            puts("Hでも普通に動くコンパイラもあるみたい");
            puts("まぁ環境依存なのでHではなくhで書くのが無難かもしれません");
            puts("");
            puts("そしてprintf()関数はフィールド指定や制度指定の指定子が存在するらしいです");
            puts("もうこれ何が言いたのかわかりませんが");
            puts("簡単に言いますと");
            puts("フォーマット指定子に必須フィールドに");
            puts("オプションをつけるみたいなことです");
            puts("printf()関数の書式指定フィールドはこのような書き方をするようです");
            puts("");
            puts("%%[フラグ] [最小フィールド] [.] [制度] [h|l|L]フォーマット指定子");
            puts("");
            puts("まず最小フィールド幅指定を説明します");
            puts("最小フィールド幅は負の数ではない10進数を指定し");
            puts("最小フィールドは表示する最小文字数を制限します");
            puts("ここで指定した数奉持する文字が短い場合");
            puts("デフォルトで右に詰められます");
            puts("ちなみにコードで書くとこんな感じ");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        printf(\"%%10d\\n\" , 10000);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("     10000");
            puts("");
            puts("こんな感じになる");
            puts("この時最小フィールドが10に指定されているため");
            puts("残りの5文字は空白として出力されます");
            puts("その結果5文字右詰めされた文字になります");
            puts("まぁ右詰めって言っていいのかわからんがｗ");
            puts("");
            puts("そして次に最初に指定するフラグですが");
            puts("なんかフラグディレクティブなるものを用いることで");
            puts("出力位置を調整することができるみたいです");
            puts("フラグディレクティブは１文字の記号で表します");
            puts("ちょっと前に説明した最小フィールドは指定場所は");
            puts("ディフォルトで右詰めでした");
            puts("そこでフラグディレクティブで-(マイナス)を指定すると");
            puts("右詰めだったものを左詰めにできます");
            puts("コードを書くとこんな感じ〜");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        printf(\"%%-10d%%d\\n\" , 10000 , 10);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("10000     10");
            puts("");
            puts("これを解説しますと");
            puts("%%-10dで10000を呼び出していて");
            puts("%%dで10を呼び出していますが");
            puts("空白が開いている理由は");
            puts("%%-10dで10マス分左詰めした場所に");
            puts("5文字分文字を入れたことで");
            puts("その5文字は左詰めされ残った5文字分は");
            puts("空白に置き換わったのです");
            puts("そこで10を持ってきたことで空白が開いたのです");
            puts("まぁ説明が下手ですが理解していただけていたら幸いです");
            puts("そしてさっきは-でやりましたが今度は+でやるとどうでしょう");
            puts("もとからデフォルトでしたよね");
            puts("だから+しても意味ないんじゃね？って思うかもしれませんが");
            puts("+を使うと数値の最初に+がついて表示されるようになります");
            puts("それとフラグディレクティブは組み合わせて使うことができます");
            puts("ってことでこれを踏まえてコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        printf(\"%%+-10d%%+d\\n\" , 10000 , 10);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("出力結果は");
            puts("");
            puts("+10000    +10");
            puts("");
            puts("となります");
            puts("このコードですが+と-を逆にしても出力されるものは変わりません");
            puts("そしてさらにフラグに0を指定すると最小幅まで0が追加されます");
            puts("ただしフラグに-が指定されていた場合-が優先される仕組みになっています");
            puts("またフラグで空白を指定すると");
            puts("出力地が符号付整数の時出力値の前に空白がつきます");
            puts("フラグで+が指定されている場合は無視されます");
            puts("ってことでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        printf(\"%%010d\\n\" , 10000);");
            puts("        printf(\"%%s%% d\" , \"ISO\" , 9000);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("0000010000");
            puts("ISO 9000");
            puts("");
            puts("これはまぁ理解できると思いますが説明しますと");
            puts("説明した通りフラグに0を入れることで空白が0に置き換えられます");
            puts("そしてフラグに空白を入れると空白が開きます");
            puts("ただそれだけですｗ");
            puts("それで最後のフラグディレクティブですが");
            puts("最後は#です");
            puts("これはフォーマット指定子がo,x,Xのいずれかの場合");
            puts("0以外ならば必ず0,0x,0Xをつけるものになります");
            puts("e,E,f,g,Gの場合は出力値に強制的に小数点を入れるらしいですw");
            puts("ってことでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        printf(\"%%#x\\n\" , 255);");
            puts("        printf(\"%%#e\\n\" , 0);");
            puts("        printf(\"%%#g\" , 0);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("0xff");
            puts("2.915270e-306");
            puts("2.91527e-306");
            puts("");
            puts("gの場合あとに続く0が切り捨てられましたが");
            puts("#フラグを指定した場合");
            puts("あとに続く0が切り捨てられることはありません");
            puts("");
            puts("そして最後に残ったのは制度指定ですね");
            puts("制度は最小フィールド指定のあとに小数点をつけて指定します");
            puts("制度はデータ型によってさまざまな意味を持ちます");
            puts("例えば、");
            puts("");
            puts("文字列であれば");
            puts("出力する最大文字数の指定となり");
            puts("指定数以上の文字数を出力することができなくなり");
            puts("あふれた分の文字は切り捨てられます");
            puts("");
            puts("正数であれば");
            puts("最小桁数の指定になります");
            puts("この場合最小桁数以上の桁でも切り捨てられることはありません");
            puts("最小桁数以下の場合は上位に0がつけられます");
            puts("");
            puts("浮動小数点の場合");
            puts("eやfであれば小数点以下の表示数の指定になります");
            puts("gまたはGであれば最小有効桁数の指定つまり全体の指定になります");
            puts("");
            puts("ってことでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        printf(\"%%5.3s\\n\" , \"Kitty\");");
            puts("        printf(\"%%5.3d\\n\" , 1);");
            puts("        printf(\"%%.3e\\n\" , 10.10);");
            puts("        printf(\"%%.3f\\n\" , 10.10);");
            puts("        printf(\"%%.3g\\n\" , 10.10);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("  Kit");
            puts("  001");
            puts("1.010e+01");
            puts("10.100");
            puts("10.1");
            puts("");
            puts("となります");
            puts("制度指定はc,Cは当然無効です");
            puts("なぜならずらせるものがないからですね");
            puts("%%%%や%%pなどにも意味がありません");
            puts("書籍フィールドを何も考えずに使うと");
            puts("見ずらいソースになりがちなので");
            puts("必要以上に使わないことをお勧めします");
            break;
        }
        case 56://#56 scanf()関数
        {
            puts("#56 scanf()関数");
            puts("前回はprintf()関数の秘密というか発展に近しいものをやっていきました");
            puts("そしてprintf()関数ぐらいお世話になっていて");
            puts("かつフォーマット指定子を使うものって何ですか？");
            puts("そうですよねscanf()関数ですよね");
            puts("printf()と同じぐらいのタイミングで出てきたscanf()関数にも");
            puts("いろんなフォーマット指定子があります");
            puts("といってもフォーマット指定子の大体がprintf()と同じものは");
            puts("説明しませんが");
            puts("そして今回説明するのが特別変わったフォーマットがありまして");
            puts("それがスキャン集合指定子です");
            puts("これまでscanf()関数を使って様々な壁ににぶち当たったと思います");
            puts("例えばscanf()はホワイトスペースに遭遇すると読み込みを中止させたり");
            puts("スペースやタブなどをscanf()関数から入力することはできませんでした");
            puts("また、プログラムが予期しない値が代入される可能性もあります");
            puts("文字を入力しろと言っているのに数値を入力したり");
            puts("その逆だってあります");
            puts("ユーザーは気まぐれなのでそれぞれに対応を考えなくてはいけません");
            puts("そこで登場するのがスキャン集合指定子で指定します");
            puts("スキャン集合指定子は指定した文字だけを読み込む指定子です");
            puts("強いですねぇ〜");
            puts("これは%%のあとに大カッコ[]を指定し、カッコの中に文字を書き込みます");
            puts("ってことでこんな感じ〜");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        char yn;");
            puts("        printf(\"猫耳は好きですか?y/n>\");");
            puts("        scanf(\"%%[yn]\" , &yn);");
            puts("");
            puts("        printf(\"入力された値 = %%c\" , yn);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("この場合scanf()はyかnしか読み取りません");
            puts("もちろん大文字も小文字も違うものとして扱います");
            puts("なのでYやNは読み込みません");
            puts("文字列や数列を入力する場合、最初に指定文字以外の文字が");
            puts("現れた時点で読み取りを中断します");
            puts("例えば0~9までの値を文字入力として集合指定子で指定した場合");
            puts("10A10と入力するとAが出てき時点で入力を中止します");
            puts("しかし読み取るべきスキャン集合が非常に多い場合は面倒です");
            puts("1行が長くなるため、ソースも見づらくなりますね");
            puts("そのような場合は");
            puts("読み取らない文字を指定することもできます");
            puts("スキャン集合の一部ではないことを指定するには^を集合の前に指定します");
            puts("ってことでコードだとこんな感じ");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        char str[128];");
            puts("        printf(\"文字列を入力してください>\");");
            puts("        scanf(\"%%[^0123456789\\n]\" , str);");
            puts("");
            puts("        printf(\"入力された値 = %%s\\n\" , str);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("注目してほしいところは改行も指定しているところです");
            puts("この改行を指定しなかった場合");
            puts("改行も一緒に読み込まれてしまいます");
            puts("もちろんそれを要求している場合改行も集合の一部にすればいいのです");
            puts("この方法を用いればホワイトスペース(改行やタブ)も読み取ることが可能です");
            puts("コードで書くとこんな感じ");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        char str[128];");
            puts("        printf(\"文字列を入力してください>\");");
            puts("        scanf(\"%%[^\n]\" , str);");
            puts("");
            puts("        printf(\"入力された値 = %%s\\n\" , str);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("これは空白やタブをscanf()から読み取ることができます");
            puts("こんにちは 私は暇人ですと入力したら開業までがstrに代入されます");
            puts("しかしscanf(9はあくまで数値を読み込むためであり");
            puts("文字列の入力に適した関数とは言えません");
            puts("数値以外の型の入力に");
            puts("scanf()が重宝されることはありません");
            puts("ついでですが");
            puts("小文字だけ読み取りたいとか");
            puts("大文字だけという場合");
            puts("aからzまで入れるのは大変です");
            puts("そんな時はこんな入力の仕方があります");
            puts("%%[a-z]");
            puts("これはaからzまでがスキャン集合指定子に");
            puts("入れますよってことです");
            puts("ちなみにこれは大文字でもできるし");
            puts("%%[a-zA-Z0-9]としても指定できます");
            puts("ただしハイフンによる指定はANSI Cの規定外です");
            puts("必ずしもすべてのコンパイラで実装されているわけではないようです");
            puts("");
            puts("そしてscanf()のその他の機能について教えます");
            puts("今まで制御文字列ではフォーマット指定のみを行いました");
            puts("まぁ簡単に言うと%%dとか%%sとか");
            puts("しかしここに通常の文字列などを指定することもできます");
            puts("ここでフォーマット指定子以外が指定された場合");
            puts("scanf()は制御文字列以外の文字に遭遇んするまで");
            puts("文字を読み取りその文字を廃棄します");
            puts("例えばですが");
            puts("1度に2つの変数へ値を入力させたい場合に有効です");
            puts("この時読み込みはデフォルトでホワイトスペースの出現まで読み込まれます");
            puts("ってことでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        int i , j;");
            puts("        printf(\"二つの数を加算します\\n\");");
            puts("        printf(\"数値を空白で区切って2つ入力してください>\");");
            puts("        scanf(\"%%d%%d\" , &i , &j);");
            puts("");
            puts("        printf(\"答えは = %%d\\n\" , i + j);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("デフォルトの状態では二つの変数への読み取りはホワイトスペースで区切られます");
            puts("空白やタブまたは改行コードを読み取ると、そのコードを破棄して変数に");
            puts("読み取ります");
            puts("この場合10と100の間に空白を開けて入力すると");
            puts("iには10が入りjには100が入ります");
            puts("それで出力される文字は110になります");
            puts("そこで");
            puts("例えば二つのフォーマット指定子の間に文字を指定すると");
            puts("その文字が一致しなくなるまで読み取り");
            puts("それを破棄します");
            puts("ってことでそれをコードにしてみるとこんな感じです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        int i , j;");
            puts("        printf(\"二つの数を加算します\\n\");");
            puts("        printf(\"数値を+で区切って2つ入力してください>\");");
            puts("        scanf(\"%%d+%%d\" , &i , &j);");
            puts("");
            puts("        printf(\"答えは = %%d\\n\" , i + j);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("これは簡単に言うと%%dと%%dの間に区切るしるしを作るみたいなものです");
            puts("上のプログラムではそれが+になっただけです");
            puts("そして毎回読み込むが廃棄するという作業が必要なのかといいますと");
            puts("scanf()が持つ厄介な特性のせいです");
            puts("scanf()関数はstdin(標準入力)から入力された文字列を読み取りますが");
            puts("書式指定に合わなかった場合読み取りをやめて関数を終了します");
            puts("この時読み取られなかった文字は 標準入力に残るのです");
            puts("厄介なことに残った値は次scanf()関数を使用したときに拾われます");
            puts("これではユーザーにしてみれば予想もしない出来事が発生することもあります");
            puts("ってことでコードをどうぞ");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        int i , j;");
            puts("        printf(\"iを入力してください>\");");
            puts("        scanf(\"%%d\" , &i);");
            puts("        printf(\"jを入力してください>\");");
            puts("        scanf(\"%%d\" , &j);");
            puts("");
            puts("        printf(\"i = %%d : j = %%d\" , i , j);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("このプログラムは次にscanf()関数が使われたときに文字列が拾われるといいましたが");
            puts("それを証明するプログラムです");
            puts("使い方としては");
            puts("最初の標準入力の時に数字と数字の間に空白やタブを入れる");
            puts("こうすることによって次scanf()関数が使われて");
            puts("残っていた文字が拾われていることがわかると思います");
            puts("実用プログラムを作成する場合はこのscanf()関数が持つ特性を");
            puts("熟知する必要がありますね");
            puts("これを理解しフォーマット指定子以外の文字列を制御文字列内に指定することで");
            puts("簡易電卓などを作成することができます");
            puts("ってことでこちらがそのコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("	char ch;");
            puts("	int i , j;");
            puts("	printf(\"演算します。式を入力してください>\");");
            puts("	scanf(\"%%d %%[+-*/] %%d\" , &i , &ch , &j);");
            puts("");
            puts("	switch(ch) {");
            puts("	case '+':");
            puts("		printf(\"答えは %%d です\" , i + j);");
            puts("		break;");
            puts("	case '-':");
            puts("		printf(\"答えは %%d です\" , i - j);");
            puts("		break;");
            puts("	case '*':");
            puts("		printf(\"答えは %%d です\" , i * j);");
            puts("		break;");
            puts("	case '/':");
            puts("		printf(\"答えは %d です\" , i / j);");
            puts("		break;");
            puts("	default:");
            puts("		printf(\"入力に誤りがあります\");");
            puts("	}");
            puts("	return 0;");
            puts("}");
            puts("");
            puts("これはオペランド演算子は空白スペースで区切るものとします");
            puts("");
            puts("そしてscanf()にもprintf()のように書式指定にも正確な形式があり");
            puts("入力に対する制御をおこなうオプションを指定することができます");
            puts("形はこんな感じ");
            puts("");
            puts("%%[*] [最大フィールド] [{h | l | L }]フォーマット指定子");
            puts("");
            puts("hやl,Lはprintf()関数と同じ意味のものです");
            puts("まずフォーマット指定子のオプションでアスタリスク*をつけることで");
            puts("指定することができます");
            puts("これを指定するとしていされた方は解釈されますが引数に代入されません");
            puts("非フォーマット文字のように");
            puts("型で代入しない型を指定することができるんです");
            puts("例えば%%d%%*c%%dという指定の場合で");
            puts("50-50と入力した場合");
            puts("中間文字 - は読み取られますが");
            puts("引数に代入することなく破棄されます");
            puts("ちなコードだとこんな感じ〜");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        char str[128];");
            puts("        printf(\"数値と文字列を入力してください>\");");
            puts("        scanf(\"%%*d%%[^\n]\" , str);");
            puts("");
            puts("        printf(\"入力された値 = %%s\" , str);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("こちらは最初に数値を入力して");
            puts("続けて文字列を入力すると");
            puts("scanf()は最初に数字以外の文字が出現するまで読み取ります");
            puts("ここで読み取った数値は代入されることなく破棄されます");
            puts("");
            puts("また最大フィールド幅を指定することができます");
            puts("指定方法はprintf()関数と同じです");
            puts("最大フィールドは場を指定すれば入力最大文字を制限できます");
            puts("これがコード");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        char str[16];");
            puts("        printf(\"文字列を入力してください(10文字以内)>\");");
            puts("        scanf(\"%%10[^\n]\" , str);");
            puts("        printf(\"入力された値 = %%s\" , str);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("これは10文字分入力できるものです");
            puts("それとprintf()同様最大入力フィールドは%%cに対して意味を持ちません");
            puts("ってことでscanf()の説明は以上です");
            puts("乙です");
            break;            
        }
        case 57://#57 文字列入出力
        {
            puts("#57 文字列入出力");
            puts("前回前々回で扱った");
            puts("printf()関数やscanf()関数は非常に凡用的な関数です");
            puts("しかし前回少し話したようにscanf()関数は");
            puts("文字列の入出力には必ずしも向いているとは言えません");
            puts("そのためC言語の標準関数には");
            puts("文字列の入出力専用の関数が用意されています");
            puts("例えば文字列を標準出力へ出力する場合は");
            puts("printf()よりも適任であるといえま");
            puts("その文字列の出力に適した関数は");
            puts("puts()という関数です");
            puts("ってことで簡易例です");
            puts("");
            puts("int puts( const char 文字列へのポインタ);");
            puts("");
            puts("引数には出力する文字列を指定します");
            puts("戻り値は正常に終了した場合負ではない値を");
            puts("失敗した場合はEOFを返します");
            puts("そしてputs()には文字列の出力に適しているだけでなく");
            puts("文字列の最後に入れられるヌル文字いわば空白を");
            puts("改行に置き換えて出力してくれます");
            puts("つまり簡単に言うと\nをつけなくても");
            puts("puts()を使えば勝手に改行をしてくれます");
            puts("使用例はこんな感じ");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        puts(\"Kitty on your lap\");");
            puts("        puts(\"Catd Captor Sakura\");");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果は");
            puts("");
            puts("Kitty on yor lap");
            puts("Catd Captor Sakura");
            puts("");
            puts("となるはずです");
            puts("ちなみに文字列の出力に");
            puts("puts()を使うのは");
            puts("printf()関数より関数のサイズが小さく");
            puts("基本的に実行速度も速いからです");
            puts("そして気づいた方もいるかもしれませんが");
            puts("ファイル操作で使ったfputs()という関数の");
            puts("ストリーム版がputs()関数です");
            puts("ちなみにfputs()のストリーム版があるなら");
            puts("fgetsのストリーム版も当然あります");
            puts("この関数は標準入力から1行読み出します");
            puts("改行文字までのすべての文字を読みだすと");
            puts("改行コードをヌル文字に置き換えます");
            puts("簡易例がこんな感じ");
            puts("");
            puts("char *gets(char *バッファ);");
            puts("");
            puts("成功すると引数の値を返します");
            puts("エラーかファイルの終端を検出するとNULlポインタを返します");
            puts("バッファには読みだした文字列を格納するポインタを指定します");
            puts("文字列の読み出しには");
            puts("scanf()よりも適任です");
            puts("ちなみに使い方はこんな感じです");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        char str[128];");
            puts("        printf(\"文字列を入力してください>\");");
            puts("        gets(str);");
            puts("        printf(\"入力した値 = %%s\\n\" , str);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("入力に");
            puts("こんにちは　暇人です");
            puts("と入れた場合出力される文字は");
            puts("");
            puts("こんにちは　暇人です");
            puts("");
            puts("となります");
            puts("見ての通り空白では読み込みを停止されず");
            puts("最後のエンターで読み込みを停止されています");
            puts("ちなみにストリーム版のgets()関数は");
            puts("入力先が違うが違うということだけで");
            puts("ほかは同じと考えてもいいでしょう");
            puts("そして文字列に対して１文字の入出力をサポートする関数も用意されていて");
            puts("文字を出力をする");
            puts("putschar()関数と");
            puts("文字を入力する");
            puts("putsgets()関数があります");
            puts("簡易例で表すとこうなります");
            puts("");
            puts("int putchar( int c );");
            puts("int getchar( void );");
            puts("");
            puts("putchar()には標準出力へ出力する値をcに指定します");
            puts("putchar()の戻り値は、エラーが発生するとEOF");
            puts("それ以外は書き込んだ文字を返します");
            puts("getchar()は標準出力から1文字を読み取ってintにキャストした値を返します");
            puts("ってことで使用例です");
            puts("");
            puts("#include <stdio.h>");
            puts("");
            puts("int main() {");
            puts("        char ch;");
            puts("        printf(\"文字を入力してください>\");");
            puts("        ch = getchar();");
            puts("        printf(\"入力された値 = \");");
            puts("        putchar(ch);");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("この実行例でkonnnitihaと文字を入力した場合");
            puts("出力される文字は");
            puts("");
            puts("入力された値 = k");
            puts("");
            puts("こうなるでしょう");
            puts("ちなみにこれらの関数に似た関数で");
            puts("putc()関数とgetc()関数が存在します");
            puts("これらの関数はfputc()とfgetc()関数と全く同じです");
            puts("ANSI Cが定められたときファイル関数として");
            puts("fputc()とfgetc()が加わりました");
            puts("ANSI Cでは、ファイル関数は先頭にfがつくという規則があるためです");
            puts("しかしもとから存在するgetc()やputc()も伝統的に");
            puts("使われていたため残されています");
            puts("実装によっては関数ではなくマクロとして実装している場合もあります");
            puts("ちなみに");
            puts("getchar(void)やputchar(int c)はfgetc(stdin),fputc(int c,stdout)と機能的に同じです");
            puts("そしてfgetc()とfputc()はgetc()とputc()に同じです");
            puts("これらの関係を理解しておいてください");
            puts("ってことで文字列入出力の説明は以上です");
            break;
        }
        case 58://#58 時間管理
        {
            puts("#58 時間管理");
            puts("今回は時間系に関する関数を説明していきます");
            puts("ある程度高度なプログラムを組む場合システムが持つ時間を利用する");
            puts("場合があります");
            puts("例えば タイムスライシング(時間割)プログラムなどに必要になります");
            puts("時間関係の情報を要求する場合");
            puts("time.hヘッダファイルを用います");
            puts("この関数はシステムから時間を得てまたそれをカレンダーに置き換える作業を");
            puts("サポートします");
            puts("現在のシステム時間を得るにはtime()関数を使います");
            puts("使い方はこんな感じ");
            puts("");
            puts("time_t time(time_t *timer);");
            puts("");
            puts("ここで新しい標準型のtime_tというものが出てきました");
            puts("これはtime()関数などの値による時間値を返す型です");
            puts("timerには得られた時間を格納するポインタを指定します");
            puts("戻り値からも得られるので引数にNULLを指定することができます");
            puts("ってことでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("#include <time.h>");
            puts("");
            puts("int main() {");
            puts("        time_t cl;");
            puts("        time(&cl);");
            puts("        printf(\"%%d : %%d\" , cl , time(NULL));");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果は");
            puts("万国標準時(UCT)の1970年1月1日00:00:00からの");
            puts("経過した時間を秒単位で表した数値です");
            puts("なので実行するととてつもない数字が出てきますｗ");
            puts("ちなみにコードの解説ですが");
            puts("time(&cl);というように");
            puts("time_t型の変数に値を格納することも可能ですし");
            puts("time(NULL)を指定して");
            puts("戻り値だけを期待することもできます");
            puts("");
            puts("もしカレンダーのような数値を得たい場合は");
            puts("時間構造体なるものを使用する必要があります");
            puts("時間構造体はstruct tmで指定でき");
            puts("時間構造体はtime.hヘッダファイルに定義されています");
            puts("通常はtime()関数でえられた値をlocaltime()関数で");
            puts("構造体に変換します");
            puts("使い方的にはこんな感じ");
            puts("");
            puts("struct tm *localtime( const time_t *timer );");
            puts("");
            puts("timerにはtime_t型のポインタを渡しています");
            puts("この関数は時間構造体へのポインタを返します");
            puts("ただしtimerの値が1970年1月1日0時0分以前を示している場合NULLを返します");
            puts("得られた時間構造体 tm のメンバから");
            puts("現在の時刻をカレンダーとして値を得られます");
            puts("時間構造体のメンバは次のようになっています");
            puts("");
            puts("tm_sec	秒(0 - 59)");
            puts("tm_min	分(0 - 59)");
            puts("tm_hour	時(0 - 23)");
            puts("tm_mday	日(1 - 31)");
            puts("tm_mon	月(0 - 11)");
            puts("tm_year	年(現在の年から1900引いた値)");
            puts("tm_wday	曜日(0 - 6)");
            puts("tm_yday	通算日数(0 - 365)");
            puts("tm_isdst	夏時間");
            puts("");
            puts("月は1月を0としますので");
            puts("表示させる場合は1を加算します");
            puts("曜日は日曜を0としています");
            puts("夏時間は有効な場合は0を");
            puts("無効な場合は0を");
            puts("不明な場合は負の数を返します");
            puts("ってことでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("#include <time.h>");
            puts("");
            puts("int main() {");
            puts("        time_t timeValue;");
            puts("        struct tm *timeObject;");
            puts("");
            puts("        time(&timeValue);");
            puts("        timeObject = localtime(&timeValue);");
            puts("");
            puts("        printf(\"%%d年 %%d月 %%d日 || %%d : %%d : %%d\" ,");
            puts("                timeObject->tm_year + 1900 , timeObject->tm_mon + 1 ,");
            puts("                timeObject->tm_mday , timeObject->tm_hour ,");
            puts("                timeObject->tm_min , timeObject->tm_sec);");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("実行結果は実行した年月や時間などが表示されるはずです");
            puts("プロンプトではあまりいいことではありませんが");
            puts("このようにリアルたむ時計を作ることもできます");
            puts("そしてコードの解説をするのですが");
            puts("最初にtime_t()でtimeValueという変数を宣言しています");
            puts("そのあとにtimeObjectという時間構造体を宣言しています");
            puts("そしてそのあとにtime()でリアルタイムの時間を");
            puts("time_tで作ったtimeValue変数に格納した後に");
            puts("localtime()で人が読める形にし");
            puts("そのアドレスを時間構造体に格納しています");
            puts("その格納されたアドレスには現在の年月や時間の");
            puts("情報があるので");
            puts("時間構造体のメンバであるtime_secなどで");
            puts("呼び出せるということです");
            puts("それと");
            puts("このようなプログラムでリアルタイムにループさせて");
            puts("デジタル時計を作ることはできますが");
            puts("windowsなどのマルチタスクプログラム環境下では無意味なループは厳禁です");
            puts("しかしこの場ではとりあえずシングルタスクと考え");
            puts("コードを書きます");
            puts("");
            puts("#include <stdio.h>");
            puts("#include <time.h>");
            puts("");
            puts("int main() {");
            puts("	time_t timeValue , timeTmp;");
            puts("	struct tm *timeObject;");
            puts("");
            puts("	while (1) {");
            puts("		if (time(&timeValue) != timeTmp) {");
            puts("			timeObject = localtime(&timeValue);");
            puts("");
            puts("			if (timeObject == NULL) {");
            puts("				puts(\"システム時刻が正常に得られません\");");
            puts("				break;");
            puts("			}");
            puts("");
            puts("			printf(\"%%2.2d : %%2.2d : %%2.2d\\r\" , timeObject->tm_hour ,");
            puts("				timeObject->tm_min , timeObject->tm_sec);");
            puts("		}");
            puts("		timeTmp = timeValue;");
            puts("	}");
            puts("		");
            puts("	return 0;");
            puts("}");
            puts("");
            puts("これを実行すると");
            puts("リアルタイムの時間分秒が表示されるはずです");
            puts("しかし無限ループなので負荷がかかります");
            puts("終了したい場合は Ctrl + Cで強制終了できるらしいので");
            puts("それをしてください");
            puts("そしてこのコードは珍しく");
            puts("動的に時間を更新しています");
            puts("ちなみに原理ですが");
            puts("最初に時刻を得て");
            puts("最後にチェック用変数timeTmpに値を格納します");
            puts("新しく時間を得るごとにtimeTmpと比較し、異なる場合は画面に出力する");
            puts("ということをして少しでも動作を軽くするかつ");
            puts("正確な時計が作れます");
            puts("このほかにも何らかのプロセスの時間を計算したい場合があります");
            puts("2つの異なる時間の差を計算する場合は");
            puts("difftime()関数が非常に便利です");
            puts("使い方はこんな感じ");
            puts("");
            puts("double difftime(time_t timer1,time_t timer0);");
            puts("");
            puts("timer1に終了時間をtimer0に開始時間を指定します");
            puts("この関数はtimer0からtimer1までの時間を");
            puts("秒単位で倍精度浮動小数点で返してくれるそうです");
            puts("この関数を用いれば");
            puts("何らかの処理時間を図ることができます");
            puts("ってことでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("#include <time.h>");
            puts("");
            puts("int main() {");
            puts("	int i;");
            puts("	double d;");
            puts("	time_t timeValue[2];");
            puts("");
            puts("	puts(\"演算中…\");");
            puts("	timeValue[0] = time( NULL );");
            puts("	for (i = 0 ; i < 100000 ; i++) printf(\"%%d\\r\" , i);");
            puts("	timeValue[1] = time( NULL );");
            puts("");
            puts("	printf(\"処理に %%d 秒かかりました\" , (int)difftime(timeValue[1] , timeValue[0]));");
            puts("		");
            puts("	return 0;");
            puts("}");
            puts("");
            puts("これを実行すると");
            puts("処理にかかった時間を表示してくれます");
            puts("私の場合");
            puts("処理に1秒かかりました");
            puts("と出力されましたね");
            puts("ちなみにループのprintf()関数の出力部分を浮動小数点演算などに変えても");
            puts("最近のコンピューターなら一瞬で作業は終わると思います");
            puts("いかに主記憶と周辺機器の入出力に時間がかかるかわかると思います");
            puts("ってことで時間管理の説明は以上です");
            puts("お疲れさまでした");
            break;
        }
        case 59://#59 乱数を得る
        {
            puts("#59 乱数を得る");
            puts("今まで変数を自分たちで決めて代入する方法しかしてきませんでしたが");
            puts("今回は乱数について教えていきます");
            puts("それで乱数を得るには");
            puts("stdlib.hヘッダファイルを利用します");
            puts("このヘッダファイルにはrand()関数が用意されてます");
            puts("使い方はこんな感じ");
            puts("");
            puts("int ranku(void);");
            puts("");
            puts("この関数は呼び出されるたび疑似乱数を返します");
            puts("ここで得られっる乱数は0からRAND_MAXの汎愛内の数値です");
            puts("RAND_MAXはstdlib.hに定義されている定数で");
            puts("ANSI C標準のコンパイラでは少なくとも32768の値を持つそうです");
            puts("つまり0〜32768の値を得ることができます");
            puts("ってことでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("#include <stdlib.h>");
            puts("");
            puts("int main() {");
            puts("	int count;");
            puts("	for (count = 0 ; count < 10 ; count++)");
            puts("		printf(\"%%d\\n\" , rand());");
            puts("");
            puts("	return 0;");
            puts("}");
            puts("");
            puts("実行結果はランダムで数字が出されるはずです");
            puts("しかしもう一度実行したところ同じ順番で値が出力されます");
            puts("これはrand()関数が計算で疑似乱数を生成しているため");
            puts("これはちゃんとした乱数ではないのです");
            puts("そこで疑似乱数を生成するための初期値を変更します");
            puts("初期値を指定しなかった場合1を初期値として疑似乱数を出しています");
            puts("初期値の指定はsrand()関数が行えます");
            puts("この関数も同じくstdlib.hヘッダファイルに定義されていて");
            puts("rand()関数を使う前に呼び出して");
            puts("初期値を指定します");
            puts("");
            puts("void srand(unsigned int seed);");
            puts("");
            puts("seedに乱数を生成するための値を指定します");
            puts("ここの値を可変にすることで");
            puts("乱数は適当な値になります");
            puts("もちろん、一定の値であれば");
            puts("乱数は常にその値から生成されるので");
            puts("やはり同じ結果しか返さない乱数になります");
            puts("それじゃあ常に違う乱数を返すもの作りたいとなった時");
            puts("何を使うかといいますと");
            puts("常に変化する値を使えばいいのです");
            puts("ってことで最近学んだシステム時刻が");
            puts("常に変化する値ですよね");
            puts("ってことでtime()関数を使って初期化します");
            puts("そんじゃこれがコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("#include <stdlib.h>");
            puts("#include <time.h>");
            puts("");
            puts("int main() {");
            puts("        int count;");
            puts("        srand((unsigned)time( NULL ));");
            puts("        for (count = 0 ; count < 10 ; count++) {");
            puts("                printf(\"%%d\\n\" , rand());");
            puts("        }");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("これで出される値は変化し続けますが");
            puts("これも計算で結果を出している以上ある程度規則性が");
            puts("生まれてしまいますが");
            puts("乱数としては使えるのでOKです");
            puts("時間はプログラムを起動するたびに異なるので");
            puts("結果として常に異なる値いで乱数を初期化することができています");
            puts("ここまでで異なる値の出力には成功しましたが");
            puts("まだ出力される範囲が広いです");
            puts("大体のシステムでは30000近くまでの範囲の");
            puts("乱数を得る必要ありませんよねｗ");
            puts("まぁ逆もあるかもしれませんけど");
            puts("特定の範囲内の乱数を得る方法を教えます");
            puts("これはrand()関数で得られた結果を算術演算");
            puts("言ってしまえば計算して解決する方法です");
            puts("指定範囲の乱数を得る場合");
            puts("最大値で除算した余りで求めることができます");
            puts("つまり0〜9の値が欲しい場合は");
            puts("rand()%%10とするのです");
            puts("まぁ乱数の精度にシビアなシステム計算では");
            puts("この方法は推奨されないようです");
            puts("ってことでコードだとこうなります");
            puts("");
            puts("#include <stdio.h>");
            puts("#include <stdlib.h>");
            puts("#include <time.h>");
            puts("");
            puts("int main() {");
            puts("        int count;");
            puts("        srand((unsigned)time( NULL ));");
            puts("        for (count = 0 ; count < 10 ; count++) {");
            puts("                printf(\"%%d\\n\" , rand() %% 10);");
            puts("        }");
            puts("");
            puts("        return 0;");
            puts("}");
            puts("");
            puts("これで0〜9までの値が出せたと思います");
            puts("ちなみにrand()%%10だと0〜9ですが");
            puts("%%11にすると0〜10の値が返されるようになります");
            puts("つまり%%のあとにつける数は");
            puts("乱数で出したい最大値+1すると最大値が想像通り");
            puts("のものになるでしょう");
            puts("最後にrand関数の精度の確認をしてみましょう");
            puts("0か1の欄集を出力させその結果を変数に格納して");
            puts("比較してみます");
            puts("確率が2分の1であればお互いの出力される確率は");
            puts("近しいはずです");
            puts("ってことでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("#include <stdlib.h>");
            puts("#include <time.h>");
            puts("");
            puts("int main() {");
            puts("	int count , one = 0 , zero = 0;");
            puts("	srand((unsigned)time( NULL ));");
            puts("	for (count = 0 ; count < 100000 ; count++) {");
            puts("		if (rand() %% 2) one++;");
            puts("		else zero++;");
            puts("	}");
            puts("	printf(\"0 = %%d : 1 = %%d\" , zero , one);");
            puts("	return 0;");
            puts("}");
            puts("");
            puts("出力してみてわかると思いますがかなり2分の1に近しいかずになったともいます");
            puts("このプログラムは10万回乱数を発生させているので");
            puts("変数zeroとoneは5万の値に近しいはずです");
            puts("疑似乱数でも一応乱数としては成り立っていることがわかりますね");
            puts("それで乱数の説明はこれで以上です");
            puts("お疲れさまでした");
            
        }
        case 60://#60 動的引数
        {
            puts("#60 動的引数");
            puts("これまでC言語を用いてきた標準出力の中で");
            puts("printf()関数やscanf()関数のような凡用的で");
            puts("特異な関数があります");
            puts("その機能は以前説明しましたが");
            puts("printf()関数のような引数の数が固定できない関数を");
            puts("私たちはまだ作れません");
            puts("ここでは引数の数を可変的に受け取れる関数を");
            puts("作成してみましょう");
            puts("まずプロトタイプで引数の数は固定できないことを示します");
            puts("そのためには３つのピリオドからなる...を用います");
            puts("使い方的にはこんな感じ");
            puts("");
            puts("void function(第一引数, ...);");
            puts("");
            puts("この場合でも必ず第一引数は固定になります");
            puts("ちなみにこの第一引数は可変引数の数を表しています");
            puts("可変にすることができるのは第二引数以降になります");
            puts("これでいくらでも(可変個の)引数を受け取ることができる関数を");
            puts("作成することができました");
            puts("次に受け取った引数にアクセスする必要があります");
            puts("可変個の引数にアクセスするには");
            puts("まずstdarg.hヘッダファイルをインクルードします");
            puts("そしてこのヘッダファイルで");
            puts("定義されているマクロと構造体型を利用します");
            puts("まず可変個の引数リストにアクセスを開始するにはva_start()を使用します");
            puts("必ずこれを最初に使う必要があります");
            puts("必ずです");
            puts("ってことで使い方はこんな感じ");
            puts("");
            puts("void va_start(va_list リスト,prev);");
            puts("");
            puts("リストには、引数リストへのポインタを指定します");
            puts("これは、可変個の引数の情報を保持するための");
            puts("stdarg.hで定義されている標準型です");
            puts("pervは最初の可変個数の手前の固定引数を指定します(最後の固定引数)");
            puts("簡単に言うと第一引数です");
            puts("この時点でva_list型の変数に可変引数の情報(可変引数の数)が格納されます次にva_list型変数から");
            puts("順に可変引数の内容を呼び出します");
            puts("引数リストの値を得るにはva_arg()を使用します");
            puts("使い方はこんな感じ");
            puts("");
            puts("type va_arg(va_list リスト,type);");
            puts("");
            puts("リストはva_start()で渡してセットされたva_list型変数を指定します");
            puts("typeは引数リストから受け取る値の型を指定します");
            puts("可変個の場合、引数を受け取るときに型チェックはされないめ");
            puts("ここで型を明示します");
            puts("つまり受け取る値が");
            puts("int型として処理するのか");
            puts("または");
            puts("char型で処理するのかを決めます");
            puts("引数リストは");
            puts("可変個数の引数の始まり部分にセットされています");
            puts("そこからva_arg()が呼び出されるごとに次の引数を返します");
            puts("まぁ簡単にまとめると");
            puts("typeが出力または代入する");
            puts("値の型(intやcharなどの型)");
            puts("そしてリストは");
            puts("はじめてva_arg()を使った場合");
            puts("可変引数の初めの値が出力され");
            puts("読み込む場所が一つ右にずれます");
            puts("そのあとva_arg()を使用するたびに");
            puts("読み込む場所が右にずれていきます");
            puts("そして最後にすべての引数を取得したらva_end()ポインタでNULLにリセットします");
            puts("簡単に言うと引数の数を指定していた");
            puts("第一引数で受け取った数だけ繰り返したら");
            puts("va_end()で");
            puts("第一引数で受け取った値を");
            puts("0にするということです");
            puts("ってことで使い方です");
            puts("");
            puts("void va_end(va_list リスト);");
            puts("");
            puts("リストはこれまでva_start()やva_arg()で引数にアクセスしていた変数です");
            puts("ってことでコードです");
            puts("");
            puts("#include <stdio.h>");
            puts("#include <stdarg.h>");
            puts("");
            puts("void dynamicArgument(int , ...);");
            puts("");
            puts("int main() {");
            puts("	dynamicArgument(4 , 10 , 20 , 30 , 40);");
            puts("	return 0;");
            puts("}");
            puts("");
            puts("void dynamicArgument(int arg_num , ...) {");
            puts("	va_list args;");
            puts("	int value , count;");
            puts("");
            puts("	if (arg_num < 1) return;");
            puts("");
            puts("	va_start(args , arg_num);");
            puts("");
            puts("	for (count = 0 ; count < arg_num ; count++) {");
            puts("		value = va_arg(args , int);");
            puts("		printf(\"第%%d引数 = %%d\\n\" , count + 2 , value);");
            puts("	}");
            puts("");
            puts("	va_end(args);");
            puts("	return;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("第2引数 = 10");
            puts("第3引数 = 20");
            puts("第4引数 = 30");
            puts("第5引数 = 40");
            puts("");
            puts("ここでは可変個の引数を受け取る関数dynamicArgument()を作成しています");
            puts("ここの関数は第一引数に引数の個数を第二引数以降な任意のint型引数を受け取り");
            puts("第二引数以降で受け取った値をint型として標準出力に出力します");
            puts("");
            puts("このように可変個の引数を受け取った場合");
            puts("受け取り方も動的になるため何らかの手段で");
            puts("引数の個数を調べる必要があります");
            puts("printf()関数などはフォーマット指定子によって");
            puts("引数リストの個数と型をチェックしていますね");
            puts("ちなみに通常");
            puts("va_arg(),va_start(),va_end()");
            puts("は関数ではなく");
            puts("マクロとして");
            puts("実装されています");
            break;
        }
        case 61://#61 ワイド文字
        {
            puts("#61 ワイド文字");
            puts("ANSI Cは標準でワイド文字をサポートしています");
            puts("ワイド文字とは1文字を表現するのに2バイトを用いる文字のこと");
            puts("同時に1バイト以上の文字のことをマルチバイト文字といいます");
            puts("これまで文字コードはASCIIコードを用いてきました");
            puts("これは1文字を1バイト(char型)で表現できるコードで");
            puts("世界的に標準とされているコードです");
            puts("しかし1バイトだけでは中国語や日本語のような");
            puts("漢字や記号を持つ言語は表せません");
            puts("そこでワイド文字が使われるのです");
            puts("ワイド文字は国際的なアプリケーションには必要な知識です");
            puts("ことUnicodeなどは非常に有名ですね");
            puts("ワイド文字の方はwchar_tです");
            puts("これは標準型としてWCHAE.Hヘッダファイルに定義されています");
            puts("またSTDDEF.H、STDLIB.Hヘッダファイルなどにも定義されています");
            puts("書き方はこんな感じです");
            puts("");
            puts("typedef unsigned short wchar_t;");
            puts("");
            puts("wchar_t型はusing short int すなわち16ビットデス");
            puts("当然short int型なので通常の文字列関数などには使えません");
            puts("ってことでとりあえずコードだとこんな感じです");
            puts("");
            puts("#include<stdio.h>");
            puts("#include<stdlib.h>");
            puts("");
            puts("int main() {");
            puts("	wchar_t ch;");
            puts("	printf(\"%%d\" , sizeof ch);");
            puts("	return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("2");
            puts("");
            puts("予想通り2という正数が標準出力に表示されます");
            puts("次はワイド文字で文字列を表現してみましょう");
            puts("ワイド文字として文字列を格納するには");
            puts("文字列の前にL(Long)プレフィックス(前につけるやつ)を指定します");
            puts("これはコンパイラにワイド文字を文字列として扱うように指示するものです");
            puts("書き方はこんな感じ");
            puts("");
            puts("wchar_t wc[]=L\"String...\";");
            puts("");
            puts("ワイド文字は必ず1文字2バイトの領域を確保します");
            puts("Lとクォーテーションの間にホワイトスペースが入ってはいけません");
            puts("ってことでコードです");
            puts("");
            puts("#include<stdio.h>");
            puts("#include<stdlib.h>");
            puts("");
            puts("int main() {");
            puts("	char ch[] = \"Kitty on your lap\";");
            puts("	wchar_t wch[] = L\"Kitty on your lap\";");
            puts("");
            puts("	printf(\"char 型文字列 = %%d\\n\" , sizeof ch);");
            puts("	printf(\"wchar_t 型文字列 = %%d\\n\" , sizeof wch);");
            puts("	return 0;");
            puts("}");
            puts("");
            puts("実行結果");
            puts("");
            puts("char 型文字列 = 18");
            puts("wchar_t 型文字列 = 36");
            puts("");
            puts("これでわかる通り1文字2バイト使っていることがわかるでしょうか");
            puts("通常のchar型変数ch配列サイズは文字数+1ですね(最後はヌル文字)");
            puts("これに対してwchar_t型変数のwchは(文字数+1)x2のサイズが確保されています");
            puts("ワイド文字はヌル文字にも2バイトを割り当てるので注意です");
            puts("同様の方法でポインタ型変数に文字列を代入することも可能です");
            puts("また,単一のワイド文字の前にLプレフィックスをつけても間違いではありません");
            puts("ほとんどの場合wchar_t型は2バイト文字ですが");
            puts("文字コードによっては");
            puts("それ以上であることも考えられます");
            puts("ワイド文字の文字コードの定義はANSI Cではされてないので");
            puts("実装依存行ってしまえば");
            puts("環境依存になってしまいます");
            break;    
        }
        case 62://エスケープシーケンス一覧
        {
            puts("記号	意味");
            puts("\\a	ベル文字（アラート）");
            puts("\\b	１文字分戻る");
            puts("\\f	ページ送り（クリア）");
            puts("\\n	改行、復帰");
            puts("\\r	同じ行の先頭に戻る");
            puts("\\t	水平タブ");
            puts("\\v	垂直タブ");
            puts("\\\\	\\を表示");
            puts("\\\?	?を表示");
            puts("\\\'	シングルクォーテーション(\')を表示");
            puts("\\\"	ダブルクォーテーション(\")を表示");
            puts("\\0	ヌル");
            puts("\\N	8進定数（Nは8進数の定数）");
            puts("\\xN	16進定数(Nは16進数の定数）");
            break;
        }
        case 63://#62 番外編#1(基本関数の振り返り)
        {
            puts("番外編ではC言語のワイド文字までを読んだまたは");
            puts("理解した人用のものです");
            puts("");
            puts("基本関数には変数の宣言や");
            puts("printf()やscanf()などがあったので");
            puts("今一度振り返ってみようかと思います");
            puts("");
            puts("-----<関数とは>");
            puts("");
            puts("-----<引数>-----");
            puts("引数とは");
            puts("関数を実行するときに渡す値です");
            puts("まぁイメージですが");
            puts("商品を買うときに");
            puts("お金を払いますよね");
            puts("それが引数です");
            puts("");
            puts("-----<戻り値>-----");
            puts("戻り値とは関数が終わった後に");
            puts("返される値です");
            puts("簡単に言うと引数を使って");
            puts("行った操作の答え(結果)を");
            puts("返すみたいなことです");
            puts("イメージとしては");
            puts("");
            puts("商品を買うときに");
            puts("お金を渡しました(引数)");
            puts("それで返されたものは");
            puts("商品です(戻り値)");
            puts("商品とお金を渡して帰ってきたのはレシートと");
            puts("商品とかっていう話は聞き入れませんｗ");
            puts("");
            puts("プログラム内での戻り値を表すにはreturnを用います");
            puts("ちなみに戻り値の使い方はこんな感じです");
            puts("");
            puts("return 0;");
            puts("");
            puts("このように使います");
            puts("ちなみにmain関数内でreturnを使うと");
            puts("プログラムが終了したと判断されて");
            puts("プログラムが終了します");
            puts("それとまたあとで触る機会があるので覚えておきましょう");
            puts("");
            puts("-----<ヘッダファイルについて>-----");
            puts("#includeのあとに続くヘッダファイルの振り返りですね");
            puts("ヘッダファイルにはそれぞれ");
            puts("使える関数が定義されていて");
            puts("ヘッダファイルをインクルードしないと");
            puts("使えない関数なんかもありましたね");
            puts("例えば最後の方でやった");
            puts("time()関数だったり");
            puts("インクルードしないと使えない関数があります");
            puts("");
            puts("-----<int main()について>-----");
            puts("そしてint main()の説明ですね");
            puts("int main()の形は");
            puts("こんな感じで私は理解しています");
            puts("");
            puts("戻り値で返される型 関数名 (引数)");
            puts("");
            puts("ちゃんと理解最後まで読んでいる方なら");
            puts("戻り値で返される型なんかは想像できますね");
            puts("そして関数名はそのまま関数名なのですが");
            puts("一つのプログラムには絶対実行する関数が必要で");
            puts("それがmain関数ですね");
            puts("なのでint main()がないとプログラムは実行できません");
            puts("そして引数は");
            puts("関数を実行したときに中に持ってくる値のことですね");
            puts("これは後々自作関数の説明をするときにまた深く語ります");
            puts("");
            puts("-----<エスケープシーケンス>-----");
            puts("エスケープシーケンスとは");
            puts("関数内の表示の仕方を変更するものです");
            puts("");
            puts("記号	意味");
            puts("");
            puts("\\a	ベル文字（アラート）");
            puts("\\b	１文字分戻る");
            puts("\\f	ページ送り（クリア）");
            puts("\\n	改行、復帰");
            puts("\\r	同じ行の先頭に戻る");
            puts("\\t	水平タブ");
            puts("\\v	垂直タブ");
            puts("\\\\	\\を表示");
            puts("\\\?	?を表示");
            puts("\\\'	シングルクォーテーション(')を表示");
            puts("\\\"	ダブルクォーテーション(\")を表示");
            puts("\\0	ヌル");
            puts("\\N	8進定数（Nは8進数の定数）");
            puts("\\xN	16進定数(Nは16進数の定数）");
            puts("");
            puts("このようにいろいろあるので");
            puts("覚えておきましょう");
            puts("");
            puts("-----<フォーマット指定子>-----");
            puts("フォーマット指定子とは");
            puts("変数や文字列を表示または格納するために");
            puts("関数内で使われることのあるものです");
            puts("");
            puts("指定子	詳細					例");
            puts("");
            puts("%d		整数(10進数)			123");
            puts("%u		整数(符号なし10進数)		123");
            puts("%x		整数(16進数、小文字)		7b");
            puts("%X		整数(16進数、大文字)		7B");
            puts("%o		整数(8進数)			173");
            puts("%e		指数表示				1.23e-02");
            puts("%g		簡潔な表示				1.23e+02");
            puts("%c		1文字					'A'");
            puts("%s		文字列				\"hello\"");
            puts("%f		小数点(浮動小数点)		123.456");
            puts("%lf		小数点(倍精度浮動小数点)	123.456");
            puts("%p		ポインタアドレス		0x7ffee2345abc");
            puts("%%		%%自体を表示			%%");
            puts("");
            puts("このように文字の詳細のように");
            puts("文字を表示、格納をします");
            puts("");
            puts("ちなみに%%eと%%gの違いがあまりわかりにくいので説明をしますと");
            puts("%%eで123を表示すると1.23e-01のように1以上10未満の形にして出力します");
            puts("%%gは123.00000とかの場合%%gを使うと");
            puts("123.00000のように0が後尾または前方についていた場合");
            puts("それらを消しずすかつ1以上10未満にします");
            puts("123.00000を%%gで表示すると");
            puts("1.233e-2となります");
            puts("逆に");
            puts("0.00123を%%gで表示すると");
            puts("1.23e+2となるはずです");
            puts("ちなみにeのあとのe-数字の数字部分は");
            puts("10を何回割ったよってことです");
            puts("逆にここがe-ではなくe+だった場合は");
            puts("10を何回かけたよって意味になります");
            puts("簡単にまとめますと");
            puts("%%eが0を消さない1以上10未満の数にする");
            puts("%%gが0を消す1以上10未満の数にする");
            puts("という感じです");
            puts("");
            puts("-----<基本関数>-----");
            puts("");
            puts("-----<変数>-----");
            puts("変数型には");
            puts("何種類かあり");
            puts("");
            puts("型		詳細					バイト数	ビット数(1バイト8ビットとして計算)");
            puts("");
            puts("-<変数>-");
            puts("int		数値を格納				4バイト	32ビット");
            puts("char		文字を格納				1バイト	8ビット");
            puts("float		浮動小数点(小数点)		4バイト	32ビット");
            puts("double	倍精度浮動小数点(小数点)	8バイト	64ビット");
            puts("void		何も値がない			-------	---------");
            puts("");
            puts("-<型修飾子>-");
            puts("long		長整数型				4バイト	32ビット");
            puts("short		単整数型				2バイト	16ビット");
            puts("signed	符号あり(正負の値を扱う)	-------	---------");
            puts("unsigned	符号なし(signedの逆)		-------	---------");
            puts("");
            puts("このように変数は5種類");
            puts("変数につけ足して使う型修飾子は4種類");
            puts("ちなみに宣言の仕方は");
            puts("");
            puts("型 変数名 値か文字");
            puts("");
            puts("のように使いますね");
            puts("変数はこのように宣言します");
            puts("");
            puts("型 変数名;");
            puts("");
            puts("型 変数名 = 数値または文字;");
            puts("");
            puts("の2種類の宣言の仕方があります");
            puts("数値を入れない方は宣言しただけなので");
            puts("変数には0が入ります");
            puts("数値を入れた方は");
            puts("宣言されたと同時に値を代入します");
            puts("それと宣言された変数に値を代入することもできます");
            puts("こんな感じで値を入れることができます");
            puts("");
            puts("変数名 = 数値または文字;");
            puts("");
            puts("このやり方で数値や文字を入れることができますが");
            puts("変数に文字を入れる場合はchar型かつダブルクォーテーション(\")で囲む必要があります");
            puts("ちなみに");
            puts("");
            puts("型修飾子 型 変数名;");
            puts("");
            puts("このように型修飾子をつけることで");
            puts("型に符号なしや符号ありを変えられたり");
            puts("割り当てる領域を増やすこともできます");
            puts("");
            puts("-----<入力と出力>-----");
            puts("入力と出力にはそれぞれ違う関数を使います");
            puts("");
            puts("入力:scanf()");
            puts("出力:printf()");
            puts("");
            puts("それぞれの使い方を説明すると");
            puts("");
            puts("<入力>");
            puts("入力はこのように使います");
            puts("");
            puts("scanf(\"フォーマット指定子\",&変数名);");
            puts("");
            puts("scanf()で使うフォーマット指定子は");
            puts("後ろの変数名の型を扱えるフォーマット指定子にしてください");
            puts("例えば");
            puts("int型なら%%dとかですね");
            puts("ちなみに&変数名の&が非常に重要ですので");
            puts("付け忘れずに");
            puts("");
            puts("<出力>");
            puts("出力はこのように使います");
            puts("");
            puts("printf(\"文字列または数字\");");
            puts("");
            puts("このようにすると文字列を入れることができます");
            puts("ちなみにですがprintf()で変数の値を表示させることもできます");
            puts("こんな感じです");
            puts("");
            puts("printf(\"文字列または数字 [フォーマット指定子]\",変数名);");
            puts("");
            puts("別にフォーマット指定子は文字列の間に挟んでも大丈夫です");
            puts("それとフォーマット指定子は変数名の型とあったものを使わないと");
            puts("想像通りの値が表示されません");
            puts("");
            puts("-----<計算>-----");
            puts("プログラミングなんで当たり前ですけど");
            puts("計算もできます");
            puts("ちなみに計算で使う文字のことを");
            puts("演算子といいます");
            puts("");
            puts("演算子	意味");
            puts("");
            puts("+		加算(足し算)");
            puts("-		減算(引き算)");
            puts("*		乗算(掛け算)");
            puts("/		除算(割り算)");
            puts("%%		剰余（余り）");
            puts("=		代入");
            puts("");
            puts("まぁ基本的に");
            puts("掛け算や割り算から先に計算するや");
            puts("カッコで区切ったものからやるなど");
            puts("普通の数学と同じです");
            puts("=だけは特殊ですね");
            puts("=は変数に値を代入するときとかに使います");
            puts("それと=は右の式や値を左に代入するという特性があります");
            puts("ちなみにこの演算子ですが");
            puts("フォーマット指定子で答えだけを表示させることもできます");
            puts("");
            puts("-----<インクリメント・デクリメント>-----");
            puts("これも計算につかいのですが");
            puts("+と-を用いた計算ですね");
            puts("しかしこれの対象は値ではなく変数になります");
            puts("インクリメントとデクリメントには");
            puts("それぞれ2種類の計算方法があります");
            puts("それぞれ詳しく話していきます");
            puts("");
            puts("<インクリメント>");
            puts("インクリメントの一つ目の計算方法はこんな感じです");
            puts("");
            puts("++変数名;");
            puts("");
            puts("これは1プラスしてから何かに代入する");
            puts("みたいなものです");
            puts("それともう一つはこんな感じです");
            puts("");
            puts("変数名++;");
            puts("");
            puts("こちらは値を何かに代入してから");
            puts("プラスするという感じです");
            puts("これらは説明しましたが");
            puts("前に足すか後に足すかの違いですね");
            puts("");
            puts("<デクリメント>");
            puts("デクリメントもインクリメントと");
            puts("同じ形のものが二つあります");
            puts("一つ目は");
            puts("");
            puts("--変数名;");
            puts("");
            puts("ですね");
            puts("二つ目は");
            puts("");
            puts("変数名--;");
            puts("");
            puts("これらのデクリメントも");
            puts("インクリメントと同じく");
            puts("前に引くか後に引くかの違いです");
            puts("");
            puts("-----<if制御>-----");
            puts("ifは英語の通りもしもの場合を");
            puts("作れるものです");
            puts("ちなみにif制御では");
            puts("真偽を明らかにする");
            puts("新しい演算子が出てきます");
            puts("その演算子はこれらですね");
            puts("");
            puts("");
            puts("演算子		詳細");
            puts("");
            puts("a < b		aがbより小さければ");
            puts("a <= b		aがbと同じか小さければ");
            puts("a > b		aがbより大きければ");
            puts("a >= b		aがbと同じか大きければ");
            puts("a == b		aとbが等しければ");
            puts("a != b		aとbが等しくなければ");
            puts("((a) && (b))	式aと式bが真ならば");
            puts("((a) || (b))	式aまたは式bが真ならば");
            puts("!a			aが真なら偽、偽なら真");
            puts("");
            puts("まぁこの辺は不等号式がわかればわかると思いますが");
            puts("&&と||と!はぱっと見でわからないので教えます");
            puts("&&は&(アンド)なので");
            puts("二つの条件があってないと真にならないものと");
            puts("考えてください");
            puts("||は&の逆ですね");
            puts("片方の条件が合っていれば真になるというものです");
            puts("!マークは式が偽の時真を返す");
            puts("逆に真の場合は偽を返すというような");
            puts("逆の答えを出すようなものです");
            puts("ちなみに=はどっちも等しければ真を返すものですねｗ");
            puts("");
            puts("それで肝心のifの使い方ですが");
            puts("");
            puts("if(演算子){関数など}");
            puts("");
            puts("このような形になります");
            puts("演算子はさっき説明した");
            puts("不等号式ですね");
            puts("関数などというところは");
            puts("printf()やscanf()のことを指しています");
            puts("");
            puts("-----<else>-----");
            puts("真偽を逆にして扱いたい場合は");
            puts("!を使えばいいといいましたが");
            puts("毎回ifの演算子で!マークを入れるは");
            puts("面倒くさいので");
            puts("elseというifと対になるような");
            puts("関数を教えます");
            puts("elseとはifで真偽を調べたときに");
            puts("偽が返されたときに");
            puts("実行することができるようになる関数です");
            puts("ってことで使い方はこんな感じ");
            puts("");
            puts("if(演算子){関数など}");
            puts("else{関数など}");
            puts("");
            puts("このような形になります");
            puts("ifで真偽を調べた後真が返されたらifのあとに続く");
            puts("関数などの方へ行きます");
            puts("逆にifで偽が返された場合");
            puts("elseの方の関数などを実行することができます");
            puts("");
            puts("ちなみにif、elseの延長線上にある");
            puts("真偽を求める方法がもう一つありまして");
            puts("それがこちらですね");
            puts("まぁこちらはprintfなどで使用するとよいでしょう");
            puts("");
            puts("式? 真の処理:偽の処理;");
            puts("");
            puts("この式にはそのまま演算子を使った式を入れたりします");
            puts("しかしこちらは0か1での真偽しか図れません");
            puts("簡単に言いますと式のところには不等号式を入れるのが");
            puts("いいのではないかということですね");
            puts("それとこちらは簡素な二者択一分岐の時の");
            puts("場合はこちらの方がいいでしょう");
            puts("ちなみにifのあとの{関数など}");
            puts("のところでもう一度ifを入れることもできます");
            puts("もちろんelseも入れられます");
            puts("");
            puts("-----<switch制御>-----");
            puts("switch制御とは言ってしまえば選択しを作るものです");
            puts("ってことで使い方はこんな感じです");
            puts("");
            puts("switch(選択肢の値){");
            puts("	case 定数:");
            puts("		プログラム");
            puts("	case 定数:");
            puts("		プログラム");
            puts("	default:");
            puts("		プログラム");
            puts("}");
            puts("");
            puts("こんな感じの使い方をします");
            puts("ここで言う選択肢の値というものは");
            puts("例えば1とか2とかのことですね");
            puts("そして定義ですが");
            puts("選択した値がどれに当てはまるかを見るものです");
            puts("なので選択肢の値が1であれば");
            puts("定数が1になっているところのプログラムを読み取ります");
            puts("そしてdefaultですがこれは");
            puts("選択しに当てはまらなかった時に実行するプログラムを");
            puts("入れることができます");
            puts("ちなみに選択肢の数は何個でも作れます");
            puts("それと選択肢の値のところには変数や");
            puts("演算子を入れることも可能です");
            puts("");
            puts("-----<繰り返し>-----");
            puts("繰り返し行うようなプログラムを");
            puts("作るにはforを使います");
            puts("使い方はこんな感じです");
            puts("");
            puts("for(カウントし始める値;繰り返す回数;ステップ){関数など}");
            puts("");
            puts("カウントし始める値は");
            puts("繰り返す回数と関連していますので最初は");
            puts("繰り返す回数を教えます");
            puts("繰り返す回数はそのままの意味ですが");
            puts("ここに入るものは不等号式です");
            puts("そしてカウントし始める値は");
            puts("初める値です");
            puts("この場合繰り返す回数を指定するために");
            puts("不等号式を使いますよね");
            puts("例えば");
            puts("");
            puts("変数名<10");
            puts("");
            puts("とい不等号式を使うとき");
            puts("変数名の始まりの値が7だったとしましょう");
            puts("そしたら繰り返す回数が3回になるという感じで");
            puts("カウントし始める値と繰り返す回数は");
            puts("関係しあっています");
            puts("そしてステップですが");
            puts("ループの始まった時の処理といった方が正しいですかね");
            puts("これはforに戻ってくるたびに有効ですね");
            puts("ここはカウントを1回進めるという処理をすることが多いですね");
            puts("なのでステップには");
            puts("変数名++が入ることが多いですね");
            puts("ちなみに最初っから不等号式の結果が偽なら1回も実行されずに終わります");
            puts("");
            puts("-----<ずっと>-----");
            puts("forは繰り返す回数を指定していましたが");
            puts("もちろんずっと繰り返すというものもあります");
            puts("それがwhile関数ですね");
            puts("使い方はこんな感じです");
            puts("");
            puts("while(ループを抜け出すための条件式){関数など}");
            puts("");
            puts("ここで言うループを抜け出すための条件式は");
            puts("条件ということなので不等号式です");
            puts("関数などは同じくprintf()などのことです");
            puts("");
            puts("-----<go to>-----");
            puts("go toとは");
            puts("ラベルと呼ばれるものを作り");
            puts("それを指定することで");
            puts("そこまで飛べる簡単に言えば");
            puts("ショートカットすることができる");
            puts("関数です");
            puts("ってことで使い方はこんな感じ");
            puts("");
            puts("Ravel1:");
            puts("	関数など");
            puts("Ravel2:");
            puts("	関数など");
            puts("");
            puts("goto Ravel1;");
            puts("");
            puts("使い方はこんな感じなのですが");
            puts("見た目はswitchと似てますが全然違います");
            puts("そしてラベルを定義するには");
            puts("");
            puts("ラベル名:");
            puts("");
            puts("で定義する必要があります");
            puts("そしてラベルに飛ぶには");
            puts("");
            puts("goto ラベル名;");
            puts("");
            puts("になります");
            puts("それとラベルは別にプログラムの行動を制限するものではないので");
            puts("gotoを使わずともラベルとラベルは移動できます");
            puts("");
            puts("-----<型変換>-----");
            puts("型変換とは");
            puts("int型やchar型を一時的に別の形に変えることで");
            puts("使い方はこんな感じ");
            puts("");
            puts("(一時的に変えたい型)変数名または値");
            puts("");
            puts("というようになります");
            puts("ちなみにprintf()関数などで");
            puts("数字や文字を出力するときは");
            puts("同じ型でないとうまく表示されないので");
            puts("型を変換するとよいでしょう");
            puts("");
            puts("-----<配列>-----");
            puts("配列とは");
            puts("同じ名前の変数に別々の値を割り当てていくことができる形です");
            puts("使い方はこんな感じ");
            puts("");
            puts("型 変数名[サイズ];");
            puts("");
            puts("型はintとかのあれです");
            puts("変数名もそのまま");
            puts("サイズというものが");
            puts("同じ名前で複数の値を持つことのできる");
            puts("味噌なのですが");
            puts("このサイズというのは");
            puts("変数が持てる個別の数の個数ですね");
            puts("サイズが1の場合もともとの型のままです");
            puts("サイズが2の場合2個の別々の値を格納できます");
            puts("ちなみに配列のサイズには最後のサイズにはヌル文字が入るので");
            puts("2サイズ宣言したら");
            puts("0と1のサイズの場所にしか数値が入れられません");
            puts("2の場所にはヌル文字が入るので");
            puts("そしてこのサイズは変数を宣言したときにしか数を指定できないのです");
            puts("それとこの配列ですが");
            puts("");
            puts("型 変数名[サイズ1][サイズ2];");
            puts("");
            puts("のように何個でも作ることができます");
            puts("しかしサイズの項目を4つ以上作るとメモリをかなり使います");
            puts("そして今までchar型は1文字分しか");
            puts("文字を入れられませんでしたが");
            puts("配列を使うことでいくらでも文字を入れることが可能になりました");
            puts("使い方はこんな感じ");
            puts("");
            puts("char 変数名[] = \"文字列\";");
            puts("");
            puts("ちなみに[]の中が空白なのは");
            puts("文字列に応じてサイズを確保するためです");
            puts("あぁ別にサイズ別に1つずつ文字を割り当てていっても文字列を");
            puts("割り当てることはできます");
            puts("それと");
            puts("数字をサイズ1個づつに入れたいとなった時");
            puts("一つ一つ入れるのは面倒くさいので");
            puts("もう少しいいやり方があります");
            puts("そのやり方がこれです");
            puts("");
            puts("型 変数名[サイズ] = {値1,値2,値3...}");
            puts("");
            puts("このようにしていけば1サイズに別々に値を入れていくことができます");
            puts("それとサイズですが");
            puts("変数に入れる値の数にしてもいいのですが");
            puts("サイズの数は空白でも");
            puts("システムが勝手にサイズを割り当ててくれます");
            puts("");
            puts("そして配列が来たことによって文字列が入れられるようになりましたが");
            puts("この文字列も配列することができます");
            puts("使い方はこんな感じです");
            puts("");
            puts("char 変数名[文字列の数][文字列1個の文字数] = {文字列,文字列,文字列...};");
            puts("");
            puts("この場合文字列は1個目の文字列の数に格納され");
            puts("各文字は文字列1個の文字数の場所に格納されます");
            puts("ちなみに");
            puts("");
            puts("char 変数名[文字列の塊の数][文字列の数][文字列1個の文字数] = ");
            puts("			{文字列,文字列}{文字列,文字列}");
            puts("");
            puts("のような形でも配列ができます");
            puts("文字列の塊の数は{}のセットの数");
            puts("文字列の数は{}の塊に");
            puts("文字列が何個存在するかの数");
            puts("文字列1個の文字数は全文字列の最大値でもいいのですが");
            puts("あふれても困るので大きな値にしておくといいでしょう");
            break;
        }        



        default:
        {
            if(No>=y)printf("%d番の説明は作成されていないか存在していません\n",No);
            break;
        }
    } 
}
void exe(char s){//実行例
    char a,b,c,x,y,z;
    puts("-----------実行例-----------");
    puts("-----------コード-----------");
    switch (No){
    case 1://y
        {
        puts("#include<stdio.h>");
        puts("");
        puts("int main()");
        puts("{");
        puts("char X=10;");
        puts("char Y=40;");
        puts("printf(\"%%dと%%dの足し算の結果は%%dです\",x,y,x+y);");
        puts("}");
        if(s=='t'){
            puts("");
            puts("xに入れる値を入れてください");
            scanf("%d",&x);
            puts("yに入れる値を入れてください");
            scanf("%d",&y);
            printf("変更完了 x=%d,y=%d\n",x,y);
            }
        else{
            y=10;
            x=40;
            }
        puts("\n-------プログラム実行中-------");
        printf("%dと%dの足し算の結果は%dです",x,y,x+y);

        break;  
        }
    case 2://y
        {    
        puts("#include<stdio.h>");
        puts("int main()");
        puts("{");
        puts("char x=50;");
        puts("int y;");
        puts("int X;");
        puts("int Y;");
        puts("int a;");
        puts("printf(\"x(%%d)に加算する数を入れてください\\n"",x);");
        puts("scanf(\"%%d\",&y);");
        puts("printf(\"x+yと大きさを比べる数を入れてください\\n"");");
        puts("scanf(\"%%d\",&Y);");
        puts("a=(x+y>=Y);");
        puts("if(a)printf(\"%%dは%%dより%%d大きいです\",x+y,Y,x+y-Y);");
        puts("if(!a)printf(\"%%dは%%dより%%d小さいです\",x+y,Y,Y-x+y);");
        puts("}");
        puts("}");
        if(s=='t'){
            puts("");
            puts("xに入れる値を入れてください");
            scanf("%d",&c);
            printf("変更完了 X=%d\n",c);
            }
        else{
            c=50;
            }
        puts("\n-------プログラム実行中-------");
        printf("x(%d)に加算する数を入れてください\n",c);
        scanf("%d",&b);
        printf("x+yと大きさを比べる数を入れてください\n");
        scanf("%d",&y);
        a=((c+b)>=y);
        if(a)printf("%dは%dより%d大きいです",c+b,y,c+b-y);
        if(!a)printf("%dは%dより%d小さいです",c+b,y,y-c+b);
        break;
        }
    case 3://y
    {
        puts("int main()");
        puts("{");
        puts("int x;");
        puts("x=(x==10);");
        puts("if(x)printf(\"xには10が入っています\");");
        puts("if(!x)printf(\"xは10ではありません x=%%d\",x);");
        puts("}");
        if(s=='t'){
            puts("");
            puts("xに入れる値を入れてください");
            scanf("%d",&x);
            printf("変更完了 x=%d\n",x);
            }
        puts("\n-------プログラム実行中-------");
        x=(x==10);
        if(x)printf("xには10が入っています\n");
        if(!x)printf("xは10ではありません x=%d\n",x);
        break;
    }
    case 4://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include<stdio.h>");
        puts("");
        puts("int main()");
        puts("{");
        puts("int x;");
        puts("printf(\"xに入れる数字を入れてください\n\");");
        puts("scanf(\"%%d\",&x);");
        puts("printf(\"xは%%dです\n\",x);");
        puts("}");
        puts("\n-------プログラム実行中-------");
        printf("xに入れる数字を入れてください\n");
        scanf("%d",&x);
        printf("xは%dです\n",x);
        break;
    }
    case 5://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include<stdio.h>");
        puts("");
        puts("int main()");
        puts("{");
        puts("int x;");
        puts("printf(\"今日はいい天気ですか？\\n\");");
        puts("printf(\"そうですね！=1/雨が降っています=2\\n\");");
        puts("scanf(\"%%d\",&x);");
        puts("switch(x)");
        puts("    {");
        puts("    case 1:");
        puts("    printf(\"今日はあつそうですね\\n\");");
        puts("    break;");
        puts("    case 2:");
        puts("    printf(\"傘が必要そうです\\n\");");
        puts("    break;");
        puts("    default:");
        puts("    printf(\"どっちですか？\\n\");");
        puts("    }");
        puts("}");
        puts("\n-------プログラム実行中-------");
        printf("今日はいい天気ですか？\n");
        printf("そうですね！=1/雨が降っています=2\n");
        scanf("%d",&x);
        switch(x)
            {
            case 1:
            printf("今日はあつそうですね\n");
            break;
            case 2:
            printf("傘が必要そうです\n");
            break;
            default:
            printf("どっちですか？\n");
	        }
        break;
    }
    case 6://y
    {
        printf("#include<stdio.h>\n");
        printf("\n");
        printf("int main()\n");
        printf("{\n");
        printf("int x;\n");
        printf("for (x=1;x<=10;x++)\n");
        printf("    {\n");
        printf("    printf(\"x=%%d\\n\",x);\n");
        printf("    }\n");
        printf("}\n");
        if(s=='t'){
            puts("");
            puts("繰り返す回数を入れてください");
            scanf("%d",&y);
            printf("変更完了 繰り返す回数=%d\n",y);
            }
        else{
            y=10;
            }
        puts("\n-------プログラム実行中-------");
        for (x=1;x<=y;x++)
	        {
	        printf("x=%d\n",x);
	        }
        break;
    }
    case 7://y
    {
        puts("#include<stdio.h>");
        puts("");
        puts("int main()");
        puts("{");
        puts("int x;");
        puts("while(x){");
        puts("printf(\"x=%%d\\n\",x);");
        puts("if(x==10)printf(\"10!\");");
        puts("if(x==50)break;");
        puts("x++;");
        puts("}");
        puts("}");
        if(s=='t'){
            puts("");
            puts("繰り返す回数");
            scanf("%d",&y);
            printf("変更完了 繰り返す回数=%d\n",y);
        }
        puts("\n-------プログラム実行中-------");
        while(x){
            printf("x=%d\n",x);
            if(x==10)printf("10!");
            if(x==50)break;
            x++;
            }
    }
    case 8://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include<stdio.h>");
        puts("");
        puts("int main()");
        puts("{");
        puts("int x;");
        puts("printf(\"xに入れる値を入れてください\\n\");");
        puts("scanf(\"%%d\",&x);");
        puts("if(x>1000)printf(\"xは1000より大きいです\\n\");");
        puts("else{");
        puts("if(x>100)printf(\"xは100より大きいです\\n\");");
        puts("else{");
        puts("printf(\"xは100より小さいです\\n\");");
        puts("}");
        puts("}");
        puts("}");
        puts("\n-------プログラム実行中-------");
        printf("xに入れる値を入れてください\n");
        scanf("%d",&x);
        if(x>1000)printf("xは1000より大きいです\n");
        else{
            if(x>100)printf("xは100より大きいです\n");
            else{
                printf("xは100より小さいです\n");
                }
            }
        break;
    }
    case 9://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include<stdio.h>");
        puts("");
        puts("int main()");
        puts("{");
        puts("int x,y;");
        puts("printf(\"x 1or0\\n\");");
        puts("scanf(\"%%d\",&x);");
        puts("printf(\"y 1or0\\n\");");
        puts("scanf(\"%%d\",&y);");
        puts("if(x||y)printf(\"今は真です\\n\");");
        puts("if(!(x&&y))printf(\"今は偽です\\n\");");
        puts("}");
        puts("\n-------プログラム実行中-------");
        printf("x 1or0\n");
        scanf("%d",&x);
        printf("y 1or0\n");
        scanf("%d",&y);
        if(x||y)printf("今は真です\n");
        if(!(x&&y))printf("今は偽です\n");
        break;
    }
    case 10://y
    {
        puts("#include<stdio.h>");
        puts("");
        puts("int main()");
        puts("{");
        puts("char x=0;");
        puts("for(;;){");
        puts("x++;");
        puts("printf(\"%%d回目の周回です\\n\",x);");
        puts("if(x>=10)break;");
        puts("}");
        puts("}");
        if(s=='t'){
            puts("xの初めの値を入れてください");
            scanf("%d",&x);
            puts("繰り返す回数を入れてください");
            scanf("%d",&y);
            if(x>y){
                while(x>y){
                    printf("繰り返す回数はxより大きくしてください X=%d\n",x);
                    scanf("%d",&y);
                }
            }
            printf("変更完了 X=%d,繰り返す回数=%d\n",x,y);

        }
        else{
            x=0;
            y=10;
        }
        puts("\n-------プログラム実行中-------");
        for(;;){
            x++;
            printf("%d回目の周回です\n",x);
            if(x>=y)break;
            }
        break;
    }
    case 11://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#inclde<stdio.h>");
        puts("");
        puts("int main()");
        puts("{");
        puts("int x,y;");
        puts("do{");
        puts("printf(\"xに入れる数字を入れてください\\n\");");
        puts("scanf(\"%%d\",x);");
        puts("if((x<=0)||(x>=1000)){");
        puts("printf(\"0〜1000まででお願いします\\n\");");
        puts("continue;");
        puts("}");
        puts("}while(0);");
        puts("printf(\"正確な数字です\\n\");");
        puts("break;");
        puts("}");
        puts("return 0;");
        puts("}");
        puts("\n-------プログラム実行中-------");
        do{
            printf("xに入れる数字を入れてください\n");
            scanf("%d",&x);
            if((x<=0)||(x>=1000)){
                printf("0〜1000まででお願いします\n");
                continue;
                }
            }while(0);
            printf("正確な数字です\n");
            break;
    }
    case 12://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include<stdio.h>");
        puts("");
        puts("int main()");
        puts("{");
        puts("int x;");
        puts("start:");
        puts("x++;");
        puts("printf(\"%%d\",x);");
        puts("if(x>=50)goto end;");
        puts("else goto start;");
        puts("end:");
        puts("printf(\"system shut dowun\\n\");");
        puts("return 0;");
        puts("}");
        puts("\n-------プログラム実行中-------");
        start:
        x++;
        printf("%d",x);
        if(x>=50)goto end;
        else goto start;
        end:
        printf("system shut dowun\n");
        break;
    }
    case 13://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include<stdio.h>");
        puts("");
        puts("int main()");
        puts("{");
        puts("short x=10000;");
        puts("long y=100000;");
        puts("double z=100000;");
        puts("unsigned short X=40000;");
        puts("unsigned long Y=2093049594;");
        puts("signed short Z=-1;");
        puts("signed long Q=-50000;");
        puts("");
        puts("printf(\"x=%%hd\\ny=%%ld\\nz=%%f\\nX=%%hu\\nY=%%lu\\nZ=%%d\\nQ=%%d\",x,y,z,X,Y,Z,Q);");
        puts("}");
        puts("\n-------プログラム実行中-------");
        short x=10000;
        long y=100000;
        double z=100000;
        unsigned short X=40000;
        unsigned long Y=2093049594;
        signed short Z=-1;
        signed long Q=-50000;

        printf("x=%hd\ny=%ld\nz=%f\nX=%hu\nY=%lu\nZ=%d\nQ=%d",x,y,z,X,Y,Z,Q);
        break;
    }
    case 14://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include<stdio.h>");
        puts("");
        puts("int main()");
        puts("{");
        puts("int x{5};");
        puts("x[0]=1;");
        puts("x[1]=10;");
        puts("x[2]=100;");
        puts("x[3]=1000;");
        puts("x[4]=10000;");
        puts("printf(\"%%d\\n%%d\\n%%d\\n%%d\\n%%d\\n\",x[0],x[1],x[2],x[3],x[4]);");
        puts("return 0;");
        puts("}");
        puts("\n-------プログラム実行中-------");
        int z[5];
        z[0]=1;
        z[1]=10;
        z[2]=100;
        z[3]=1000;
        z[4]=10000;
        printf("%d\n%d\n%d\n%d\n%d\n");
        break;
    }
    case 15://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include<stdio.h>");
        puts("");
        puts("int main()");
        puts("{");
        puts("int x[2][2];");
        puts("x[0][0]=10;");
        puts("x[0][1]=100;");
        puts("x[1][0]=1000;");
        puts("x[1][1]=10000;");
        puts("printf(\"%%d %%d\\n%%d %%d\",x[0][0],x[0][1],x[1][0],x[1][1]);");
        puts("} ");
        puts("\n-------プログラム実行中-------");
        int q[2][2];
        q[0][0]=10;
        q[0][1]=100;
        q[1][0]=1000;
        q[1][1]=10000;
        printf("%d %d\n%d %d",q[0][0],q[0][1],q[1][0],q[1][1]);
    }
    case 16://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include<stdio.h>");
        puts("");
        puts("int main()");
        puts("{");
        puts("char x[5];");
        puts("x[0]=\'h\';");
        puts("x[1]=\'e\';");
        puts("x[2]=\'l\';");
        puts("x[3]=x[2];");
        puts("x[4]=\'o\';");
        puts("x[5]=0;");
        puts("");
        puts("printf(x);");
        puts("return 0;");
        puts("}");
        puts("\n-------プログラム実行中-------");
        char a[5];
        a[0]='h';
        a[1]='e';
        a[2]='l';
        a[3]=a[2];
        a[4]='o';
        a[5]=0;

        printf(a);
    }
    case 17://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include<stdio.h>");
        puts("");
        puts("int main(){");
        puts("char x[][2][128]={");
        puts("{\"hello\",\"world\"},");
        puts("{\"こんにちは\",\"こんばんは\"},");
        puts("{\"おはよう"",""おやすみ\"}");
        puts("};");
        puts("printf(\"%%s\\t%%s\\n\",x[0][0],x[0][1]);");
        puts("printf(\"%%s\\t%%s\\n\",x[1][0],x[1][1]);");
        puts("printf(\"%%s\\t%%s\\n\",x[2][0],x[2][1]);");
        puts("}");
        puts("\n-------プログラム実行中-------");
        char D[3][2][128]={
            {"hello","world"},
            {"こんにちは","こんばんは"},
            {"おはよう","おやすみ"}
            };
            printf("%s\t%s\n",D[0][0],D[0][1]);
            printf("%s\t%s\n",D[1][0],D[1][1]);
            printf("%s\t%s\n",D[2][0],D[2][1]);
        break;
    }
    case 18://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("int main()");
        puts("{");
        puts("    int *po , var;");
        puts("    var = 100;");
        puts("    po = &var;");
        puts("");
        puts("    *po = 1010;");
        puts("    printf(\"変数varの値 = %%d\" , var);");
        puts("");
        puts("    return 0;");
        puts("}");
        puts("\n-------プログラム実行中-------");
        int *po , var;
        var = 100;
        po = &var;
        *po = 1010;
        printf("変数varの値 = %d" , var);
        break;
    }
    case 19://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("int main()");
        puts("{");
        puts("int ary[2] = { 1000 , 2000 };");
        puts("int *po;");
        puts("");
        puts("po = &ary[0];");
        puts("printf(\"po\\t = %%x\\n\" , po);");
        puts("po++;");
        puts("printf(\"po++\\t = %%x\\n\" , po);");
        puts("printf(\"*po++\\t = %%d\" , *po);");
        puts("");
        puts("return 0;");
        puts("}");
        puts("\n-------プログラム実行中-------");
        int ary[2] = { 1000 , 2000 };
        int *po;

        po = &ary[0];
        printf("po\t = %x\n" , po);
        po++;
        printf("po++\t = %x\n" , po);
        printf("*po++\t = %d" , *po);
        break;
    }
    case 20://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("int main() {");
        puts("int ary[3] = { 10,20,30 };");
        puts("int *ary_p;");
        puts("ary_p = ary;");
        puts("");
        puts("printf(\"間接参照\\t=%%d,%%d,%%d\\n\", *ary_p , *(ary_p + 1) , *(ary_p + 2));");
        puts("printf(\"添え字指定\\t=%%d,%%d,%%d\" , ary[0] , ary[1] , ary[2]);");
        puts("return 0;");
        puts("\n-------プログラム実行中-------");
        int ary[3] = { 10,20,30 };
        int *ary_p;
        ary_p = ary;

        printf("間接参照\t=%d,%d,%d\n", *ary_p , *(ary_p + 1) , *(ary_p + 2));
        printf("添え字指定\t=%d,%d,%d" , ary[0] , ary[1] , ary[2]);
        break;
    }
    case 21://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("int main() {");
        puts("char *str = ""kitty on your lap"";");
        puts("");
        puts("printf(\"先頭アドレス = %%c\n\",*str);");
        puts("printf(\"格納文字列 = %%s\" , str);");
        puts("");
        puts("return 0;");
        puts("}");
        puts("\n-------プログラム実行中-------");
        char *str = "kitty on your lap";

        printf("先頭アドレス = %c\n",*str);
        printf("格納文字列 = %s" , str);
        break;
    }
    case 22://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("int main() {");
        puts("        int get_n;");
        puts("        char *ary[] = { \"暇人\" , \"人間\" , \"宇宙人\" };");
        puts("        printf(\"あなたは誰ですか？\\n\");");
        puts("        printf(\"暇人 = 1\\n人間 = 2\\n宇宙人 = 3\\n\");");
        puts("        printf(\"1〜3の半角英数>\");");
        puts("");
        puts("        scanf(\"%%d\",&get_n);");
        puts("        if (( get_n <= 3 ) && ( get_n >= 1))");
        puts("");
        puts("                printf(\"あなたは%%sさんなんですね!\" , ary[get_n - 1]);");
        puts("        else printf(\"不正な値です\");");
        puts("");
        puts("        return 0;");
        puts("}");
        puts("\n-------プログラム実行中-------");
        int get_n;
        char *ary[] = { "暇人" , "人間" , "宇宙人" };
        printf("あなたは誰ですか？\n");
        printf("暇人 = 1\n人間 = 2\n宇宙人 = 3\n");
        printf("1〜3の半角英数>");

        scanf("%d",&get_n);
        if (( get_n <= 3 ) && ( get_n >= 1))

                printf("あなたは%sさんなんですね!" , ary[get_n - 1]);
        else printf("不正な値です");
        break;
    }
    case 23://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("int main() {");
        puts("    char str[] = \"kitty on your lap\";");
        puts("    char *str_p;");
        puts("    char **str_pp;	/*ポインタのポインタ*/");
        puts("");
        puts("    str_p = str;");
        puts("    str_pp = &str_p;");
        puts("");
        puts("    printf(\"文字型配列変数\\n\");");
        puts("    printf(\"配列先頭アドレス = %%x\\n\" , str);");
        puts("    printf(\"保持する文字列 = %%s\\n\\n\" , str);");
        puts("");
        puts("    printf(\"ポインタの示す値\\n\");");
        puts("    printf(\"ポインタアドレス = %%x\\n\" , &str_p);");
        puts("    printf(\"保存する値 = %%x\\n\" , str_p);");
        puts("    printf(\"保持するアドレスが持つ内容 = %%s\\n\\n\" , str_p);");
        puts("");
        puts("    printf(\"ポインタのポインタが示す値\\n\");");
        puts("    printf(\"保持する値 = %%x\\n\" , str_pp);");
        puts("    printf(\"保持する値が持つ値 = %%x\\n\" , *str_pp);");
        puts("    printf(\"保持する値が持つ値の内容 = %%s\", *str_pp);");
        puts("");
        puts("    return 0;");
        puts("}");
        puts("\n-------プログラム実行中-------");
        char str[] = "kitty on your lap";
        char *str_p;
        char **str_pp;	/*ポインタのポインタ*/

        str_p = str;
        str_pp = &str_p;

        printf("文字型配列変数\n");
        printf("配列先頭アドレス = %x\n" , str);
        printf("保持する文字列 = %s\n\n" , str);

        printf("ポインタの示す値\n");
        printf("ポインタアドレス = %x\n" , &str_p);
        printf("保存する値 = %x\n" , str_p);
        printf("保持するアドレスが持つ内容 = %s\n\n" , str_p);

        printf("ポインタのポインタが示す値\n");
        printf("保持する値 = %x\n" , str_pp);
        printf("保持する値が持つ値 = %x\n" , *str_pp);
        printf("保持する値が持つ値の内容 = %s", *str_pp);
        break;
    }
    case 24://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("void func() {");
        puts("        printf(\"kitty on your lap\");");
        puts("}");
        puts("");
        puts("int main() {");
        puts("        func();");
        puts("        return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 25://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("void func(void);");
        puts("");
        puts("int main() {");
        puts("        func();");
        puts("        return 0;");
        puts("}");
        puts("");
        puts("void func() {");
        puts("printf(\"kitty on your lap\");");
        puts("実行例が作成されていません");
        break;
    }
    case 26://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("int func(int var1 , int var2);");
        puts("");
        puts("int main() {");
        puts("int var;");
        puts("var = func(13 , 17);");
        puts("");
        puts("printf(\"戻ってきた値 = %%d\" , var);");
        puts("");
        puts("return 0;");
        puts("}");
        puts("");
        puts("int func(int var1 , int  var2 ) {");
        puts("return var1 + var2;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 27://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include<stdio.h>");
        puts("");
        puts("void func(void);");
        puts("");
        puts("int var = 10;");
        puts("");
        puts("int main() {");
        puts("printf(\"main() : varのアドレス = %%x\\n\" , &var);");
        puts("printf(\"main() : varの内容 = %%d\\n\" , var);");
        puts("func();");
        puts("var = 100;");
        puts("func();");
        puts("");
        puts("return 0;");
        puts("}");
        puts("");
        puts("void func() {");
        puts("printf(\"func() : varのアドレス = %%x\\n\" , &var);");
        puts("printf(\"func() : varの内容 = %%d\\n\" , var);");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 28://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include<stdio.h>");
        puts("");
        puts("void func(int );");
        puts("");
        puts("int main() {");
        puts("func(0);");
        puts("");
        puts("printf(\"プログラムを終了します\");");
        puts("return 0;");
        puts("}");
        puts("");
        puts("void func(int max) {");
        puts("if (max <= 10000) {");
        puts("        printf(\"%%d\\r\",max);");
        puts("        func(max + 1);");
        puts("}");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 29://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include<stdio.h>");
        puts("");
        puts("void call_by_value(int );");
        puts("void call_by_reference(int *);");
        puts("");
        puts("int main() {");
        puts("    int var = 10;");
        puts("");
        puts("    call_by_value(var);");
        puts("    printf(\"値渡し後 = %%d\n\" , var);");
        puts("");
        puts("    call_by_reference(&var);");
        puts("    printf(\"参照渡し後 = %%d\" , var);");
        puts("");
        puts("    return 0;");
        puts("}");
        puts("");
        puts("void call_by_value(int var) {");
        puts("    var = 100;");
        puts("}");
        puts("");
        puts("void call_by_reference(int *var) {");
        puts("    *var = 100;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 30://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include<stdio.h>");
        puts("");
        puts("int main(int argc , char *argv[]) {");
        puts("        int count = 0;");
        puts("        while (count < argc) {");
        puts("                printf(\"第%%d引数 = %%s\\n\" , count + 1 , argv[count]);");
        puts("                count++;");
        puts("        }");
        puts("        return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 31://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("int max(int , int );");
        puts("");
        puts("int main() {");
        puts("    int r_var , var1 , var2;");
        puts("");
        puts("    printf(\"最初の値を入力してください>\");");
        puts("    scanf(\"%%d\" , &var1);");
        puts("    printf(\"比較する値を入力してください>\");");
        puts("    scanf(\"%%d\" , &var2);");
        puts("");
        puts("    r_var = max(var1,var2);");
        puts("    printf(\"%%dのほうが大きいです\",r_var);");
        puts("");
        puts("    return 0;");
        puts("}");
        puts("");
        puts("int max(var1 , var2)");
        puts("int var1,var2;");
        puts("{");
        puts("    if (var1 > var2) return var1;");
        puts("    if (var2 > var1) return var2;");
        puts("    else return var1;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 32://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("struct LOVE_HINA {");
        puts("        char *name;");
        puts("        int age;");
        puts("}naru , sinobu;");
        puts("");
        puts("int main() {");
        puts("        struct LOVE_HINA motoko;");
        puts("        naru.name = \"成瀬川なる\";");
        puts("        naru.age = 17;");
        puts("        sinobu.name = \"前原しのぶ\";");
        puts("        sinobu.age = 13;");
        puts("        motoko.name = \"青山素子\";");
        puts("        motoko.age = 15;");
        puts("");
        puts("        printf(\"名前\t\t年齢\n\");");
        puts("        printf(\"%%s\\t%%d\\n\" , naru.name , naru.age);");
        puts("        printf(\"%%s\\t%%d\\n\" , sinobu.name , sinobu.age);");
        puts("        printf(\"%%s\\t%%d\\n\" , motoko.name , motoko.age);");
        puts("");
        puts("        return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 33://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("struct LOVE_HINA {");
        puts("    char *name;");
        puts("    int age;");
        puts("}naru , sinobu;");
        puts("");
        puts("void func(struct LOVE_HINA);");
        puts("struct LOVE_HINA LOVE_HINA(char * , int);");
        puts("");
        puts("int main() {");
        puts("    struct LOVE_HINA motoko;");
        puts("");
        puts("    naru = LOVE_HINA(\"成瀬川なる\" , 17);");
        puts("    sinobu = LOVE_HINA(\"前原しのぶ\" , 13);");
        puts("    motoko = LOVE_HINA(\"青山素子\" , 15);");
        puts("    ");
        puts("    printf(\"名前\\t\\t年齢\\n\");");
        puts("    func(naru);");
        puts("    func(sinobu);");
        puts("    func(motoko);");
        puts("");
        puts("    return 0;");
        puts("}");
        puts("");
        puts("void func(struct LOVE_HINA hina) {");
        puts("    printf(\"%%s\\t%%d\\n\",hina.name , hina.age);");
        puts("}");
        puts("");
        puts("struct LOVE_HINA LOVE_HINA(char *name , int age) {");
        puts("    struct LOVE_HINA hina;");
        puts("    hina.name = name;");
        puts("    hina.age = age;");
        puts("");
        puts("    return hina;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 34://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("struct LOVE_HINA {");
        puts("    char *name;");
        puts("    int age;");
        puts("};");
        puts("");
        puts("struct LOVE_HINA LOVE_HINA(char * , int);");
        puts("void write(struct LOVE_HINA *);");
        puts("");
        puts("int main() {");
        puts("    struct LOVE_HINA naru = LOVE_HINA(\"成瀬川なる\", 17);");
        puts("    struct LOVE_HINA sinobu = LOVE_HINA(\"前原しのぶ\" , 13);");
        puts("    printf(\"名前\\t\\t年齢\\n\");");
        puts("    write(&naru);");
        puts("    write(&sinobu);");
        puts("");
        puts("    return 0;");
        puts("}");
        puts("");
        puts("struct LOVE_HINA LOVE_HINA(char name[] , int age) {");
        puts("    struct LOVE_HINA obj;");
        puts("    obj.name = name;");
        puts("    obj.age = age;");
        puts("    return obj;");
        puts("}");
        puts("");
        puts("void write(struct LOVE_HINA *obj) {");
        puts("    printf(\"%%s\\t%%d\\n\" , obj->name , obj->age);");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 35://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("struct Param {");
        puts("    char *name;");
        puts("    int age;");
        puts("};");
        puts("");
        puts("struct LOVE_HINA {");
        puts("    struct Param hina;");
        puts("}naru , sinobu;");
        puts("");
        puts("struct LOVE_HINA2 {");
        puts("    char *tabacco;");
        puts("    struct Param hina;");
        puts("}haruka;");
        puts("");
        puts("void Param(struct Param * , char * , int);");
        puts("");
        puts("int main() {");
        puts("    printf(\"名前\\t\\t年齢\n\");");
        puts("    Param(&naru.hina , \"成瀬川なる\" , 17);");
        puts("    Param(&sinobu.hina , \"前原しのぶ\" , 13);");
        puts("    Param(&haruka.hina , \"浦島はるか\" , 27);");
        puts("    haruka.tabacco = \"マルボ○\";");
        puts("    printf(\"はるかさん、タバコは%%sらしい…\" , haruka.tabacco);");
        puts("");
        puts("    return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 36://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("struct {");
        puts("        unsigned bool: 1;");
        puts("}Boolean;");
        puts("");
        puts("int main() {");
        puts("        Boolean.bool = 2;");
        puts("        printf(\"2 = %%d\\n\" , Boolean.bool);");
        puts("");
        puts("        Boolean.bool = 3;");
        puts("        printf(\"3 = %%d\" , Boolean.bool);");
        puts("");
        puts("        return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }  
    case 37://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("union UNION {");
        puts("        char ch;");
        puts("        int n;");
        puts("        double m;");
        puts("};");
        puts("");
        puts("int main() {");
        puts("        union UNION obj;");
        puts("        obj.m = 0;");
        puts("");
        puts("        obj.ch = '@';");
        puts("        printf(\"%%c : %%d : %%g\\n\" , obj.ch , obj.n , obj.m);");
        puts("        obj.n++;");
        puts("        printf(\"%%c : %%d : %%g\\n\" , obj.ch , obj.n , obj.m);");
        puts("        obj.m = 3.26083e-322;");
        puts("        printf(\"%%c : %%d : %%g\\n\" , obj.ch , obj.n , obj.m);");
        puts("");
        puts("        return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 38://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("#define YUKI \"Kitty on your lap\\n\"");
        puts("");
        puts("int main() {");
        puts("        #ifdef YUKI");
        puts("                printf(YUKI);");
        puts("        #endif");
        puts("");
        puts("        #undef YUKI");
        puts("");
        puts("        #ifdef YUKI");
        puts("                printf(YUKI);");
        puts("      #else");
        puts("              printf(\"ひざの上の同居人\");");
        puts("      #endif");
        puts("      return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 39://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("int main() {");
        puts("        #if 0");
        puts("                printf(\"Kitty on your lap\\n\");");
        puts("        #elif 1");
        puts("                printf(\"Back To Your True Shape\\n\");");
        puts("        #endif");
        puts("        printf(\"CLOW CARD\");");
        puts("        return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 40://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("#define PRINT(str) printf(#str \"\\n\")");
        puts("#define STRING(str) #str");
        puts("");
        puts("int main() {");
        puts("        PRINT(Kitty on your lap);");
        puts("        printf(\"%%sバイトは1キロバイト\" , STRING(1024));");
        puts("");
        puts("        return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 41://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("#include <stdlib.h>");
        puts("");
        puts("int main() {");
        puts("        char fileName[128];");
        puts("        FILE *fp;");
        puts("");
        puts("        printf(\"ファイル名を入力してください>\");");
        puts("        scanf(\"%%s\" , fileName);");
        puts("");
        puts("        fp = fopen(fileName , \"r\");");
        puts("        if (fp == NULL) {");
        puts("                printf(\"ファイルが開けませんでした\");");
        puts("                exit (1);");
        puts("        }");
        puts("        printf(\"ファイルのオープンに成功しました\");");
        puts("");
        puts("        fclose(fp);");
        puts("        return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 42://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("int main() {");
        puts("        char str[] = \"Kitty on your lap\\n\";");
        puts("        char er[] = \"エラーです : 猫耳を愛しましょう\";");
        puts("        int count ;");
        puts("");
        puts("        for (count = 0 ; str[count] != 0 ; count++) {");
        puts("                fputc(str[count] , stdout);");
        puts("        }");
        puts("        for (count = 0 ; er[count] != 0 ; count++){");
        puts("                fputc(er[count] , stderr);");
        puts("        }");
        puts("        return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 43://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("#include <stdlib.h>");
        puts("");
        puts("int main() {");
        puts("	char fileName[128] , saveName[128];");
        puts("	int text;");
        puts("	FILE *load , *save;");
        puts("");
        puts("	printf(\"コピーしたいファイル名を入れてください>\");");
        puts("	scanf(\"%%s\" , fileName);");
        puts("");
        puts("	if ((load = fopen(fileName , \"r\")) == NULL) {");
        puts("		printf(\"ファイルを開けませんでした\");");
        puts("		exit(1);");
        puts("	}");
        puts("");
        puts("	printf(\"コピーファイル名を入力してください\n存在する場合は内容を破壊します>\");");
        puts("	scanf(\"%s\" , saveName);");
        puts("	");
        puts("	if ((save = fopen(saveName , \"w\")) == NULL) {");
        puts("		printf(\"書き込みに失敗しました\");");
        puts("		exit(1);");
        puts("	}");
        puts("");
        puts("	while(1) {");
        puts("		text = fgetc(load);");
        puts("		if(!feof(load)) fputc(text , save);");
        puts("		else break;");
        puts("	}");
        puts("");
        puts("	fclose(load);");
        puts("	fclose(save);");
        puts("	return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 44://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("struct TEST {");
        puts("        unsigned int bit:8 ;");
        puts("}obj;");
        puts("");
        puts("int main() {");
        puts("        printf(\"obj = %%d\\n\" , sizeof(obj));");
        puts("        printf(\"struct TEST = %%d\" , sizeof(struct TEST));");
        puts("        return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 45://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("void outString(void *);");
        puts("");
        puts("int main() {");
        puts("        int i = 65 ;");
        puts("        double d = 10.101;");
        puts("");
        puts("        outString(&i);");
        puts("        outString(&d);");
        puts("        outString(\"Kitty on your lap\");");
        puts("");
        puts("        return 0;");
        puts("}");
        puts("");
        puts("void outString(void *text) {");
        puts("        char *str = (char *)text;");
        puts("        printf(\"%%s\\n\" , str);");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 46://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("#include <stdlib.h>");
        puts("");
        puts("int main() {");
        puts("        char i[] = { 65 , 66 , 67 , 68 , 69 , 70 };");
        puts("");
        puts("        fwrite(&i , sizeof(char) , 6 , stdout);");
        puts("        printf(\"\\n\");");
        puts("        fwrite(&i , sizeof(char)+1 , 3 ,stdout);");
        puts("");
        puts("        return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 47://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("#include <stdlib.h>");
        puts("");
        puts("int main() {");
        puts("        int i[] = { 100 , 200 , 300 };");
        puts("        FILE *fp;");
        puts("");
        puts("        if ((fp = fopen(\"test.txt\" , \"wb\")) == NULL) {");
        puts("                fprintf(stderr , \"ファイル操作でエラーが発生\");");
        puts("                exit(1);");
        puts("        }");
        puts("");
        puts("        fseek(fp , 1024 , SEEK_SET);");
        puts("");
        puts("        fwrite(i , 4 , 3 , fp);");
        puts("        fclose(fp);");
        puts("        return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 48://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("void func(void);");
        puts("");
        puts("int main() {");
        puts("        int count;");
        puts("");
        puts("        for (count = 0 ; count < 1000 ; count++) func();");
        puts("");
        puts("        return 0;");
        puts("}");
        puts("");
        puts("void func() {");
        puts("        static int count = 1;");
        puts("        printf(\"%%d\\n\" , count);");
        puts("        count++;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 49://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("enum Kitty { MIMI , YUKI = 5 , RENA } cats;");
        puts("");
        puts("int main() {");
        puts("        cats = RENA;");
        puts("");
        puts("        switch(cats) {");
        puts("        case MIMI:");
        puts("                printf(\"ミミ\");");
        puts("                break;");
        puts("        case YUKI:");
        puts("                printf(\"ユキ\");");
        puts("                break;");
        puts("        case RENA:");
        puts("                printf(\"レナ\");");
        puts("        }");
        puts("");
        puts("        return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 50://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("int main() {");
        puts("        const char str[] = \"Kitty on your lap\";");
        puts("        printf(str);");
        puts("");
        puts("        return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 51://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("int main() {");
        puts("        char i = 100;");
        puts("        printf(\"%%d\\n\" , i >> 2);");
        puts("        printf(\"%%d\" , i << 1);");
        puts("        return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 52://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("void kitty(void);");
        puts("void sakura(void);");
        puts("void hina(void);");
        puts("");
        puts("int main() {");
        puts("	void (*po[])() = { kitty , sakura , hina };");
        puts("	int i;");
        puts("");
        puts("	printf(\"実行する関数の番号を指定してください 0〜2>\");");
        puts("	scanf(\"%%d\" , &i);");
        puts("	if ((i < 0) | (i > 2)) return 0;");
        puts("	(*po[i])();");
        puts("	return 0;");
        puts("}");
        puts("");
        puts("void kitty() {");
        puts("	printf(\"Kitty on your lap\\n\");");
        puts("}");
        puts("");
        puts("void sakura() {");
        puts("	printf(\"Card Captor SAKURA\");");
        puts("}");
        puts("");
        puts("void hina() {");
        puts("	printf(\"LOVE HINA\");");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 53://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("#include <stdlib.h>");
        puts("#include <string.h>");
        puts("");
        puts("int main() {");
        puts("	char *po;");
        puts("	po = (char *)calloc(128 , sizeof(char));");
        puts("	if (po == NULL) exit(1);");
        puts("");
        puts("	strcpy(po , \"Kitty on your lap\");");
        puts("	printf(\"%%s\" , po);");
        puts("	free(po);");
        puts("	return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 54://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("typedef const char final;");
        puts("typedef FILE stream;");
        puts("typedef signed int Integer;");
        puts("");
        puts("int main() {");
        puts("        final str[] = \"Kitty on your lap\";");
        puts("        stream *fp;");
        puts("        Integer i = 10;");
        puts("");
        puts("        return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 55://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("int main() {");
        puts("        printf(\"%%5.3s\\n\" , \"Kitty\");");
        puts("        printf(\"%%5.3d\\n\" , 1);");
        puts("        printf(\"%%.3e\\n\" , 10.10);");
        puts("        printf(\"%%.3f\\n\" , 10.10);");
        puts("        printf(\"%%.3g\\n\" , 10.10);");
        puts("        return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 56://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("int main() {");
        puts("	char ch;");
        puts("	int i , j;");
        puts("	printf(\"演算します。式を入力してください>\");");
        puts("	scanf(\"%%d %%[+-*/] %%d\" , &i , &ch , &j);");
        puts("");
        puts("	switch(ch) {");
        puts("	case '+':");
        puts("		printf(\"答えは %%d です\" , i + j);");
        puts("		break;");
        puts("	case '-':");
        puts("		printf(\"答えは %%d です\" , i - j);");
        puts("		break;");
        puts("	case '*':");
        puts("		printf(\"答えは %%d です\" , i * j);");
        puts("		break;");
        puts("	case '/':");
        puts("		printf(\"答えは %d です\" , i / j);");
        puts("		break;");
        puts("	default:");
        puts("		printf(\"入力に誤りがあります\");");
        puts("	}");
        puts("	return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 57://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("");
        puts("int main() {");
        puts("        char ch;");
        puts("        printf(\"文字を入力してください>\");");
        puts("        ch = getchar();");
        puts("        printf(\"入力された値 = \");");
        puts("        putchar(ch);");
        puts("        return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 58://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("#include <time.h>");
        puts("");
        puts("int main() {");
        puts("	time_t timeValue , timeTmp;");
        puts("	struct tm *timeObject;");
        puts("");
        puts("	while (1) {");
        puts("		if (time(&timeValue) != timeTmp) {");
        puts("			timeObject = localtime(&timeValue);");
        puts("");
        puts("			if (timeObject == NULL) {");
        puts("				puts(\"システム時刻が正常に得られません\");");
        puts("				break;");
        puts("			}");
        puts("");
        puts("			printf(\"%%2.2d : %%2.2d : %%2.2d\\r\" , timeObject->tm_hour ,");
        puts("				timeObject->tm_min , timeObject->tm_sec);");
        puts("		}");
        puts("		timeTmp = timeValue;");
        puts("	}");
        puts("		");
        puts("	return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 59://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("int main() {");
        puts("        int count;");
        puts("        srand((unsigned)time( NULL ));");
        puts("        for (count = 0 ; count < 10 ; count++) {");
        puts("                printf(\"%%d\\n\" , rand() %% 10);");
        puts("        }");
        puts("");
        puts("        return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    case 60://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include <stdio.h>");
        puts("#include <stdarg.h>");
        puts("");
        puts("void dynamicArgument(int , ...);");
        puts("");
        puts("int main() {");
        puts("	dynamicArgument(4 , 10 , 20 , 30 , 40);");
        puts("	return 0;");
        puts("}");
        puts("");
        puts("void dynamicArgument(int arg_num , ...) {");
        puts("	va_list args;");
        puts("	int value , count;");
        puts("");
        puts("	if (arg_num < 1) return;");
        puts("");
        puts("	va_start(args , arg_num);");
        puts("");
        puts("	for (count = 0 ; count < arg_num ; count++) {");
        puts("		value = va_arg(args , int);");
        puts("		printf(\"第%%d引数 = %%d\\n\" , count + 2 , value);");
        puts("	}");
        puts("");
        puts("	va_end(args);");
        puts("	return;");
        puts("}");
        puts("");
        puts("実行例が作成されていません");
        break;
    }
    case 61://n
    {
        if(s=='t'){
            printf("このプログラムは変更できません");
            break;
        }
        puts("#include<stdio.h>");
        puts("#include<stdlib.h>");
        puts("");
        puts("int main() {");
        puts("	char ch[] = \"Kitty on your lap\";");
        puts("	wchar_t wch[] = L\"Kitty on your lap\";");
        puts("");
        puts("	printf(\"char 型文字列 = %%d\\n\" , sizeof ch);");
        puts("	printf(\"wchar_t 型文字列 = %%d\\n\" , sizeof wch);");
        puts("	return 0;");
        puts("}");
        puts("実行例が作成されていません");
        break;
    }
    }
    puts("\n----------実行完了----------");
}

int error(int loop){//エラー検出
    if(loop>=100){
        printf("error001 不正な値を検出しました\n");
        return -1;
    }

}